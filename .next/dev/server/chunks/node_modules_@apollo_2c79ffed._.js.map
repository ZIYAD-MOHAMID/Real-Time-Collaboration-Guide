{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///E:/wark/Next.graphQL/nextTyar/node_modules/%40apollo/usage-reporting-protobuf/generated/esm/protobuf.js"],"sourcesContent":["/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/\nimport $protobuf from \"@apollo/protobufjs/minimal\";\n\n// Common aliases\nconst $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;\n\n// Exported root namespace\nconst $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n\nexport const Trace = $root.Trace = (() => {\n\n    /**\n     * Properties of a Trace.\n     * @exports ITrace\n     * @interface ITrace\n     * @property {google.protobuf.ITimestamp|null} [startTime] Trace startTime\n     * @property {google.protobuf.ITimestamp|null} [endTime] Trace endTime\n     * @property {number|null} [durationNs] Trace durationNs\n     * @property {Trace.INode|null} [root] Trace root\n     * @property {boolean|null} [isIncomplete] Trace isIncomplete\n     * @property {string|null} [signature] Trace signature\n     * @property {string|null} [unexecutedOperationBody] Trace unexecutedOperationBody\n     * @property {string|null} [unexecutedOperationName] Trace unexecutedOperationName\n     * @property {Trace.IDetails|null} [details] Trace details\n     * @property {string|null} [clientName] Trace clientName\n     * @property {string|null} [clientVersion] Trace clientVersion\n     * @property {Trace.IHTTP|null} [http] Trace http\n     * @property {Trace.ICachePolicy|null} [cachePolicy] Trace cachePolicy\n     * @property {Trace.IQueryPlanNode|null} [queryPlan] Trace queryPlan\n     * @property {boolean|null} [fullQueryCacheHit] Trace fullQueryCacheHit\n     * @property {boolean|null} [persistedQueryHit] Trace persistedQueryHit\n     * @property {boolean|null} [persistedQueryRegister] Trace persistedQueryRegister\n     * @property {boolean|null} [registeredOperation] Trace registeredOperation\n     * @property {boolean|null} [forbiddenOperation] Trace forbiddenOperation\n     * @property {number|null} [fieldExecutionWeight] Trace fieldExecutionWeight\n     */\n\n    /**\n     * Constructs a new Trace.\n     * @exports Trace\n     * @classdesc Represents a Trace.\n     * @implements ITrace\n     * @constructor\n     * @param {ITrace=} [properties] Properties to set\n     */\n    function Trace(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * Trace startTime.\n     * @member {google.protobuf.ITimestamp|null|undefined} startTime\n     * @memberof Trace\n     * @instance\n     */\n    Trace.prototype.startTime = null;\n\n    /**\n     * Trace endTime.\n     * @member {google.protobuf.ITimestamp|null|undefined} endTime\n     * @memberof Trace\n     * @instance\n     */\n    Trace.prototype.endTime = null;\n\n    /**\n     * Trace durationNs.\n     * @member {number} durationNs\n     * @memberof Trace\n     * @instance\n     */\n    Trace.prototype.durationNs = 0;\n\n    /**\n     * Trace root.\n     * @member {Trace.INode|null|undefined} root\n     * @memberof Trace\n     * @instance\n     */\n    Trace.prototype.root = null;\n\n    /**\n     * Trace isIncomplete.\n     * @member {boolean} isIncomplete\n     * @memberof Trace\n     * @instance\n     */\n    Trace.prototype.isIncomplete = false;\n\n    /**\n     * Trace signature.\n     * @member {string} signature\n     * @memberof Trace\n     * @instance\n     */\n    Trace.prototype.signature = \"\";\n\n    /**\n     * Trace unexecutedOperationBody.\n     * @member {string} unexecutedOperationBody\n     * @memberof Trace\n     * @instance\n     */\n    Trace.prototype.unexecutedOperationBody = \"\";\n\n    /**\n     * Trace unexecutedOperationName.\n     * @member {string} unexecutedOperationName\n     * @memberof Trace\n     * @instance\n     */\n    Trace.prototype.unexecutedOperationName = \"\";\n\n    /**\n     * Trace details.\n     * @member {Trace.IDetails|null|undefined} details\n     * @memberof Trace\n     * @instance\n     */\n    Trace.prototype.details = null;\n\n    /**\n     * Trace clientName.\n     * @member {string} clientName\n     * @memberof Trace\n     * @instance\n     */\n    Trace.prototype.clientName = \"\";\n\n    /**\n     * Trace clientVersion.\n     * @member {string} clientVersion\n     * @memberof Trace\n     * @instance\n     */\n    Trace.prototype.clientVersion = \"\";\n\n    /**\n     * Trace http.\n     * @member {Trace.IHTTP|null|undefined} http\n     * @memberof Trace\n     * @instance\n     */\n    Trace.prototype.http = null;\n\n    /**\n     * Trace cachePolicy.\n     * @member {Trace.ICachePolicy|null|undefined} cachePolicy\n     * @memberof Trace\n     * @instance\n     */\n    Trace.prototype.cachePolicy = null;\n\n    /**\n     * Trace queryPlan.\n     * @member {Trace.IQueryPlanNode|null|undefined} queryPlan\n     * @memberof Trace\n     * @instance\n     */\n    Trace.prototype.queryPlan = null;\n\n    /**\n     * Trace fullQueryCacheHit.\n     * @member {boolean} fullQueryCacheHit\n     * @memberof Trace\n     * @instance\n     */\n    Trace.prototype.fullQueryCacheHit = false;\n\n    /**\n     * Trace persistedQueryHit.\n     * @member {boolean} persistedQueryHit\n     * @memberof Trace\n     * @instance\n     */\n    Trace.prototype.persistedQueryHit = false;\n\n    /**\n     * Trace persistedQueryRegister.\n     * @member {boolean} persistedQueryRegister\n     * @memberof Trace\n     * @instance\n     */\n    Trace.prototype.persistedQueryRegister = false;\n\n    /**\n     * Trace registeredOperation.\n     * @member {boolean} registeredOperation\n     * @memberof Trace\n     * @instance\n     */\n    Trace.prototype.registeredOperation = false;\n\n    /**\n     * Trace forbiddenOperation.\n     * @member {boolean} forbiddenOperation\n     * @memberof Trace\n     * @instance\n     */\n    Trace.prototype.forbiddenOperation = false;\n\n    /**\n     * Trace fieldExecutionWeight.\n     * @member {number} fieldExecutionWeight\n     * @memberof Trace\n     * @instance\n     */\n    Trace.prototype.fieldExecutionWeight = 0;\n\n    /**\n     * Creates a new Trace instance using the specified properties.\n     * @function create\n     * @memberof Trace\n     * @static\n     * @param {ITrace=} [properties] Properties to set\n     * @returns {Trace} Trace instance\n     */\n    Trace.create = function create(properties) {\n        return new Trace(properties);\n    };\n\n    /**\n     * Encodes the specified Trace message. Does not implicitly {@link Trace.verify|verify} messages.\n     * @function encode\n     * @memberof Trace\n     * @static\n     * @param {ITrace} message Trace message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Trace.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.endTime != null && Object.hasOwnProperty.call(message, \"endTime\"))\n            $root.google.protobuf.Timestamp.encode(message.endTime, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n        if (message.startTime != null && Object.hasOwnProperty.call(message, \"startTime\"))\n            $root.google.protobuf.Timestamp.encode(message.startTime, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n        if (message.details != null && Object.hasOwnProperty.call(message, \"details\"))\n            $root.Trace.Details.encode(message.details, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();\n        if (message.clientName != null && Object.hasOwnProperty.call(message, \"clientName\"))\n            writer.uint32(/* id 7, wireType 2 =*/58).string(message.clientName);\n        if (message.clientVersion != null && Object.hasOwnProperty.call(message, \"clientVersion\"))\n            writer.uint32(/* id 8, wireType 2 =*/66).string(message.clientVersion);\n        if (message.http != null && Object.hasOwnProperty.call(message, \"http\"))\n            $root.Trace.HTTP.encode(message.http, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();\n        if (message.durationNs != null && Object.hasOwnProperty.call(message, \"durationNs\"))\n            writer.uint32(/* id 11, wireType 0 =*/88).uint64(message.durationNs);\n        if (message.root != null && Object.hasOwnProperty.call(message, \"root\"))\n            $root.Trace.Node.encode(message.root, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();\n        if (message.cachePolicy != null && Object.hasOwnProperty.call(message, \"cachePolicy\"))\n            $root.Trace.CachePolicy.encode(message.cachePolicy, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();\n        if (message.signature != null && Object.hasOwnProperty.call(message, \"signature\"))\n            writer.uint32(/* id 19, wireType 2 =*/154).string(message.signature);\n        if (message.fullQueryCacheHit != null && Object.hasOwnProperty.call(message, \"fullQueryCacheHit\"))\n            writer.uint32(/* id 20, wireType 0 =*/160).bool(message.fullQueryCacheHit);\n        if (message.persistedQueryHit != null && Object.hasOwnProperty.call(message, \"persistedQueryHit\"))\n            writer.uint32(/* id 21, wireType 0 =*/168).bool(message.persistedQueryHit);\n        if (message.persistedQueryRegister != null && Object.hasOwnProperty.call(message, \"persistedQueryRegister\"))\n            writer.uint32(/* id 22, wireType 0 =*/176).bool(message.persistedQueryRegister);\n        if (message.registeredOperation != null && Object.hasOwnProperty.call(message, \"registeredOperation\"))\n            writer.uint32(/* id 24, wireType 0 =*/192).bool(message.registeredOperation);\n        if (message.forbiddenOperation != null && Object.hasOwnProperty.call(message, \"forbiddenOperation\"))\n            writer.uint32(/* id 25, wireType 0 =*/200).bool(message.forbiddenOperation);\n        if (message.queryPlan != null && Object.hasOwnProperty.call(message, \"queryPlan\"))\n            $root.Trace.QueryPlanNode.encode(message.queryPlan, writer.uint32(/* id 26, wireType 2 =*/210).fork()).ldelim();\n        if (message.unexecutedOperationBody != null && Object.hasOwnProperty.call(message, \"unexecutedOperationBody\"))\n            writer.uint32(/* id 27, wireType 2 =*/218).string(message.unexecutedOperationBody);\n        if (message.unexecutedOperationName != null && Object.hasOwnProperty.call(message, \"unexecutedOperationName\"))\n            writer.uint32(/* id 28, wireType 2 =*/226).string(message.unexecutedOperationName);\n        if (message.fieldExecutionWeight != null && Object.hasOwnProperty.call(message, \"fieldExecutionWeight\"))\n            writer.uint32(/* id 31, wireType 1 =*/249).double(message.fieldExecutionWeight);\n        if (message.isIncomplete != null && Object.hasOwnProperty.call(message, \"isIncomplete\"))\n            writer.uint32(/* id 33, wireType 0 =*/264).bool(message.isIncomplete);\n        return writer;\n    };\n\n    /**\n     * Encodes the specified Trace message, length delimited. Does not implicitly {@link Trace.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof Trace\n     * @static\n     * @param {ITrace} message Trace message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Trace.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a Trace message from the specified reader or buffer.\n     * @function decode\n     * @memberof Trace\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {Trace} Trace\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Trace.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trace();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 4:\n                message.startTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());\n                break;\n            case 3:\n                message.endTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());\n                break;\n            case 11:\n                message.durationNs = reader.uint64();\n                break;\n            case 14:\n                message.root = $root.Trace.Node.decode(reader, reader.uint32());\n                break;\n            case 33:\n                message.isIncomplete = reader.bool();\n                break;\n            case 19:\n                message.signature = reader.string();\n                break;\n            case 27:\n                message.unexecutedOperationBody = reader.string();\n                break;\n            case 28:\n                message.unexecutedOperationName = reader.string();\n                break;\n            case 6:\n                message.details = $root.Trace.Details.decode(reader, reader.uint32());\n                break;\n            case 7:\n                message.clientName = reader.string();\n                break;\n            case 8:\n                message.clientVersion = reader.string();\n                break;\n            case 10:\n                message.http = $root.Trace.HTTP.decode(reader, reader.uint32());\n                break;\n            case 18:\n                message.cachePolicy = $root.Trace.CachePolicy.decode(reader, reader.uint32());\n                break;\n            case 26:\n                message.queryPlan = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());\n                break;\n            case 20:\n                message.fullQueryCacheHit = reader.bool();\n                break;\n            case 21:\n                message.persistedQueryHit = reader.bool();\n                break;\n            case 22:\n                message.persistedQueryRegister = reader.bool();\n                break;\n            case 24:\n                message.registeredOperation = reader.bool();\n                break;\n            case 25:\n                message.forbiddenOperation = reader.bool();\n                break;\n            case 31:\n                message.fieldExecutionWeight = reader.double();\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a Trace message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof Trace\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {Trace} Trace\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Trace.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a Trace message.\n     * @function verify\n     * @memberof Trace\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    Trace.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.startTime != null && message.hasOwnProperty(\"startTime\")) {\n            let error = $root.google.protobuf.Timestamp.verify(message.startTime);\n            if (error)\n                return \"startTime.\" + error;\n        }\n        if (message.endTime != null && message.hasOwnProperty(\"endTime\")) {\n            let error = $root.google.protobuf.Timestamp.verify(message.endTime);\n            if (error)\n                return \"endTime.\" + error;\n        }\n        if (message.durationNs != null && message.hasOwnProperty(\"durationNs\"))\n            if (!$util.isInteger(message.durationNs) && !(message.durationNs && $util.isInteger(message.durationNs.low) && $util.isInteger(message.durationNs.high)))\n                return \"durationNs: integer|Long expected\";\n        if (message.root != null && message.hasOwnProperty(\"root\")) {\n            let error = $root.Trace.Node.verify(message.root);\n            if (error)\n                return \"root.\" + error;\n        }\n        if (message.isIncomplete != null && message.hasOwnProperty(\"isIncomplete\"))\n            if (typeof message.isIncomplete !== \"boolean\")\n                return \"isIncomplete: boolean expected\";\n        if (message.signature != null && message.hasOwnProperty(\"signature\"))\n            if (!$util.isString(message.signature))\n                return \"signature: string expected\";\n        if (message.unexecutedOperationBody != null && message.hasOwnProperty(\"unexecutedOperationBody\"))\n            if (!$util.isString(message.unexecutedOperationBody))\n                return \"unexecutedOperationBody: string expected\";\n        if (message.unexecutedOperationName != null && message.hasOwnProperty(\"unexecutedOperationName\"))\n            if (!$util.isString(message.unexecutedOperationName))\n                return \"unexecutedOperationName: string expected\";\n        if (message.details != null && message.hasOwnProperty(\"details\")) {\n            let error = $root.Trace.Details.verify(message.details);\n            if (error)\n                return \"details.\" + error;\n        }\n        if (message.clientName != null && message.hasOwnProperty(\"clientName\"))\n            if (!$util.isString(message.clientName))\n                return \"clientName: string expected\";\n        if (message.clientVersion != null && message.hasOwnProperty(\"clientVersion\"))\n            if (!$util.isString(message.clientVersion))\n                return \"clientVersion: string expected\";\n        if (message.http != null && message.hasOwnProperty(\"http\")) {\n            let error = $root.Trace.HTTP.verify(message.http);\n            if (error)\n                return \"http.\" + error;\n        }\n        if (message.cachePolicy != null && message.hasOwnProperty(\"cachePolicy\")) {\n            let error = $root.Trace.CachePolicy.verify(message.cachePolicy);\n            if (error)\n                return \"cachePolicy.\" + error;\n        }\n        if (message.queryPlan != null && message.hasOwnProperty(\"queryPlan\")) {\n            let error = $root.Trace.QueryPlanNode.verify(message.queryPlan);\n            if (error)\n                return \"queryPlan.\" + error;\n        }\n        if (message.fullQueryCacheHit != null && message.hasOwnProperty(\"fullQueryCacheHit\"))\n            if (typeof message.fullQueryCacheHit !== \"boolean\")\n                return \"fullQueryCacheHit: boolean expected\";\n        if (message.persistedQueryHit != null && message.hasOwnProperty(\"persistedQueryHit\"))\n            if (typeof message.persistedQueryHit !== \"boolean\")\n                return \"persistedQueryHit: boolean expected\";\n        if (message.persistedQueryRegister != null && message.hasOwnProperty(\"persistedQueryRegister\"))\n            if (typeof message.persistedQueryRegister !== \"boolean\")\n                return \"persistedQueryRegister: boolean expected\";\n        if (message.registeredOperation != null && message.hasOwnProperty(\"registeredOperation\"))\n            if (typeof message.registeredOperation !== \"boolean\")\n                return \"registeredOperation: boolean expected\";\n        if (message.forbiddenOperation != null && message.hasOwnProperty(\"forbiddenOperation\"))\n            if (typeof message.forbiddenOperation !== \"boolean\")\n                return \"forbiddenOperation: boolean expected\";\n        if (message.fieldExecutionWeight != null && message.hasOwnProperty(\"fieldExecutionWeight\"))\n            if (typeof message.fieldExecutionWeight !== \"number\")\n                return \"fieldExecutionWeight: number expected\";\n        return null;\n    };\n\n    /**\n     * Creates a plain object from a Trace message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Trace\n     * @static\n     * @param {Trace} message Trace\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    Trace.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.defaults) {\n            object.endTime = null;\n            object.startTime = null;\n            object.details = null;\n            object.clientName = \"\";\n            object.clientVersion = \"\";\n            object.http = null;\n            object.durationNs = 0;\n            object.root = null;\n            object.cachePolicy = null;\n            object.signature = \"\";\n            object.fullQueryCacheHit = false;\n            object.persistedQueryHit = false;\n            object.persistedQueryRegister = false;\n            object.registeredOperation = false;\n            object.forbiddenOperation = false;\n            object.queryPlan = null;\n            object.unexecutedOperationBody = \"\";\n            object.unexecutedOperationName = \"\";\n            object.fieldExecutionWeight = 0;\n            object.isIncomplete = false;\n        }\n        if (message.endTime != null && message.hasOwnProperty(\"endTime\"))\n            object.endTime = $root.google.protobuf.Timestamp.toObject(message.endTime, options);\n        if (message.startTime != null && message.hasOwnProperty(\"startTime\"))\n            object.startTime = $root.google.protobuf.Timestamp.toObject(message.startTime, options);\n        if (message.details != null && message.hasOwnProperty(\"details\"))\n            object.details = $root.Trace.Details.toObject(message.details, options);\n        if (message.clientName != null && message.hasOwnProperty(\"clientName\"))\n            object.clientName = message.clientName;\n        if (message.clientVersion != null && message.hasOwnProperty(\"clientVersion\"))\n            object.clientVersion = message.clientVersion;\n        if (message.http != null && message.hasOwnProperty(\"http\"))\n            object.http = $root.Trace.HTTP.toObject(message.http, options);\n        if (message.durationNs != null && message.hasOwnProperty(\"durationNs\"))\n            if (typeof message.durationNs === \"number\")\n                object.durationNs = options.longs === String ? String(message.durationNs) : message.durationNs;\n            else\n                object.durationNs = options.longs === String ? $util.Long.prototype.toString.call(message.durationNs) : options.longs === Number ? new $util.LongBits(message.durationNs.low >>> 0, message.durationNs.high >>> 0).toNumber(true) : message.durationNs;\n        if (message.root != null && message.hasOwnProperty(\"root\"))\n            object.root = $root.Trace.Node.toObject(message.root, options);\n        if (message.cachePolicy != null && message.hasOwnProperty(\"cachePolicy\"))\n            object.cachePolicy = $root.Trace.CachePolicy.toObject(message.cachePolicy, options);\n        if (message.signature != null && message.hasOwnProperty(\"signature\"))\n            object.signature = message.signature;\n        if (message.fullQueryCacheHit != null && message.hasOwnProperty(\"fullQueryCacheHit\"))\n            object.fullQueryCacheHit = message.fullQueryCacheHit;\n        if (message.persistedQueryHit != null && message.hasOwnProperty(\"persistedQueryHit\"))\n            object.persistedQueryHit = message.persistedQueryHit;\n        if (message.persistedQueryRegister != null && message.hasOwnProperty(\"persistedQueryRegister\"))\n            object.persistedQueryRegister = message.persistedQueryRegister;\n        if (message.registeredOperation != null && message.hasOwnProperty(\"registeredOperation\"))\n            object.registeredOperation = message.registeredOperation;\n        if (message.forbiddenOperation != null && message.hasOwnProperty(\"forbiddenOperation\"))\n            object.forbiddenOperation = message.forbiddenOperation;\n        if (message.queryPlan != null && message.hasOwnProperty(\"queryPlan\"))\n            object.queryPlan = $root.Trace.QueryPlanNode.toObject(message.queryPlan, options);\n        if (message.unexecutedOperationBody != null && message.hasOwnProperty(\"unexecutedOperationBody\"))\n            object.unexecutedOperationBody = message.unexecutedOperationBody;\n        if (message.unexecutedOperationName != null && message.hasOwnProperty(\"unexecutedOperationName\"))\n            object.unexecutedOperationName = message.unexecutedOperationName;\n        if (message.fieldExecutionWeight != null && message.hasOwnProperty(\"fieldExecutionWeight\"))\n            object.fieldExecutionWeight = options.json && !isFinite(message.fieldExecutionWeight) ? String(message.fieldExecutionWeight) : message.fieldExecutionWeight;\n        if (message.isIncomplete != null && message.hasOwnProperty(\"isIncomplete\"))\n            object.isIncomplete = message.isIncomplete;\n        return object;\n    };\n\n    /**\n     * Converts this Trace to JSON.\n     * @function toJSON\n     * @memberof Trace\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    Trace.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    Trace.CachePolicy = (function() {\n\n        /**\n         * Properties of a CachePolicy.\n         * @memberof Trace\n         * @interface ICachePolicy\n         * @property {Trace.CachePolicy.Scope|null} [scope] CachePolicy scope\n         * @property {number|null} [maxAgeNs] CachePolicy maxAgeNs\n         */\n\n        /**\n         * Constructs a new CachePolicy.\n         * @memberof Trace\n         * @classdesc Represents a CachePolicy.\n         * @implements ICachePolicy\n         * @constructor\n         * @param {Trace.ICachePolicy=} [properties] Properties to set\n         */\n        function CachePolicy(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * CachePolicy scope.\n         * @member {Trace.CachePolicy.Scope} scope\n         * @memberof Trace.CachePolicy\n         * @instance\n         */\n        CachePolicy.prototype.scope = 0;\n\n        /**\n         * CachePolicy maxAgeNs.\n         * @member {number} maxAgeNs\n         * @memberof Trace.CachePolicy\n         * @instance\n         */\n        CachePolicy.prototype.maxAgeNs = 0;\n\n        /**\n         * Creates a new CachePolicy instance using the specified properties.\n         * @function create\n         * @memberof Trace.CachePolicy\n         * @static\n         * @param {Trace.ICachePolicy=} [properties] Properties to set\n         * @returns {Trace.CachePolicy} CachePolicy instance\n         */\n        CachePolicy.create = function create(properties) {\n            return new CachePolicy(properties);\n        };\n\n        /**\n         * Encodes the specified CachePolicy message. Does not implicitly {@link Trace.CachePolicy.verify|verify} messages.\n         * @function encode\n         * @memberof Trace.CachePolicy\n         * @static\n         * @param {Trace.ICachePolicy} message CachePolicy message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CachePolicy.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.scope != null && Object.hasOwnProperty.call(message, \"scope\"))\n                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.scope);\n            if (message.maxAgeNs != null && Object.hasOwnProperty.call(message, \"maxAgeNs\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.maxAgeNs);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified CachePolicy message, length delimited. Does not implicitly {@link Trace.CachePolicy.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof Trace.CachePolicy\n         * @static\n         * @param {Trace.ICachePolicy} message CachePolicy message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CachePolicy.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a CachePolicy message from the specified reader or buffer.\n         * @function decode\n         * @memberof Trace.CachePolicy\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Trace.CachePolicy} CachePolicy\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CachePolicy.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trace.CachePolicy();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.scope = reader.int32();\n                    break;\n                case 2:\n                    message.maxAgeNs = reader.int64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a CachePolicy message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof Trace.CachePolicy\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {Trace.CachePolicy} CachePolicy\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CachePolicy.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a CachePolicy message.\n         * @function verify\n         * @memberof Trace.CachePolicy\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        CachePolicy.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.scope != null && message.hasOwnProperty(\"scope\"))\n                switch (message.scope) {\n                default:\n                    return \"scope: enum value expected\";\n                case 0:\n                case 1:\n                case 2:\n                    break;\n                }\n            if (message.maxAgeNs != null && message.hasOwnProperty(\"maxAgeNs\"))\n                if (!$util.isInteger(message.maxAgeNs) && !(message.maxAgeNs && $util.isInteger(message.maxAgeNs.low) && $util.isInteger(message.maxAgeNs.high)))\n                    return \"maxAgeNs: integer|Long expected\";\n            return null;\n        };\n\n        /**\n         * Creates a plain object from a CachePolicy message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof Trace.CachePolicy\n         * @static\n         * @param {Trace.CachePolicy} message CachePolicy\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        CachePolicy.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            let object = {};\n            if (options.defaults) {\n                object.scope = options.enums === String ? \"UNKNOWN\" : 0;\n                object.maxAgeNs = 0;\n            }\n            if (message.scope != null && message.hasOwnProperty(\"scope\"))\n                object.scope = options.enums === String ? $root.Trace.CachePolicy.Scope[message.scope] : message.scope;\n            if (message.maxAgeNs != null && message.hasOwnProperty(\"maxAgeNs\"))\n                if (typeof message.maxAgeNs === \"number\")\n                    object.maxAgeNs = options.longs === String ? String(message.maxAgeNs) : message.maxAgeNs;\n                else\n                    object.maxAgeNs = options.longs === String ? $util.Long.prototype.toString.call(message.maxAgeNs) : options.longs === Number ? new $util.LongBits(message.maxAgeNs.low >>> 0, message.maxAgeNs.high >>> 0).toNumber() : message.maxAgeNs;\n            return object;\n        };\n\n        /**\n         * Converts this CachePolicy to JSON.\n         * @function toJSON\n         * @memberof Trace.CachePolicy\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        CachePolicy.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        /**\n         * Scope enum.\n         * @name Trace.CachePolicy.Scope\n         * @enum {string}\n         * @property {number} UNKNOWN=0 UNKNOWN value\n         * @property {number} PUBLIC=1 PUBLIC value\n         * @property {number} PRIVATE=2 PRIVATE value\n         */\n        CachePolicy.Scope = (function() {\n            const valuesById = {}, values = Object.create(valuesById);\n            values[valuesById[0] = \"UNKNOWN\"] = 0;\n            values[valuesById[1] = \"PUBLIC\"] = 1;\n            values[valuesById[2] = \"PRIVATE\"] = 2;\n            return values;\n        })();\n\n        return CachePolicy;\n    })();\n\n    Trace.Details = (function() {\n\n        /**\n         * Properties of a Details.\n         * @memberof Trace\n         * @interface IDetails\n         * @property {Object.<string,string>|null} [variablesJson] Details variablesJson\n         * @property {string|null} [operationName] Details operationName\n         */\n\n        /**\n         * Constructs a new Details.\n         * @memberof Trace\n         * @classdesc Represents a Details.\n         * @implements IDetails\n         * @constructor\n         * @param {Trace.IDetails=} [properties] Properties to set\n         */\n        function Details(properties) {\n            this.variablesJson = {};\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * Details variablesJson.\n         * @member {Object.<string,string>} variablesJson\n         * @memberof Trace.Details\n         * @instance\n         */\n        Details.prototype.variablesJson = $util.emptyObject;\n\n        /**\n         * Details operationName.\n         * @member {string} operationName\n         * @memberof Trace.Details\n         * @instance\n         */\n        Details.prototype.operationName = \"\";\n\n        /**\n         * Creates a new Details instance using the specified properties.\n         * @function create\n         * @memberof Trace.Details\n         * @static\n         * @param {Trace.IDetails=} [properties] Properties to set\n         * @returns {Trace.Details} Details instance\n         */\n        Details.create = function create(properties) {\n            return new Details(properties);\n        };\n\n        /**\n         * Encodes the specified Details message. Does not implicitly {@link Trace.Details.verify|verify} messages.\n         * @function encode\n         * @memberof Trace.Details\n         * @static\n         * @param {Trace.IDetails} message Details message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Details.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.operationName != null && Object.hasOwnProperty.call(message, \"operationName\"))\n                writer.uint32(/* id 3, wireType 2 =*/26).string(message.operationName);\n            if (message.variablesJson != null && Object.hasOwnProperty.call(message, \"variablesJson\"))\n                for (let keys = Object.keys(message.variablesJson), i = 0; i < keys.length; ++i)\n                    writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.variablesJson[keys[i]]).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified Details message, length delimited. Does not implicitly {@link Trace.Details.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof Trace.Details\n         * @static\n         * @param {Trace.IDetails} message Details message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Details.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a Details message from the specified reader or buffer.\n         * @function decode\n         * @memberof Trace.Details\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Trace.Details} Details\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Details.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trace.Details(), key;\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 4:\n                    reader.skip().pos++;\n                    if (message.variablesJson === $util.emptyObject)\n                        message.variablesJson = {};\n                    key = reader.string();\n                    reader.pos++;\n                    message.variablesJson[key] = reader.string();\n                    break;\n                case 3:\n                    message.operationName = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a Details message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof Trace.Details\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {Trace.Details} Details\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Details.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a Details message.\n         * @function verify\n         * @memberof Trace.Details\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        Details.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.variablesJson != null && message.hasOwnProperty(\"variablesJson\")) {\n                if (!$util.isObject(message.variablesJson))\n                    return \"variablesJson: object expected\";\n                let key = Object.keys(message.variablesJson);\n                for (let i = 0; i < key.length; ++i)\n                    if (!$util.isString(message.variablesJson[key[i]]))\n                        return \"variablesJson: string{k:string} expected\";\n            }\n            if (message.operationName != null && message.hasOwnProperty(\"operationName\"))\n                if (!$util.isString(message.operationName))\n                    return \"operationName: string expected\";\n            return null;\n        };\n\n        /**\n         * Creates a plain object from a Details message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof Trace.Details\n         * @static\n         * @param {Trace.Details} message Details\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        Details.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            let object = {};\n            if (options.objects || options.defaults)\n                object.variablesJson = {};\n            if (options.defaults)\n                object.operationName = \"\";\n            if (message.operationName != null && message.hasOwnProperty(\"operationName\"))\n                object.operationName = message.operationName;\n            let keys2;\n            if (message.variablesJson && (keys2 = Object.keys(message.variablesJson)).length) {\n                object.variablesJson = {};\n                for (let j = 0; j < keys2.length; ++j)\n                    object.variablesJson[keys2[j]] = message.variablesJson[keys2[j]];\n            }\n            return object;\n        };\n\n        /**\n         * Converts this Details to JSON.\n         * @function toJSON\n         * @memberof Trace.Details\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        Details.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return Details;\n    })();\n\n    Trace.Error = (function() {\n\n        /**\n         * Properties of an Error.\n         * @memberof Trace\n         * @interface IError\n         * @property {string|null} [message] Error message\n         * @property {Array.<Trace.ILocation>|null} [location] Error location\n         * @property {number|null} [timeNs] Error timeNs\n         * @property {string|null} [json] Error json\n         */\n\n        /**\n         * Constructs a new Error.\n         * @memberof Trace\n         * @classdesc Represents an Error.\n         * @implements IError\n         * @constructor\n         * @param {Trace.IError=} [properties] Properties to set\n         */\n        function Error(properties) {\n            this.location = [];\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * Error message.\n         * @member {string} message\n         * @memberof Trace.Error\n         * @instance\n         */\n        Error.prototype.message = \"\";\n\n        /**\n         * Error location.\n         * @member {Array.<Trace.ILocation>} location\n         * @memberof Trace.Error\n         * @instance\n         */\n        Error.prototype.location = $util.emptyArray;\n\n        /**\n         * Error timeNs.\n         * @member {number} timeNs\n         * @memberof Trace.Error\n         * @instance\n         */\n        Error.prototype.timeNs = 0;\n\n        /**\n         * Error json.\n         * @member {string} json\n         * @memberof Trace.Error\n         * @instance\n         */\n        Error.prototype.json = \"\";\n\n        /**\n         * Creates a new Error instance using the specified properties.\n         * @function create\n         * @memberof Trace.Error\n         * @static\n         * @param {Trace.IError=} [properties] Properties to set\n         * @returns {Trace.Error} Error instance\n         */\n        Error.create = function create(properties) {\n            return new Error(properties);\n        };\n\n        /**\n         * Encodes the specified Error message. Does not implicitly {@link Trace.Error.verify|verify} messages.\n         * @function encode\n         * @memberof Trace.Error\n         * @static\n         * @param {Trace.IError} message Error message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Error.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.message != null && Object.hasOwnProperty.call(message, \"message\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.message);\n            if (message.location != null && message.location.length)\n                for (let i = 0; i < message.location.length; ++i)\n                    $root.Trace.Location.encode(message.location[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            if (message.timeNs != null && Object.hasOwnProperty.call(message, \"timeNs\"))\n                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.timeNs);\n            if (message.json != null && Object.hasOwnProperty.call(message, \"json\"))\n                writer.uint32(/* id 4, wireType 2 =*/34).string(message.json);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified Error message, length delimited. Does not implicitly {@link Trace.Error.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof Trace.Error\n         * @static\n         * @param {Trace.IError} message Error message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Error.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes an Error message from the specified reader or buffer.\n         * @function decode\n         * @memberof Trace.Error\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Trace.Error} Error\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Error.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trace.Error();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.message = reader.string();\n                    break;\n                case 2:\n                    if (!(message.location && message.location.length))\n                        message.location = [];\n                    message.location.push($root.Trace.Location.decode(reader, reader.uint32()));\n                    break;\n                case 3:\n                    message.timeNs = reader.uint64();\n                    break;\n                case 4:\n                    message.json = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes an Error message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof Trace.Error\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {Trace.Error} Error\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Error.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies an Error message.\n         * @function verify\n         * @memberof Trace.Error\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        Error.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.message != null && message.hasOwnProperty(\"message\"))\n                if (!$util.isString(message.message))\n                    return \"message: string expected\";\n            if (message.location != null && message.hasOwnProperty(\"location\")) {\n                if (!Array.isArray(message.location))\n                    return \"location: array expected\";\n                for (let i = 0; i < message.location.length; ++i) {\n                    let error = $root.Trace.Location.verify(message.location[i]);\n                    if (error)\n                        return \"location.\" + error;\n                }\n            }\n            if (message.timeNs != null && message.hasOwnProperty(\"timeNs\"))\n                if (!$util.isInteger(message.timeNs) && !(message.timeNs && $util.isInteger(message.timeNs.low) && $util.isInteger(message.timeNs.high)))\n                    return \"timeNs: integer|Long expected\";\n            if (message.json != null && message.hasOwnProperty(\"json\"))\n                if (!$util.isString(message.json))\n                    return \"json: string expected\";\n            return null;\n        };\n\n        /**\n         * Creates a plain object from an Error message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof Trace.Error\n         * @static\n         * @param {Trace.Error} message Error\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        Error.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            let object = {};\n            if (options.arrays || options.defaults)\n                object.location = [];\n            if (options.defaults) {\n                object.message = \"\";\n                object.timeNs = 0;\n                object.json = \"\";\n            }\n            if (message.message != null && message.hasOwnProperty(\"message\"))\n                object.message = message.message;\n            if (message.location && message.location.length) {\n                object.location = [];\n                for (let j = 0; j < message.location.length; ++j)\n                    object.location[j] = $root.Trace.Location.toObject(message.location[j], options);\n            }\n            if (message.timeNs != null && message.hasOwnProperty(\"timeNs\"))\n                if (typeof message.timeNs === \"number\")\n                    object.timeNs = options.longs === String ? String(message.timeNs) : message.timeNs;\n                else\n                    object.timeNs = options.longs === String ? $util.Long.prototype.toString.call(message.timeNs) : options.longs === Number ? new $util.LongBits(message.timeNs.low >>> 0, message.timeNs.high >>> 0).toNumber(true) : message.timeNs;\n            if (message.json != null && message.hasOwnProperty(\"json\"))\n                object.json = message.json;\n            return object;\n        };\n\n        /**\n         * Converts this Error to JSON.\n         * @function toJSON\n         * @memberof Trace.Error\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        Error.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return Error;\n    })();\n\n    Trace.HTTP = (function() {\n\n        /**\n         * Properties of a HTTP.\n         * @memberof Trace\n         * @interface IHTTP\n         * @property {Trace.HTTP.Method|null} [method] HTTP method\n         * @property {Object.<string,Trace.HTTP.IValues>|null} [requestHeaders] HTTP requestHeaders\n         * @property {Object.<string,Trace.HTTP.IValues>|null} [responseHeaders] HTTP responseHeaders\n         * @property {number|null} [statusCode] HTTP statusCode\n         */\n\n        /**\n         * Constructs a new HTTP.\n         * @memberof Trace\n         * @classdesc Represents a HTTP.\n         * @implements IHTTP\n         * @constructor\n         * @param {Trace.IHTTP=} [properties] Properties to set\n         */\n        function HTTP(properties) {\n            this.requestHeaders = {};\n            this.responseHeaders = {};\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * HTTP method.\n         * @member {Trace.HTTP.Method} method\n         * @memberof Trace.HTTP\n         * @instance\n         */\n        HTTP.prototype.method = 0;\n\n        /**\n         * HTTP requestHeaders.\n         * @member {Object.<string,Trace.HTTP.IValues>} requestHeaders\n         * @memberof Trace.HTTP\n         * @instance\n         */\n        HTTP.prototype.requestHeaders = $util.emptyObject;\n\n        /**\n         * HTTP responseHeaders.\n         * @member {Object.<string,Trace.HTTP.IValues>} responseHeaders\n         * @memberof Trace.HTTP\n         * @instance\n         */\n        HTTP.prototype.responseHeaders = $util.emptyObject;\n\n        /**\n         * HTTP statusCode.\n         * @member {number} statusCode\n         * @memberof Trace.HTTP\n         * @instance\n         */\n        HTTP.prototype.statusCode = 0;\n\n        /**\n         * Creates a new HTTP instance using the specified properties.\n         * @function create\n         * @memberof Trace.HTTP\n         * @static\n         * @param {Trace.IHTTP=} [properties] Properties to set\n         * @returns {Trace.HTTP} HTTP instance\n         */\n        HTTP.create = function create(properties) {\n            return new HTTP(properties);\n        };\n\n        /**\n         * Encodes the specified HTTP message. Does not implicitly {@link Trace.HTTP.verify|verify} messages.\n         * @function encode\n         * @memberof Trace.HTTP\n         * @static\n         * @param {Trace.IHTTP} message HTTP message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        HTTP.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.method != null && Object.hasOwnProperty.call(message, \"method\"))\n                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.method);\n            if (message.requestHeaders != null && Object.hasOwnProperty.call(message, \"requestHeaders\"))\n                for (let keys = Object.keys(message.requestHeaders), i = 0; i < keys.length; ++i) {\n                    writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);\n                    $root.Trace.HTTP.Values.encode(message.requestHeaders[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();\n                }\n            if (message.responseHeaders != null && Object.hasOwnProperty.call(message, \"responseHeaders\"))\n                for (let keys = Object.keys(message.responseHeaders), i = 0; i < keys.length; ++i) {\n                    writer.uint32(/* id 5, wireType 2 =*/42).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);\n                    $root.Trace.HTTP.Values.encode(message.responseHeaders[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();\n                }\n            if (message.statusCode != null && Object.hasOwnProperty.call(message, \"statusCode\"))\n                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.statusCode);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified HTTP message, length delimited. Does not implicitly {@link Trace.HTTP.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof Trace.HTTP\n         * @static\n         * @param {Trace.IHTTP} message HTTP message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        HTTP.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a HTTP message from the specified reader or buffer.\n         * @function decode\n         * @memberof Trace.HTTP\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Trace.HTTP} HTTP\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        HTTP.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trace.HTTP(), key;\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.method = reader.int32();\n                    break;\n                case 4:\n                    reader.skip().pos++;\n                    if (message.requestHeaders === $util.emptyObject)\n                        message.requestHeaders = {};\n                    key = reader.string();\n                    reader.pos++;\n                    message.requestHeaders[key] = $root.Trace.HTTP.Values.decode(reader, reader.uint32());\n                    break;\n                case 5:\n                    reader.skip().pos++;\n                    if (message.responseHeaders === $util.emptyObject)\n                        message.responseHeaders = {};\n                    key = reader.string();\n                    reader.pos++;\n                    message.responseHeaders[key] = $root.Trace.HTTP.Values.decode(reader, reader.uint32());\n                    break;\n                case 6:\n                    message.statusCode = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a HTTP message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof Trace.HTTP\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {Trace.HTTP} HTTP\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        HTTP.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a HTTP message.\n         * @function verify\n         * @memberof Trace.HTTP\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        HTTP.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.method != null && message.hasOwnProperty(\"method\"))\n                switch (message.method) {\n                default:\n                    return \"method: enum value expected\";\n                case 0:\n                case 1:\n                case 2:\n                case 3:\n                case 4:\n                case 5:\n                case 6:\n                case 7:\n                case 8:\n                case 9:\n                    break;\n                }\n            if (message.requestHeaders != null && message.hasOwnProperty(\"requestHeaders\")) {\n                if (!$util.isObject(message.requestHeaders))\n                    return \"requestHeaders: object expected\";\n                let key = Object.keys(message.requestHeaders);\n                for (let i = 0; i < key.length; ++i) {\n                    let error = $root.Trace.HTTP.Values.verify(message.requestHeaders[key[i]]);\n                    if (error)\n                        return \"requestHeaders.\" + error;\n                }\n            }\n            if (message.responseHeaders != null && message.hasOwnProperty(\"responseHeaders\")) {\n                if (!$util.isObject(message.responseHeaders))\n                    return \"responseHeaders: object expected\";\n                let key = Object.keys(message.responseHeaders);\n                for (let i = 0; i < key.length; ++i) {\n                    let error = $root.Trace.HTTP.Values.verify(message.responseHeaders[key[i]]);\n                    if (error)\n                        return \"responseHeaders.\" + error;\n                }\n            }\n            if (message.statusCode != null && message.hasOwnProperty(\"statusCode\"))\n                if (!$util.isInteger(message.statusCode))\n                    return \"statusCode: integer expected\";\n            return null;\n        };\n\n        /**\n         * Creates a plain object from a HTTP message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof Trace.HTTP\n         * @static\n         * @param {Trace.HTTP} message HTTP\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        HTTP.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            let object = {};\n            if (options.objects || options.defaults) {\n                object.requestHeaders = {};\n                object.responseHeaders = {};\n            }\n            if (options.defaults) {\n                object.method = options.enums === String ? \"UNKNOWN\" : 0;\n                object.statusCode = 0;\n            }\n            if (message.method != null && message.hasOwnProperty(\"method\"))\n                object.method = options.enums === String ? $root.Trace.HTTP.Method[message.method] : message.method;\n            let keys2;\n            if (message.requestHeaders && (keys2 = Object.keys(message.requestHeaders)).length) {\n                object.requestHeaders = {};\n                for (let j = 0; j < keys2.length; ++j)\n                    object.requestHeaders[keys2[j]] = $root.Trace.HTTP.Values.toObject(message.requestHeaders[keys2[j]], options);\n            }\n            if (message.responseHeaders && (keys2 = Object.keys(message.responseHeaders)).length) {\n                object.responseHeaders = {};\n                for (let j = 0; j < keys2.length; ++j)\n                    object.responseHeaders[keys2[j]] = $root.Trace.HTTP.Values.toObject(message.responseHeaders[keys2[j]], options);\n            }\n            if (message.statusCode != null && message.hasOwnProperty(\"statusCode\"))\n                object.statusCode = message.statusCode;\n            return object;\n        };\n\n        /**\n         * Converts this HTTP to JSON.\n         * @function toJSON\n         * @memberof Trace.HTTP\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        HTTP.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        HTTP.Values = (function() {\n\n            /**\n             * Properties of a Values.\n             * @memberof Trace.HTTP\n             * @interface IValues\n             * @property {Array.<string>|null} [value] Values value\n             */\n\n            /**\n             * Constructs a new Values.\n             * @memberof Trace.HTTP\n             * @classdesc Represents a Values.\n             * @implements IValues\n             * @constructor\n             * @param {Trace.HTTP.IValues=} [properties] Properties to set\n             */\n            function Values(properties) {\n                this.value = [];\n                if (properties)\n                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n\n            /**\n             * Values value.\n             * @member {Array.<string>} value\n             * @memberof Trace.HTTP.Values\n             * @instance\n             */\n            Values.prototype.value = $util.emptyArray;\n\n            /**\n             * Creates a new Values instance using the specified properties.\n             * @function create\n             * @memberof Trace.HTTP.Values\n             * @static\n             * @param {Trace.HTTP.IValues=} [properties] Properties to set\n             * @returns {Trace.HTTP.Values} Values instance\n             */\n            Values.create = function create(properties) {\n                return new Values(properties);\n            };\n\n            /**\n             * Encodes the specified Values message. Does not implicitly {@link Trace.HTTP.Values.verify|verify} messages.\n             * @function encode\n             * @memberof Trace.HTTP.Values\n             * @static\n             * @param {Trace.HTTP.IValues} message Values message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Values.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.value != null && message.value.length)\n                    for (let i = 0; i < message.value.length; ++i)\n                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.value[i]);\n                return writer;\n            };\n\n            /**\n             * Encodes the specified Values message, length delimited. Does not implicitly {@link Trace.HTTP.Values.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof Trace.HTTP.Values\n             * @static\n             * @param {Trace.HTTP.IValues} message Values message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Values.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n\n            /**\n             * Decodes a Values message from the specified reader or buffer.\n             * @function decode\n             * @memberof Trace.HTTP.Values\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {Trace.HTTP.Values} Values\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Values.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trace.HTTP.Values();\n                while (reader.pos < end) {\n                    let tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        if (!(message.value && message.value.length))\n                            message.value = [];\n                        message.value.push(reader.string());\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n\n            /**\n             * Decodes a Values message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof Trace.HTTP.Values\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {Trace.HTTP.Values} Values\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Values.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n\n            /**\n             * Verifies a Values message.\n             * @function verify\n             * @memberof Trace.HTTP.Values\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            Values.verify = function verify(message) {\n                if (typeof message !== \"object\" || message === null)\n                    return \"object expected\";\n                if (message.value != null && message.hasOwnProperty(\"value\")) {\n                    if (!Array.isArray(message.value))\n                        return \"value: array expected\";\n                    for (let i = 0; i < message.value.length; ++i)\n                        if (!$util.isString(message.value[i]))\n                            return \"value: string[] expected\";\n                }\n                return null;\n            };\n\n            /**\n             * Creates a plain object from a Values message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof Trace.HTTP.Values\n             * @static\n             * @param {Trace.HTTP.Values} message Values\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            Values.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                let object = {};\n                if (options.arrays || options.defaults)\n                    object.value = [];\n                if (message.value && message.value.length) {\n                    object.value = [];\n                    for (let j = 0; j < message.value.length; ++j)\n                        object.value[j] = message.value[j];\n                }\n                return object;\n            };\n\n            /**\n             * Converts this Values to JSON.\n             * @function toJSON\n             * @memberof Trace.HTTP.Values\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            Values.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return Values;\n        })();\n\n        /**\n         * Method enum.\n         * @name Trace.HTTP.Method\n         * @enum {string}\n         * @property {number} UNKNOWN=0 UNKNOWN value\n         * @property {number} OPTIONS=1 OPTIONS value\n         * @property {number} GET=2 GET value\n         * @property {number} HEAD=3 HEAD value\n         * @property {number} POST=4 POST value\n         * @property {number} PUT=5 PUT value\n         * @property {number} DELETE=6 DELETE value\n         * @property {number} TRACE=7 TRACE value\n         * @property {number} CONNECT=8 CONNECT value\n         * @property {number} PATCH=9 PATCH value\n         */\n        HTTP.Method = (function() {\n            const valuesById = {}, values = Object.create(valuesById);\n            values[valuesById[0] = \"UNKNOWN\"] = 0;\n            values[valuesById[1] = \"OPTIONS\"] = 1;\n            values[valuesById[2] = \"GET\"] = 2;\n            values[valuesById[3] = \"HEAD\"] = 3;\n            values[valuesById[4] = \"POST\"] = 4;\n            values[valuesById[5] = \"PUT\"] = 5;\n            values[valuesById[6] = \"DELETE\"] = 6;\n            values[valuesById[7] = \"TRACE\"] = 7;\n            values[valuesById[8] = \"CONNECT\"] = 8;\n            values[valuesById[9] = \"PATCH\"] = 9;\n            return values;\n        })();\n\n        return HTTP;\n    })();\n\n    Trace.Location = (function() {\n\n        /**\n         * Properties of a Location.\n         * @memberof Trace\n         * @interface ILocation\n         * @property {number|null} [line] Location line\n         * @property {number|null} [column] Location column\n         */\n\n        /**\n         * Constructs a new Location.\n         * @memberof Trace\n         * @classdesc Represents a Location.\n         * @implements ILocation\n         * @constructor\n         * @param {Trace.ILocation=} [properties] Properties to set\n         */\n        function Location(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * Location line.\n         * @member {number} line\n         * @memberof Trace.Location\n         * @instance\n         */\n        Location.prototype.line = 0;\n\n        /**\n         * Location column.\n         * @member {number} column\n         * @memberof Trace.Location\n         * @instance\n         */\n        Location.prototype.column = 0;\n\n        /**\n         * Creates a new Location instance using the specified properties.\n         * @function create\n         * @memberof Trace.Location\n         * @static\n         * @param {Trace.ILocation=} [properties] Properties to set\n         * @returns {Trace.Location} Location instance\n         */\n        Location.create = function create(properties) {\n            return new Location(properties);\n        };\n\n        /**\n         * Encodes the specified Location message. Does not implicitly {@link Trace.Location.verify|verify} messages.\n         * @function encode\n         * @memberof Trace.Location\n         * @static\n         * @param {Trace.ILocation} message Location message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Location.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.line != null && Object.hasOwnProperty.call(message, \"line\"))\n                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.line);\n            if (message.column != null && Object.hasOwnProperty.call(message, \"column\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.column);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified Location message, length delimited. Does not implicitly {@link Trace.Location.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof Trace.Location\n         * @static\n         * @param {Trace.ILocation} message Location message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Location.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a Location message from the specified reader or buffer.\n         * @function decode\n         * @memberof Trace.Location\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Trace.Location} Location\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Location.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trace.Location();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.line = reader.uint32();\n                    break;\n                case 2:\n                    message.column = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a Location message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof Trace.Location\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {Trace.Location} Location\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Location.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a Location message.\n         * @function verify\n         * @memberof Trace.Location\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        Location.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.line != null && message.hasOwnProperty(\"line\"))\n                if (!$util.isInteger(message.line))\n                    return \"line: integer expected\";\n            if (message.column != null && message.hasOwnProperty(\"column\"))\n                if (!$util.isInteger(message.column))\n                    return \"column: integer expected\";\n            return null;\n        };\n\n        /**\n         * Creates a plain object from a Location message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof Trace.Location\n         * @static\n         * @param {Trace.Location} message Location\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        Location.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            let object = {};\n            if (options.defaults) {\n                object.line = 0;\n                object.column = 0;\n            }\n            if (message.line != null && message.hasOwnProperty(\"line\"))\n                object.line = message.line;\n            if (message.column != null && message.hasOwnProperty(\"column\"))\n                object.column = message.column;\n            return object;\n        };\n\n        /**\n         * Converts this Location to JSON.\n         * @function toJSON\n         * @memberof Trace.Location\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        Location.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return Location;\n    })();\n\n    Trace.Node = (function() {\n\n        /**\n         * Properties of a Node.\n         * @memberof Trace\n         * @interface INode\n         * @property {string|null} [responseName] Node responseName\n         * @property {number|null} [index] Node index\n         * @property {string|null} [originalFieldName] Node originalFieldName\n         * @property {string|null} [type] Node type\n         * @property {string|null} [parentType] Node parentType\n         * @property {Trace.ICachePolicy|null} [cachePolicy] Node cachePolicy\n         * @property {number|null} [startTime] Node startTime\n         * @property {number|null} [endTime] Node endTime\n         * @property {Array.<Trace.IError>|null} [error] Node error\n         * @property {Array.<Trace.INode>|null} [child] Node child\n         */\n\n        /**\n         * Constructs a new Node.\n         * @memberof Trace\n         * @classdesc Represents a Node.\n         * @implements INode\n         * @constructor\n         * @param {Trace.INode=} [properties] Properties to set\n         */\n        function Node(properties) {\n            this.error = [];\n            this.child = [];\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * Node responseName.\n         * @member {string} responseName\n         * @memberof Trace.Node\n         * @instance\n         */\n        Node.prototype.responseName = \"\";\n\n        /**\n         * Node index.\n         * @member {number} index\n         * @memberof Trace.Node\n         * @instance\n         */\n        Node.prototype.index = 0;\n\n        /**\n         * Node originalFieldName.\n         * @member {string} originalFieldName\n         * @memberof Trace.Node\n         * @instance\n         */\n        Node.prototype.originalFieldName = \"\";\n\n        /**\n         * Node type.\n         * @member {string} type\n         * @memberof Trace.Node\n         * @instance\n         */\n        Node.prototype.type = \"\";\n\n        /**\n         * Node parentType.\n         * @member {string} parentType\n         * @memberof Trace.Node\n         * @instance\n         */\n        Node.prototype.parentType = \"\";\n\n        /**\n         * Node cachePolicy.\n         * @member {Trace.ICachePolicy|null|undefined} cachePolicy\n         * @memberof Trace.Node\n         * @instance\n         */\n        Node.prototype.cachePolicy = null;\n\n        /**\n         * Node startTime.\n         * @member {number} startTime\n         * @memberof Trace.Node\n         * @instance\n         */\n        Node.prototype.startTime = 0;\n\n        /**\n         * Node endTime.\n         * @member {number} endTime\n         * @memberof Trace.Node\n         * @instance\n         */\n        Node.prototype.endTime = 0;\n\n        /**\n         * Node error.\n         * @member {Array.<Trace.IError>} error\n         * @memberof Trace.Node\n         * @instance\n         */\n        Node.prototype.error = $util.emptyArray;\n\n        /**\n         * Node child.\n         * @member {Array.<Trace.INode>} child\n         * @memberof Trace.Node\n         * @instance\n         */\n        Node.prototype.child = $util.emptyArray;\n\n        // OneOf field names bound to virtual getters and setters\n        let $oneOfFields;\n\n        /**\n         * Node id.\n         * @member {\"responseName\"|\"index\"|undefined} id\n         * @memberof Trace.Node\n         * @instance\n         */\n        Object.defineProperty(Node.prototype, \"id\", {\n            get: $util.oneOfGetter($oneOfFields = [\"responseName\", \"index\"]),\n            set: $util.oneOfSetter($oneOfFields)\n        });\n\n        /**\n         * Creates a new Node instance using the specified properties.\n         * @function create\n         * @memberof Trace.Node\n         * @static\n         * @param {Trace.INode=} [properties] Properties to set\n         * @returns {Trace.Node} Node instance\n         */\n        Node.create = function create(properties) {\n            return new Node(properties);\n        };\n\n        /**\n         * Encodes the specified Node message. Does not implicitly {@link Trace.Node.verify|verify} messages.\n         * @function encode\n         * @memberof Trace.Node\n         * @static\n         * @param {Trace.INode} message Node message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Node.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.responseName != null && Object.hasOwnProperty.call(message, \"responseName\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.responseName);\n            if (message.index != null && Object.hasOwnProperty.call(message, \"index\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.index);\n            if (message.type != null && Object.hasOwnProperty.call(message, \"type\"))\n                writer.uint32(/* id 3, wireType 2 =*/26).string(message.type);\n            if (message.cachePolicy != null && Object.hasOwnProperty.call(message, \"cachePolicy\"))\n                $root.Trace.CachePolicy.encode(message.cachePolicy, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();\n            if (message.startTime != null && Object.hasOwnProperty.call(message, \"startTime\"))\n                writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.startTime);\n            if (message.endTime != null && Object.hasOwnProperty.call(message, \"endTime\"))\n                writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.endTime);\n            if (message.error != null && message.error.length)\n                for (let i = 0; i < message.error.length; ++i)\n                    $root.Trace.Error.encode(message.error[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();\n            if (message.child != null && message.child.length)\n                for (let i = 0; i < message.child.length; ++i)\n                    $root.Trace.Node.encode(message.child[i], writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();\n            if (message.parentType != null && Object.hasOwnProperty.call(message, \"parentType\"))\n                writer.uint32(/* id 13, wireType 2 =*/106).string(message.parentType);\n            if (message.originalFieldName != null && Object.hasOwnProperty.call(message, \"originalFieldName\"))\n                writer.uint32(/* id 14, wireType 2 =*/114).string(message.originalFieldName);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified Node message, length delimited. Does not implicitly {@link Trace.Node.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof Trace.Node\n         * @static\n         * @param {Trace.INode} message Node message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Node.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a Node message from the specified reader or buffer.\n         * @function decode\n         * @memberof Trace.Node\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Trace.Node} Node\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Node.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trace.Node();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.responseName = reader.string();\n                    break;\n                case 2:\n                    message.index = reader.uint32();\n                    break;\n                case 14:\n                    message.originalFieldName = reader.string();\n                    break;\n                case 3:\n                    message.type = reader.string();\n                    break;\n                case 13:\n                    message.parentType = reader.string();\n                    break;\n                case 5:\n                    message.cachePolicy = $root.Trace.CachePolicy.decode(reader, reader.uint32());\n                    break;\n                case 8:\n                    message.startTime = reader.uint64();\n                    break;\n                case 9:\n                    message.endTime = reader.uint64();\n                    break;\n                case 11:\n                    if (!(message.error && message.error.length))\n                        message.error = [];\n                    message.error.push($root.Trace.Error.decode(reader, reader.uint32()));\n                    break;\n                case 12:\n                    if (!(message.child && message.child.length))\n                        message.child = [];\n                    message.child.push($root.Trace.Node.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a Node message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof Trace.Node\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {Trace.Node} Node\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Node.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a Node message.\n         * @function verify\n         * @memberof Trace.Node\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        Node.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            let properties = {};\n            if (message.responseName != null && message.hasOwnProperty(\"responseName\")) {\n                properties.id = 1;\n                if (!$util.isString(message.responseName))\n                    return \"responseName: string expected\";\n            }\n            if (message.index != null && message.hasOwnProperty(\"index\")) {\n                if (properties.id === 1)\n                    return \"id: multiple values\";\n                properties.id = 1;\n                if (!$util.isInteger(message.index))\n                    return \"index: integer expected\";\n            }\n            if (message.originalFieldName != null && message.hasOwnProperty(\"originalFieldName\"))\n                if (!$util.isString(message.originalFieldName))\n                    return \"originalFieldName: string expected\";\n            if (message.type != null && message.hasOwnProperty(\"type\"))\n                if (!$util.isString(message.type))\n                    return \"type: string expected\";\n            if (message.parentType != null && message.hasOwnProperty(\"parentType\"))\n                if (!$util.isString(message.parentType))\n                    return \"parentType: string expected\";\n            if (message.cachePolicy != null && message.hasOwnProperty(\"cachePolicy\")) {\n                let error = $root.Trace.CachePolicy.verify(message.cachePolicy);\n                if (error)\n                    return \"cachePolicy.\" + error;\n            }\n            if (message.startTime != null && message.hasOwnProperty(\"startTime\"))\n                if (!$util.isInteger(message.startTime) && !(message.startTime && $util.isInteger(message.startTime.low) && $util.isInteger(message.startTime.high)))\n                    return \"startTime: integer|Long expected\";\n            if (message.endTime != null && message.hasOwnProperty(\"endTime\"))\n                if (!$util.isInteger(message.endTime) && !(message.endTime && $util.isInteger(message.endTime.low) && $util.isInteger(message.endTime.high)))\n                    return \"endTime: integer|Long expected\";\n            if (message.error != null && message.hasOwnProperty(\"error\")) {\n                if (!Array.isArray(message.error))\n                    return \"error: array expected\";\n                for (let i = 0; i < message.error.length; ++i) {\n                    let error = $root.Trace.Error.verify(message.error[i]);\n                    if (error)\n                        return \"error.\" + error;\n                }\n            }\n            if (message.child != null && message.hasOwnProperty(\"child\")) {\n                if (!Array.isArray(message.child))\n                    return \"child: array expected\";\n                for (let i = 0; i < message.child.length; ++i) {\n                    let error = $root.Trace.Node.verify(message.child[i]);\n                    if (error)\n                        return \"child.\" + error;\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Creates a plain object from a Node message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof Trace.Node\n         * @static\n         * @param {Trace.Node} message Node\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        Node.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            let object = {};\n            if (options.arrays || options.defaults) {\n                object.error = [];\n                object.child = [];\n            }\n            if (options.defaults) {\n                object.type = \"\";\n                object.cachePolicy = null;\n                object.startTime = 0;\n                object.endTime = 0;\n                object.parentType = \"\";\n                object.originalFieldName = \"\";\n            }\n            if (message.responseName != null && message.hasOwnProperty(\"responseName\")) {\n                object.responseName = message.responseName;\n                if (options.oneofs)\n                    object.id = \"responseName\";\n            }\n            if (message.index != null && message.hasOwnProperty(\"index\")) {\n                object.index = message.index;\n                if (options.oneofs)\n                    object.id = \"index\";\n            }\n            if (message.type != null && message.hasOwnProperty(\"type\"))\n                object.type = message.type;\n            if (message.cachePolicy != null && message.hasOwnProperty(\"cachePolicy\"))\n                object.cachePolicy = $root.Trace.CachePolicy.toObject(message.cachePolicy, options);\n            if (message.startTime != null && message.hasOwnProperty(\"startTime\"))\n                if (typeof message.startTime === \"number\")\n                    object.startTime = options.longs === String ? String(message.startTime) : message.startTime;\n                else\n                    object.startTime = options.longs === String ? $util.Long.prototype.toString.call(message.startTime) : options.longs === Number ? new $util.LongBits(message.startTime.low >>> 0, message.startTime.high >>> 0).toNumber(true) : message.startTime;\n            if (message.endTime != null && message.hasOwnProperty(\"endTime\"))\n                if (typeof message.endTime === \"number\")\n                    object.endTime = options.longs === String ? String(message.endTime) : message.endTime;\n                else\n                    object.endTime = options.longs === String ? $util.Long.prototype.toString.call(message.endTime) : options.longs === Number ? new $util.LongBits(message.endTime.low >>> 0, message.endTime.high >>> 0).toNumber(true) : message.endTime;\n            if (message.error && message.error.length) {\n                object.error = [];\n                for (let j = 0; j < message.error.length; ++j)\n                    object.error[j] = $root.Trace.Error.toObject(message.error[j], options);\n            }\n            if (message.child && message.child.length) {\n                object.child = [];\n                for (let j = 0; j < message.child.length; ++j)\n                    object.child[j] = $root.Trace.Node.toObject(message.child[j], options);\n            }\n            if (message.parentType != null && message.hasOwnProperty(\"parentType\"))\n                object.parentType = message.parentType;\n            if (message.originalFieldName != null && message.hasOwnProperty(\"originalFieldName\"))\n                object.originalFieldName = message.originalFieldName;\n            return object;\n        };\n\n        /**\n         * Converts this Node to JSON.\n         * @function toJSON\n         * @memberof Trace.Node\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        Node.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return Node;\n    })();\n\n    Trace.QueryPlanNode = (function() {\n\n        /**\n         * Properties of a QueryPlanNode.\n         * @memberof Trace\n         * @interface IQueryPlanNode\n         * @property {Trace.QueryPlanNode.ISequenceNode|null} [sequence] QueryPlanNode sequence\n         * @property {Trace.QueryPlanNode.IParallelNode|null} [parallel] QueryPlanNode parallel\n         * @property {Trace.QueryPlanNode.IFetchNode|null} [fetch] QueryPlanNode fetch\n         * @property {Trace.QueryPlanNode.IFlattenNode|null} [flatten] QueryPlanNode flatten\n         * @property {Trace.QueryPlanNode.IDeferNode|null} [defer] QueryPlanNode defer\n         * @property {Trace.QueryPlanNode.IConditionNode|null} [condition] QueryPlanNode condition\n         */\n\n        /**\n         * Constructs a new QueryPlanNode.\n         * @memberof Trace\n         * @classdesc Represents a QueryPlanNode.\n         * @implements IQueryPlanNode\n         * @constructor\n         * @param {Trace.IQueryPlanNode=} [properties] Properties to set\n         */\n        function QueryPlanNode(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * QueryPlanNode sequence.\n         * @member {Trace.QueryPlanNode.ISequenceNode|null|undefined} sequence\n         * @memberof Trace.QueryPlanNode\n         * @instance\n         */\n        QueryPlanNode.prototype.sequence = null;\n\n        /**\n         * QueryPlanNode parallel.\n         * @member {Trace.QueryPlanNode.IParallelNode|null|undefined} parallel\n         * @memberof Trace.QueryPlanNode\n         * @instance\n         */\n        QueryPlanNode.prototype.parallel = null;\n\n        /**\n         * QueryPlanNode fetch.\n         * @member {Trace.QueryPlanNode.IFetchNode|null|undefined} fetch\n         * @memberof Trace.QueryPlanNode\n         * @instance\n         */\n        QueryPlanNode.prototype.fetch = null;\n\n        /**\n         * QueryPlanNode flatten.\n         * @member {Trace.QueryPlanNode.IFlattenNode|null|undefined} flatten\n         * @memberof Trace.QueryPlanNode\n         * @instance\n         */\n        QueryPlanNode.prototype.flatten = null;\n\n        /**\n         * QueryPlanNode defer.\n         * @member {Trace.QueryPlanNode.IDeferNode|null|undefined} defer\n         * @memberof Trace.QueryPlanNode\n         * @instance\n         */\n        QueryPlanNode.prototype.defer = null;\n\n        /**\n         * QueryPlanNode condition.\n         * @member {Trace.QueryPlanNode.IConditionNode|null|undefined} condition\n         * @memberof Trace.QueryPlanNode\n         * @instance\n         */\n        QueryPlanNode.prototype.condition = null;\n\n        // OneOf field names bound to virtual getters and setters\n        let $oneOfFields;\n\n        /**\n         * QueryPlanNode node.\n         * @member {\"sequence\"|\"parallel\"|\"fetch\"|\"flatten\"|\"defer\"|\"condition\"|undefined} node\n         * @memberof Trace.QueryPlanNode\n         * @instance\n         */\n        Object.defineProperty(QueryPlanNode.prototype, \"node\", {\n            get: $util.oneOfGetter($oneOfFields = [\"sequence\", \"parallel\", \"fetch\", \"flatten\", \"defer\", \"condition\"]),\n            set: $util.oneOfSetter($oneOfFields)\n        });\n\n        /**\n         * Creates a new QueryPlanNode instance using the specified properties.\n         * @function create\n         * @memberof Trace.QueryPlanNode\n         * @static\n         * @param {Trace.IQueryPlanNode=} [properties] Properties to set\n         * @returns {Trace.QueryPlanNode} QueryPlanNode instance\n         */\n        QueryPlanNode.create = function create(properties) {\n            return new QueryPlanNode(properties);\n        };\n\n        /**\n         * Encodes the specified QueryPlanNode message. Does not implicitly {@link Trace.QueryPlanNode.verify|verify} messages.\n         * @function encode\n         * @memberof Trace.QueryPlanNode\n         * @static\n         * @param {Trace.IQueryPlanNode} message QueryPlanNode message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        QueryPlanNode.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.sequence != null && Object.hasOwnProperty.call(message, \"sequence\"))\n                $root.Trace.QueryPlanNode.SequenceNode.encode(message.sequence, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.parallel != null && Object.hasOwnProperty.call(message, \"parallel\"))\n                $root.Trace.QueryPlanNode.ParallelNode.encode(message.parallel, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            if (message.fetch != null && Object.hasOwnProperty.call(message, \"fetch\"))\n                $root.Trace.QueryPlanNode.FetchNode.encode(message.fetch, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n            if (message.flatten != null && Object.hasOwnProperty.call(message, \"flatten\"))\n                $root.Trace.QueryPlanNode.FlattenNode.encode(message.flatten, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n            if (message.defer != null && Object.hasOwnProperty.call(message, \"defer\"))\n                $root.Trace.QueryPlanNode.DeferNode.encode(message.defer, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();\n            if (message.condition != null && Object.hasOwnProperty.call(message, \"condition\"))\n                $root.Trace.QueryPlanNode.ConditionNode.encode(message.condition, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified QueryPlanNode message, length delimited. Does not implicitly {@link Trace.QueryPlanNode.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof Trace.QueryPlanNode\n         * @static\n         * @param {Trace.IQueryPlanNode} message QueryPlanNode message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        QueryPlanNode.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a QueryPlanNode message from the specified reader or buffer.\n         * @function decode\n         * @memberof Trace.QueryPlanNode\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Trace.QueryPlanNode} QueryPlanNode\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        QueryPlanNode.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.sequence = $root.Trace.QueryPlanNode.SequenceNode.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.parallel = $root.Trace.QueryPlanNode.ParallelNode.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.fetch = $root.Trace.QueryPlanNode.FetchNode.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    message.flatten = $root.Trace.QueryPlanNode.FlattenNode.decode(reader, reader.uint32());\n                    break;\n                case 5:\n                    message.defer = $root.Trace.QueryPlanNode.DeferNode.decode(reader, reader.uint32());\n                    break;\n                case 6:\n                    message.condition = $root.Trace.QueryPlanNode.ConditionNode.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a QueryPlanNode message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof Trace.QueryPlanNode\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {Trace.QueryPlanNode} QueryPlanNode\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        QueryPlanNode.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a QueryPlanNode message.\n         * @function verify\n         * @memberof Trace.QueryPlanNode\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        QueryPlanNode.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            let properties = {};\n            if (message.sequence != null && message.hasOwnProperty(\"sequence\")) {\n                properties.node = 1;\n                {\n                    let error = $root.Trace.QueryPlanNode.SequenceNode.verify(message.sequence);\n                    if (error)\n                        return \"sequence.\" + error;\n                }\n            }\n            if (message.parallel != null && message.hasOwnProperty(\"parallel\")) {\n                if (properties.node === 1)\n                    return \"node: multiple values\";\n                properties.node = 1;\n                {\n                    let error = $root.Trace.QueryPlanNode.ParallelNode.verify(message.parallel);\n                    if (error)\n                        return \"parallel.\" + error;\n                }\n            }\n            if (message.fetch != null && message.hasOwnProperty(\"fetch\")) {\n                if (properties.node === 1)\n                    return \"node: multiple values\";\n                properties.node = 1;\n                {\n                    let error = $root.Trace.QueryPlanNode.FetchNode.verify(message.fetch);\n                    if (error)\n                        return \"fetch.\" + error;\n                }\n            }\n            if (message.flatten != null && message.hasOwnProperty(\"flatten\")) {\n                if (properties.node === 1)\n                    return \"node: multiple values\";\n                properties.node = 1;\n                {\n                    let error = $root.Trace.QueryPlanNode.FlattenNode.verify(message.flatten);\n                    if (error)\n                        return \"flatten.\" + error;\n                }\n            }\n            if (message.defer != null && message.hasOwnProperty(\"defer\")) {\n                if (properties.node === 1)\n                    return \"node: multiple values\";\n                properties.node = 1;\n                {\n                    let error = $root.Trace.QueryPlanNode.DeferNode.verify(message.defer);\n                    if (error)\n                        return \"defer.\" + error;\n                }\n            }\n            if (message.condition != null && message.hasOwnProperty(\"condition\")) {\n                if (properties.node === 1)\n                    return \"node: multiple values\";\n                properties.node = 1;\n                {\n                    let error = $root.Trace.QueryPlanNode.ConditionNode.verify(message.condition);\n                    if (error)\n                        return \"condition.\" + error;\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Creates a plain object from a QueryPlanNode message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof Trace.QueryPlanNode\n         * @static\n         * @param {Trace.QueryPlanNode} message QueryPlanNode\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        QueryPlanNode.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            let object = {};\n            if (message.sequence != null && message.hasOwnProperty(\"sequence\")) {\n                object.sequence = $root.Trace.QueryPlanNode.SequenceNode.toObject(message.sequence, options);\n                if (options.oneofs)\n                    object.node = \"sequence\";\n            }\n            if (message.parallel != null && message.hasOwnProperty(\"parallel\")) {\n                object.parallel = $root.Trace.QueryPlanNode.ParallelNode.toObject(message.parallel, options);\n                if (options.oneofs)\n                    object.node = \"parallel\";\n            }\n            if (message.fetch != null && message.hasOwnProperty(\"fetch\")) {\n                object.fetch = $root.Trace.QueryPlanNode.FetchNode.toObject(message.fetch, options);\n                if (options.oneofs)\n                    object.node = \"fetch\";\n            }\n            if (message.flatten != null && message.hasOwnProperty(\"flatten\")) {\n                object.flatten = $root.Trace.QueryPlanNode.FlattenNode.toObject(message.flatten, options);\n                if (options.oneofs)\n                    object.node = \"flatten\";\n            }\n            if (message.defer != null && message.hasOwnProperty(\"defer\")) {\n                object.defer = $root.Trace.QueryPlanNode.DeferNode.toObject(message.defer, options);\n                if (options.oneofs)\n                    object.node = \"defer\";\n            }\n            if (message.condition != null && message.hasOwnProperty(\"condition\")) {\n                object.condition = $root.Trace.QueryPlanNode.ConditionNode.toObject(message.condition, options);\n                if (options.oneofs)\n                    object.node = \"condition\";\n            }\n            return object;\n        };\n\n        /**\n         * Converts this QueryPlanNode to JSON.\n         * @function toJSON\n         * @memberof Trace.QueryPlanNode\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        QueryPlanNode.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        QueryPlanNode.SequenceNode = (function() {\n\n            /**\n             * Properties of a SequenceNode.\n             * @memberof Trace.QueryPlanNode\n             * @interface ISequenceNode\n             * @property {Array.<Trace.IQueryPlanNode>|null} [nodes] SequenceNode nodes\n             */\n\n            /**\n             * Constructs a new SequenceNode.\n             * @memberof Trace.QueryPlanNode\n             * @classdesc Represents a SequenceNode.\n             * @implements ISequenceNode\n             * @constructor\n             * @param {Trace.QueryPlanNode.ISequenceNode=} [properties] Properties to set\n             */\n            function SequenceNode(properties) {\n                this.nodes = [];\n                if (properties)\n                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n\n            /**\n             * SequenceNode nodes.\n             * @member {Array.<Trace.IQueryPlanNode>} nodes\n             * @memberof Trace.QueryPlanNode.SequenceNode\n             * @instance\n             */\n            SequenceNode.prototype.nodes = $util.emptyArray;\n\n            /**\n             * Creates a new SequenceNode instance using the specified properties.\n             * @function create\n             * @memberof Trace.QueryPlanNode.SequenceNode\n             * @static\n             * @param {Trace.QueryPlanNode.ISequenceNode=} [properties] Properties to set\n             * @returns {Trace.QueryPlanNode.SequenceNode} SequenceNode instance\n             */\n            SequenceNode.create = function create(properties) {\n                return new SequenceNode(properties);\n            };\n\n            /**\n             * Encodes the specified SequenceNode message. Does not implicitly {@link Trace.QueryPlanNode.SequenceNode.verify|verify} messages.\n             * @function encode\n             * @memberof Trace.QueryPlanNode.SequenceNode\n             * @static\n             * @param {Trace.QueryPlanNode.ISequenceNode} message SequenceNode message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            SequenceNode.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.nodes != null && message.nodes.length)\n                    for (let i = 0; i < message.nodes.length; ++i)\n                        $root.Trace.QueryPlanNode.encode(message.nodes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                return writer;\n            };\n\n            /**\n             * Encodes the specified SequenceNode message, length delimited. Does not implicitly {@link Trace.QueryPlanNode.SequenceNode.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof Trace.QueryPlanNode.SequenceNode\n             * @static\n             * @param {Trace.QueryPlanNode.ISequenceNode} message SequenceNode message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            SequenceNode.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n\n            /**\n             * Decodes a SequenceNode message from the specified reader or buffer.\n             * @function decode\n             * @memberof Trace.QueryPlanNode.SequenceNode\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {Trace.QueryPlanNode.SequenceNode} SequenceNode\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            SequenceNode.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.SequenceNode();\n                while (reader.pos < end) {\n                    let tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        if (!(message.nodes && message.nodes.length))\n                            message.nodes = [];\n                        message.nodes.push($root.Trace.QueryPlanNode.decode(reader, reader.uint32()));\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n\n            /**\n             * Decodes a SequenceNode message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof Trace.QueryPlanNode.SequenceNode\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {Trace.QueryPlanNode.SequenceNode} SequenceNode\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            SequenceNode.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n\n            /**\n             * Verifies a SequenceNode message.\n             * @function verify\n             * @memberof Trace.QueryPlanNode.SequenceNode\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            SequenceNode.verify = function verify(message) {\n                if (typeof message !== \"object\" || message === null)\n                    return \"object expected\";\n                if (message.nodes != null && message.hasOwnProperty(\"nodes\")) {\n                    if (!Array.isArray(message.nodes))\n                        return \"nodes: array expected\";\n                    for (let i = 0; i < message.nodes.length; ++i) {\n                        let error = $root.Trace.QueryPlanNode.verify(message.nodes[i]);\n                        if (error)\n                            return \"nodes.\" + error;\n                    }\n                }\n                return null;\n            };\n\n            /**\n             * Creates a plain object from a SequenceNode message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof Trace.QueryPlanNode.SequenceNode\n             * @static\n             * @param {Trace.QueryPlanNode.SequenceNode} message SequenceNode\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            SequenceNode.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                let object = {};\n                if (options.arrays || options.defaults)\n                    object.nodes = [];\n                if (message.nodes && message.nodes.length) {\n                    object.nodes = [];\n                    for (let j = 0; j < message.nodes.length; ++j)\n                        object.nodes[j] = $root.Trace.QueryPlanNode.toObject(message.nodes[j], options);\n                }\n                return object;\n            };\n\n            /**\n             * Converts this SequenceNode to JSON.\n             * @function toJSON\n             * @memberof Trace.QueryPlanNode.SequenceNode\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            SequenceNode.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return SequenceNode;\n        })();\n\n        QueryPlanNode.ParallelNode = (function() {\n\n            /**\n             * Properties of a ParallelNode.\n             * @memberof Trace.QueryPlanNode\n             * @interface IParallelNode\n             * @property {Array.<Trace.IQueryPlanNode>|null} [nodes] ParallelNode nodes\n             */\n\n            /**\n             * Constructs a new ParallelNode.\n             * @memberof Trace.QueryPlanNode\n             * @classdesc Represents a ParallelNode.\n             * @implements IParallelNode\n             * @constructor\n             * @param {Trace.QueryPlanNode.IParallelNode=} [properties] Properties to set\n             */\n            function ParallelNode(properties) {\n                this.nodes = [];\n                if (properties)\n                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n\n            /**\n             * ParallelNode nodes.\n             * @member {Array.<Trace.IQueryPlanNode>} nodes\n             * @memberof Trace.QueryPlanNode.ParallelNode\n             * @instance\n             */\n            ParallelNode.prototype.nodes = $util.emptyArray;\n\n            /**\n             * Creates a new ParallelNode instance using the specified properties.\n             * @function create\n             * @memberof Trace.QueryPlanNode.ParallelNode\n             * @static\n             * @param {Trace.QueryPlanNode.IParallelNode=} [properties] Properties to set\n             * @returns {Trace.QueryPlanNode.ParallelNode} ParallelNode instance\n             */\n            ParallelNode.create = function create(properties) {\n                return new ParallelNode(properties);\n            };\n\n            /**\n             * Encodes the specified ParallelNode message. Does not implicitly {@link Trace.QueryPlanNode.ParallelNode.verify|verify} messages.\n             * @function encode\n             * @memberof Trace.QueryPlanNode.ParallelNode\n             * @static\n             * @param {Trace.QueryPlanNode.IParallelNode} message ParallelNode message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            ParallelNode.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.nodes != null && message.nodes.length)\n                    for (let i = 0; i < message.nodes.length; ++i)\n                        $root.Trace.QueryPlanNode.encode(message.nodes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                return writer;\n            };\n\n            /**\n             * Encodes the specified ParallelNode message, length delimited. Does not implicitly {@link Trace.QueryPlanNode.ParallelNode.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof Trace.QueryPlanNode.ParallelNode\n             * @static\n             * @param {Trace.QueryPlanNode.IParallelNode} message ParallelNode message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            ParallelNode.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n\n            /**\n             * Decodes a ParallelNode message from the specified reader or buffer.\n             * @function decode\n             * @memberof Trace.QueryPlanNode.ParallelNode\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {Trace.QueryPlanNode.ParallelNode} ParallelNode\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            ParallelNode.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.ParallelNode();\n                while (reader.pos < end) {\n                    let tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        if (!(message.nodes && message.nodes.length))\n                            message.nodes = [];\n                        message.nodes.push($root.Trace.QueryPlanNode.decode(reader, reader.uint32()));\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n\n            /**\n             * Decodes a ParallelNode message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof Trace.QueryPlanNode.ParallelNode\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {Trace.QueryPlanNode.ParallelNode} ParallelNode\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            ParallelNode.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n\n            /**\n             * Verifies a ParallelNode message.\n             * @function verify\n             * @memberof Trace.QueryPlanNode.ParallelNode\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            ParallelNode.verify = function verify(message) {\n                if (typeof message !== \"object\" || message === null)\n                    return \"object expected\";\n                if (message.nodes != null && message.hasOwnProperty(\"nodes\")) {\n                    if (!Array.isArray(message.nodes))\n                        return \"nodes: array expected\";\n                    for (let i = 0; i < message.nodes.length; ++i) {\n                        let error = $root.Trace.QueryPlanNode.verify(message.nodes[i]);\n                        if (error)\n                            return \"nodes.\" + error;\n                    }\n                }\n                return null;\n            };\n\n            /**\n             * Creates a plain object from a ParallelNode message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof Trace.QueryPlanNode.ParallelNode\n             * @static\n             * @param {Trace.QueryPlanNode.ParallelNode} message ParallelNode\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            ParallelNode.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                let object = {};\n                if (options.arrays || options.defaults)\n                    object.nodes = [];\n                if (message.nodes && message.nodes.length) {\n                    object.nodes = [];\n                    for (let j = 0; j < message.nodes.length; ++j)\n                        object.nodes[j] = $root.Trace.QueryPlanNode.toObject(message.nodes[j], options);\n                }\n                return object;\n            };\n\n            /**\n             * Converts this ParallelNode to JSON.\n             * @function toJSON\n             * @memberof Trace.QueryPlanNode.ParallelNode\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            ParallelNode.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return ParallelNode;\n        })();\n\n        QueryPlanNode.FetchNode = (function() {\n\n            /**\n             * Properties of a FetchNode.\n             * @memberof Trace.QueryPlanNode\n             * @interface IFetchNode\n             * @property {string|null} [serviceName] FetchNode serviceName\n             * @property {boolean|null} [traceParsingFailed] FetchNode traceParsingFailed\n             * @property {ITrace|null} [trace] FetchNode trace\n             * @property {number|null} [sentTimeOffset] FetchNode sentTimeOffset\n             * @property {google.protobuf.ITimestamp|null} [sentTime] FetchNode sentTime\n             * @property {google.protobuf.ITimestamp|null} [receivedTime] FetchNode receivedTime\n             */\n\n            /**\n             * Constructs a new FetchNode.\n             * @memberof Trace.QueryPlanNode\n             * @classdesc Represents a FetchNode.\n             * @implements IFetchNode\n             * @constructor\n             * @param {Trace.QueryPlanNode.IFetchNode=} [properties] Properties to set\n             */\n            function FetchNode(properties) {\n                if (properties)\n                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n\n            /**\n             * FetchNode serviceName.\n             * @member {string} serviceName\n             * @memberof Trace.QueryPlanNode.FetchNode\n             * @instance\n             */\n            FetchNode.prototype.serviceName = \"\";\n\n            /**\n             * FetchNode traceParsingFailed.\n             * @member {boolean} traceParsingFailed\n             * @memberof Trace.QueryPlanNode.FetchNode\n             * @instance\n             */\n            FetchNode.prototype.traceParsingFailed = false;\n\n            /**\n             * FetchNode trace.\n             * @member {ITrace|null|undefined} trace\n             * @memberof Trace.QueryPlanNode.FetchNode\n             * @instance\n             */\n            FetchNode.prototype.trace = null;\n\n            /**\n             * FetchNode sentTimeOffset.\n             * @member {number} sentTimeOffset\n             * @memberof Trace.QueryPlanNode.FetchNode\n             * @instance\n             */\n            FetchNode.prototype.sentTimeOffset = 0;\n\n            /**\n             * FetchNode sentTime.\n             * @member {google.protobuf.ITimestamp|null|undefined} sentTime\n             * @memberof Trace.QueryPlanNode.FetchNode\n             * @instance\n             */\n            FetchNode.prototype.sentTime = null;\n\n            /**\n             * FetchNode receivedTime.\n             * @member {google.protobuf.ITimestamp|null|undefined} receivedTime\n             * @memberof Trace.QueryPlanNode.FetchNode\n             * @instance\n             */\n            FetchNode.prototype.receivedTime = null;\n\n            /**\n             * Creates a new FetchNode instance using the specified properties.\n             * @function create\n             * @memberof Trace.QueryPlanNode.FetchNode\n             * @static\n             * @param {Trace.QueryPlanNode.IFetchNode=} [properties] Properties to set\n             * @returns {Trace.QueryPlanNode.FetchNode} FetchNode instance\n             */\n            FetchNode.create = function create(properties) {\n                return new FetchNode(properties);\n            };\n\n            /**\n             * Encodes the specified FetchNode message. Does not implicitly {@link Trace.QueryPlanNode.FetchNode.verify|verify} messages.\n             * @function encode\n             * @memberof Trace.QueryPlanNode.FetchNode\n             * @static\n             * @param {Trace.QueryPlanNode.IFetchNode} message FetchNode message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            FetchNode.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.serviceName != null && Object.hasOwnProperty.call(message, \"serviceName\"))\n                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.serviceName);\n                if (message.traceParsingFailed != null && Object.hasOwnProperty.call(message, \"traceParsingFailed\"))\n                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.traceParsingFailed);\n                if (message.trace != null && Object.hasOwnProperty.call(message, \"trace\"))\n                    $root.Trace.encode(message.trace, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n                if (message.sentTimeOffset != null && Object.hasOwnProperty.call(message, \"sentTimeOffset\"))\n                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.sentTimeOffset);\n                if (message.sentTime != null && Object.hasOwnProperty.call(message, \"sentTime\"))\n                    $root.google.protobuf.Timestamp.encode(message.sentTime, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();\n                if (message.receivedTime != null && Object.hasOwnProperty.call(message, \"receivedTime\"))\n                    $root.google.protobuf.Timestamp.encode(message.receivedTime, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();\n                return writer;\n            };\n\n            /**\n             * Encodes the specified FetchNode message, length delimited. Does not implicitly {@link Trace.QueryPlanNode.FetchNode.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof Trace.QueryPlanNode.FetchNode\n             * @static\n             * @param {Trace.QueryPlanNode.IFetchNode} message FetchNode message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            FetchNode.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n\n            /**\n             * Decodes a FetchNode message from the specified reader or buffer.\n             * @function decode\n             * @memberof Trace.QueryPlanNode.FetchNode\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {Trace.QueryPlanNode.FetchNode} FetchNode\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            FetchNode.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.FetchNode();\n                while (reader.pos < end) {\n                    let tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.serviceName = reader.string();\n                        break;\n                    case 2:\n                        message.traceParsingFailed = reader.bool();\n                        break;\n                    case 3:\n                        message.trace = $root.Trace.decode(reader, reader.uint32());\n                        break;\n                    case 4:\n                        message.sentTimeOffset = reader.uint64();\n                        break;\n                    case 5:\n                        message.sentTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());\n                        break;\n                    case 6:\n                        message.receivedTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n\n            /**\n             * Decodes a FetchNode message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof Trace.QueryPlanNode.FetchNode\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {Trace.QueryPlanNode.FetchNode} FetchNode\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            FetchNode.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n\n            /**\n             * Verifies a FetchNode message.\n             * @function verify\n             * @memberof Trace.QueryPlanNode.FetchNode\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            FetchNode.verify = function verify(message) {\n                if (typeof message !== \"object\" || message === null)\n                    return \"object expected\";\n                if (message.serviceName != null && message.hasOwnProperty(\"serviceName\"))\n                    if (!$util.isString(message.serviceName))\n                        return \"serviceName: string expected\";\n                if (message.traceParsingFailed != null && message.hasOwnProperty(\"traceParsingFailed\"))\n                    if (typeof message.traceParsingFailed !== \"boolean\")\n                        return \"traceParsingFailed: boolean expected\";\n                if (message.trace != null && message.hasOwnProperty(\"trace\")) {\n                    let error = $root.Trace.verify(message.trace);\n                    if (error)\n                        return \"trace.\" + error;\n                }\n                if (message.sentTimeOffset != null && message.hasOwnProperty(\"sentTimeOffset\"))\n                    if (!$util.isInteger(message.sentTimeOffset) && !(message.sentTimeOffset && $util.isInteger(message.sentTimeOffset.low) && $util.isInteger(message.sentTimeOffset.high)))\n                        return \"sentTimeOffset: integer|Long expected\";\n                if (message.sentTime != null && message.hasOwnProperty(\"sentTime\")) {\n                    let error = $root.google.protobuf.Timestamp.verify(message.sentTime);\n                    if (error)\n                        return \"sentTime.\" + error;\n                }\n                if (message.receivedTime != null && message.hasOwnProperty(\"receivedTime\")) {\n                    let error = $root.google.protobuf.Timestamp.verify(message.receivedTime);\n                    if (error)\n                        return \"receivedTime.\" + error;\n                }\n                return null;\n            };\n\n            /**\n             * Creates a plain object from a FetchNode message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof Trace.QueryPlanNode.FetchNode\n             * @static\n             * @param {Trace.QueryPlanNode.FetchNode} message FetchNode\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            FetchNode.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                let object = {};\n                if (options.defaults) {\n                    object.serviceName = \"\";\n                    object.traceParsingFailed = false;\n                    object.trace = null;\n                    object.sentTimeOffset = 0;\n                    object.sentTime = null;\n                    object.receivedTime = null;\n                }\n                if (message.serviceName != null && message.hasOwnProperty(\"serviceName\"))\n                    object.serviceName = message.serviceName;\n                if (message.traceParsingFailed != null && message.hasOwnProperty(\"traceParsingFailed\"))\n                    object.traceParsingFailed = message.traceParsingFailed;\n                if (message.trace != null && message.hasOwnProperty(\"trace\"))\n                    object.trace = $root.Trace.toObject(message.trace, options);\n                if (message.sentTimeOffset != null && message.hasOwnProperty(\"sentTimeOffset\"))\n                    if (typeof message.sentTimeOffset === \"number\")\n                        object.sentTimeOffset = options.longs === String ? String(message.sentTimeOffset) : message.sentTimeOffset;\n                    else\n                        object.sentTimeOffset = options.longs === String ? $util.Long.prototype.toString.call(message.sentTimeOffset) : options.longs === Number ? new $util.LongBits(message.sentTimeOffset.low >>> 0, message.sentTimeOffset.high >>> 0).toNumber(true) : message.sentTimeOffset;\n                if (message.sentTime != null && message.hasOwnProperty(\"sentTime\"))\n                    object.sentTime = $root.google.protobuf.Timestamp.toObject(message.sentTime, options);\n                if (message.receivedTime != null && message.hasOwnProperty(\"receivedTime\"))\n                    object.receivedTime = $root.google.protobuf.Timestamp.toObject(message.receivedTime, options);\n                return object;\n            };\n\n            /**\n             * Converts this FetchNode to JSON.\n             * @function toJSON\n             * @memberof Trace.QueryPlanNode.FetchNode\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            FetchNode.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return FetchNode;\n        })();\n\n        QueryPlanNode.FlattenNode = (function() {\n\n            /**\n             * Properties of a FlattenNode.\n             * @memberof Trace.QueryPlanNode\n             * @interface IFlattenNode\n             * @property {Array.<Trace.QueryPlanNode.IResponsePathElement>|null} [responsePath] FlattenNode responsePath\n             * @property {Trace.IQueryPlanNode|null} [node] FlattenNode node\n             */\n\n            /**\n             * Constructs a new FlattenNode.\n             * @memberof Trace.QueryPlanNode\n             * @classdesc Represents a FlattenNode.\n             * @implements IFlattenNode\n             * @constructor\n             * @param {Trace.QueryPlanNode.IFlattenNode=} [properties] Properties to set\n             */\n            function FlattenNode(properties) {\n                this.responsePath = [];\n                if (properties)\n                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n\n            /**\n             * FlattenNode responsePath.\n             * @member {Array.<Trace.QueryPlanNode.IResponsePathElement>} responsePath\n             * @memberof Trace.QueryPlanNode.FlattenNode\n             * @instance\n             */\n            FlattenNode.prototype.responsePath = $util.emptyArray;\n\n            /**\n             * FlattenNode node.\n             * @member {Trace.IQueryPlanNode|null|undefined} node\n             * @memberof Trace.QueryPlanNode.FlattenNode\n             * @instance\n             */\n            FlattenNode.prototype.node = null;\n\n            /**\n             * Creates a new FlattenNode instance using the specified properties.\n             * @function create\n             * @memberof Trace.QueryPlanNode.FlattenNode\n             * @static\n             * @param {Trace.QueryPlanNode.IFlattenNode=} [properties] Properties to set\n             * @returns {Trace.QueryPlanNode.FlattenNode} FlattenNode instance\n             */\n            FlattenNode.create = function create(properties) {\n                return new FlattenNode(properties);\n            };\n\n            /**\n             * Encodes the specified FlattenNode message. Does not implicitly {@link Trace.QueryPlanNode.FlattenNode.verify|verify} messages.\n             * @function encode\n             * @memberof Trace.QueryPlanNode.FlattenNode\n             * @static\n             * @param {Trace.QueryPlanNode.IFlattenNode} message FlattenNode message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            FlattenNode.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.responsePath != null && message.responsePath.length)\n                    for (let i = 0; i < message.responsePath.length; ++i)\n                        $root.Trace.QueryPlanNode.ResponsePathElement.encode(message.responsePath[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                if (message.node != null && Object.hasOwnProperty.call(message, \"node\"))\n                    $root.Trace.QueryPlanNode.encode(message.node, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                return writer;\n            };\n\n            /**\n             * Encodes the specified FlattenNode message, length delimited. Does not implicitly {@link Trace.QueryPlanNode.FlattenNode.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof Trace.QueryPlanNode.FlattenNode\n             * @static\n             * @param {Trace.QueryPlanNode.IFlattenNode} message FlattenNode message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            FlattenNode.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n\n            /**\n             * Decodes a FlattenNode message from the specified reader or buffer.\n             * @function decode\n             * @memberof Trace.QueryPlanNode.FlattenNode\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {Trace.QueryPlanNode.FlattenNode} FlattenNode\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            FlattenNode.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.FlattenNode();\n                while (reader.pos < end) {\n                    let tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        if (!(message.responsePath && message.responsePath.length))\n                            message.responsePath = [];\n                        message.responsePath.push($root.Trace.QueryPlanNode.ResponsePathElement.decode(reader, reader.uint32()));\n                        break;\n                    case 2:\n                        message.node = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n\n            /**\n             * Decodes a FlattenNode message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof Trace.QueryPlanNode.FlattenNode\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {Trace.QueryPlanNode.FlattenNode} FlattenNode\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            FlattenNode.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n\n            /**\n             * Verifies a FlattenNode message.\n             * @function verify\n             * @memberof Trace.QueryPlanNode.FlattenNode\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            FlattenNode.verify = function verify(message) {\n                if (typeof message !== \"object\" || message === null)\n                    return \"object expected\";\n                if (message.responsePath != null && message.hasOwnProperty(\"responsePath\")) {\n                    if (!Array.isArray(message.responsePath))\n                        return \"responsePath: array expected\";\n                    for (let i = 0; i < message.responsePath.length; ++i) {\n                        let error = $root.Trace.QueryPlanNode.ResponsePathElement.verify(message.responsePath[i]);\n                        if (error)\n                            return \"responsePath.\" + error;\n                    }\n                }\n                if (message.node != null && message.hasOwnProperty(\"node\")) {\n                    let error = $root.Trace.QueryPlanNode.verify(message.node);\n                    if (error)\n                        return \"node.\" + error;\n                }\n                return null;\n            };\n\n            /**\n             * Creates a plain object from a FlattenNode message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof Trace.QueryPlanNode.FlattenNode\n             * @static\n             * @param {Trace.QueryPlanNode.FlattenNode} message FlattenNode\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            FlattenNode.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                let object = {};\n                if (options.arrays || options.defaults)\n                    object.responsePath = [];\n                if (options.defaults)\n                    object.node = null;\n                if (message.responsePath && message.responsePath.length) {\n                    object.responsePath = [];\n                    for (let j = 0; j < message.responsePath.length; ++j)\n                        object.responsePath[j] = $root.Trace.QueryPlanNode.ResponsePathElement.toObject(message.responsePath[j], options);\n                }\n                if (message.node != null && message.hasOwnProperty(\"node\"))\n                    object.node = $root.Trace.QueryPlanNode.toObject(message.node, options);\n                return object;\n            };\n\n            /**\n             * Converts this FlattenNode to JSON.\n             * @function toJSON\n             * @memberof Trace.QueryPlanNode.FlattenNode\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            FlattenNode.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return FlattenNode;\n        })();\n\n        QueryPlanNode.DeferNode = (function() {\n\n            /**\n             * Properties of a DeferNode.\n             * @memberof Trace.QueryPlanNode\n             * @interface IDeferNode\n             * @property {Trace.QueryPlanNode.IDeferNodePrimary|null} [primary] DeferNode primary\n             * @property {Array.<Trace.QueryPlanNode.IDeferredNode>|null} [deferred] DeferNode deferred\n             */\n\n            /**\n             * Constructs a new DeferNode.\n             * @memberof Trace.QueryPlanNode\n             * @classdesc Represents a DeferNode.\n             * @implements IDeferNode\n             * @constructor\n             * @param {Trace.QueryPlanNode.IDeferNode=} [properties] Properties to set\n             */\n            function DeferNode(properties) {\n                this.deferred = [];\n                if (properties)\n                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n\n            /**\n             * DeferNode primary.\n             * @member {Trace.QueryPlanNode.IDeferNodePrimary|null|undefined} primary\n             * @memberof Trace.QueryPlanNode.DeferNode\n             * @instance\n             */\n            DeferNode.prototype.primary = null;\n\n            /**\n             * DeferNode deferred.\n             * @member {Array.<Trace.QueryPlanNode.IDeferredNode>} deferred\n             * @memberof Trace.QueryPlanNode.DeferNode\n             * @instance\n             */\n            DeferNode.prototype.deferred = $util.emptyArray;\n\n            /**\n             * Creates a new DeferNode instance using the specified properties.\n             * @function create\n             * @memberof Trace.QueryPlanNode.DeferNode\n             * @static\n             * @param {Trace.QueryPlanNode.IDeferNode=} [properties] Properties to set\n             * @returns {Trace.QueryPlanNode.DeferNode} DeferNode instance\n             */\n            DeferNode.create = function create(properties) {\n                return new DeferNode(properties);\n            };\n\n            /**\n             * Encodes the specified DeferNode message. Does not implicitly {@link Trace.QueryPlanNode.DeferNode.verify|verify} messages.\n             * @function encode\n             * @memberof Trace.QueryPlanNode.DeferNode\n             * @static\n             * @param {Trace.QueryPlanNode.IDeferNode} message DeferNode message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            DeferNode.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.primary != null && Object.hasOwnProperty.call(message, \"primary\"))\n                    $root.Trace.QueryPlanNode.DeferNodePrimary.encode(message.primary, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                if (message.deferred != null && message.deferred.length)\n                    for (let i = 0; i < message.deferred.length; ++i)\n                        $root.Trace.QueryPlanNode.DeferredNode.encode(message.deferred[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                return writer;\n            };\n\n            /**\n             * Encodes the specified DeferNode message, length delimited. Does not implicitly {@link Trace.QueryPlanNode.DeferNode.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof Trace.QueryPlanNode.DeferNode\n             * @static\n             * @param {Trace.QueryPlanNode.IDeferNode} message DeferNode message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            DeferNode.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n\n            /**\n             * Decodes a DeferNode message from the specified reader or buffer.\n             * @function decode\n             * @memberof Trace.QueryPlanNode.DeferNode\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {Trace.QueryPlanNode.DeferNode} DeferNode\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            DeferNode.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.DeferNode();\n                while (reader.pos < end) {\n                    let tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.primary = $root.Trace.QueryPlanNode.DeferNodePrimary.decode(reader, reader.uint32());\n                        break;\n                    case 2:\n                        if (!(message.deferred && message.deferred.length))\n                            message.deferred = [];\n                        message.deferred.push($root.Trace.QueryPlanNode.DeferredNode.decode(reader, reader.uint32()));\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n\n            /**\n             * Decodes a DeferNode message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof Trace.QueryPlanNode.DeferNode\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {Trace.QueryPlanNode.DeferNode} DeferNode\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            DeferNode.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n\n            /**\n             * Verifies a DeferNode message.\n             * @function verify\n             * @memberof Trace.QueryPlanNode.DeferNode\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            DeferNode.verify = function verify(message) {\n                if (typeof message !== \"object\" || message === null)\n                    return \"object expected\";\n                if (message.primary != null && message.hasOwnProperty(\"primary\")) {\n                    let error = $root.Trace.QueryPlanNode.DeferNodePrimary.verify(message.primary);\n                    if (error)\n                        return \"primary.\" + error;\n                }\n                if (message.deferred != null && message.hasOwnProperty(\"deferred\")) {\n                    if (!Array.isArray(message.deferred))\n                        return \"deferred: array expected\";\n                    for (let i = 0; i < message.deferred.length; ++i) {\n                        let error = $root.Trace.QueryPlanNode.DeferredNode.verify(message.deferred[i]);\n                        if (error)\n                            return \"deferred.\" + error;\n                    }\n                }\n                return null;\n            };\n\n            /**\n             * Creates a plain object from a DeferNode message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof Trace.QueryPlanNode.DeferNode\n             * @static\n             * @param {Trace.QueryPlanNode.DeferNode} message DeferNode\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            DeferNode.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                let object = {};\n                if (options.arrays || options.defaults)\n                    object.deferred = [];\n                if (options.defaults)\n                    object.primary = null;\n                if (message.primary != null && message.hasOwnProperty(\"primary\"))\n                    object.primary = $root.Trace.QueryPlanNode.DeferNodePrimary.toObject(message.primary, options);\n                if (message.deferred && message.deferred.length) {\n                    object.deferred = [];\n                    for (let j = 0; j < message.deferred.length; ++j)\n                        object.deferred[j] = $root.Trace.QueryPlanNode.DeferredNode.toObject(message.deferred[j], options);\n                }\n                return object;\n            };\n\n            /**\n             * Converts this DeferNode to JSON.\n             * @function toJSON\n             * @memberof Trace.QueryPlanNode.DeferNode\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            DeferNode.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return DeferNode;\n        })();\n\n        QueryPlanNode.ConditionNode = (function() {\n\n            /**\n             * Properties of a ConditionNode.\n             * @memberof Trace.QueryPlanNode\n             * @interface IConditionNode\n             * @property {string|null} [condition] ConditionNode condition\n             * @property {Trace.IQueryPlanNode|null} [ifClause] ConditionNode ifClause\n             * @property {Trace.IQueryPlanNode|null} [elseClause] ConditionNode elseClause\n             */\n\n            /**\n             * Constructs a new ConditionNode.\n             * @memberof Trace.QueryPlanNode\n             * @classdesc Represents a ConditionNode.\n             * @implements IConditionNode\n             * @constructor\n             * @param {Trace.QueryPlanNode.IConditionNode=} [properties] Properties to set\n             */\n            function ConditionNode(properties) {\n                if (properties)\n                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n\n            /**\n             * ConditionNode condition.\n             * @member {string} condition\n             * @memberof Trace.QueryPlanNode.ConditionNode\n             * @instance\n             */\n            ConditionNode.prototype.condition = \"\";\n\n            /**\n             * ConditionNode ifClause.\n             * @member {Trace.IQueryPlanNode|null|undefined} ifClause\n             * @memberof Trace.QueryPlanNode.ConditionNode\n             * @instance\n             */\n            ConditionNode.prototype.ifClause = null;\n\n            /**\n             * ConditionNode elseClause.\n             * @member {Trace.IQueryPlanNode|null|undefined} elseClause\n             * @memberof Trace.QueryPlanNode.ConditionNode\n             * @instance\n             */\n            ConditionNode.prototype.elseClause = null;\n\n            /**\n             * Creates a new ConditionNode instance using the specified properties.\n             * @function create\n             * @memberof Trace.QueryPlanNode.ConditionNode\n             * @static\n             * @param {Trace.QueryPlanNode.IConditionNode=} [properties] Properties to set\n             * @returns {Trace.QueryPlanNode.ConditionNode} ConditionNode instance\n             */\n            ConditionNode.create = function create(properties) {\n                return new ConditionNode(properties);\n            };\n\n            /**\n             * Encodes the specified ConditionNode message. Does not implicitly {@link Trace.QueryPlanNode.ConditionNode.verify|verify} messages.\n             * @function encode\n             * @memberof Trace.QueryPlanNode.ConditionNode\n             * @static\n             * @param {Trace.QueryPlanNode.IConditionNode} message ConditionNode message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            ConditionNode.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.condition != null && Object.hasOwnProperty.call(message, \"condition\"))\n                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.condition);\n                if (message.ifClause != null && Object.hasOwnProperty.call(message, \"ifClause\"))\n                    $root.Trace.QueryPlanNode.encode(message.ifClause, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                if (message.elseClause != null && Object.hasOwnProperty.call(message, \"elseClause\"))\n                    $root.Trace.QueryPlanNode.encode(message.elseClause, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n                return writer;\n            };\n\n            /**\n             * Encodes the specified ConditionNode message, length delimited. Does not implicitly {@link Trace.QueryPlanNode.ConditionNode.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof Trace.QueryPlanNode.ConditionNode\n             * @static\n             * @param {Trace.QueryPlanNode.IConditionNode} message ConditionNode message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            ConditionNode.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n\n            /**\n             * Decodes a ConditionNode message from the specified reader or buffer.\n             * @function decode\n             * @memberof Trace.QueryPlanNode.ConditionNode\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {Trace.QueryPlanNode.ConditionNode} ConditionNode\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            ConditionNode.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.ConditionNode();\n                while (reader.pos < end) {\n                    let tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.condition = reader.string();\n                        break;\n                    case 2:\n                        message.ifClause = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());\n                        break;\n                    case 3:\n                        message.elseClause = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n\n            /**\n             * Decodes a ConditionNode message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof Trace.QueryPlanNode.ConditionNode\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {Trace.QueryPlanNode.ConditionNode} ConditionNode\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            ConditionNode.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n\n            /**\n             * Verifies a ConditionNode message.\n             * @function verify\n             * @memberof Trace.QueryPlanNode.ConditionNode\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            ConditionNode.verify = function verify(message) {\n                if (typeof message !== \"object\" || message === null)\n                    return \"object expected\";\n                if (message.condition != null && message.hasOwnProperty(\"condition\"))\n                    if (!$util.isString(message.condition))\n                        return \"condition: string expected\";\n                if (message.ifClause != null && message.hasOwnProperty(\"ifClause\")) {\n                    let error = $root.Trace.QueryPlanNode.verify(message.ifClause);\n                    if (error)\n                        return \"ifClause.\" + error;\n                }\n                if (message.elseClause != null && message.hasOwnProperty(\"elseClause\")) {\n                    let error = $root.Trace.QueryPlanNode.verify(message.elseClause);\n                    if (error)\n                        return \"elseClause.\" + error;\n                }\n                return null;\n            };\n\n            /**\n             * Creates a plain object from a ConditionNode message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof Trace.QueryPlanNode.ConditionNode\n             * @static\n             * @param {Trace.QueryPlanNode.ConditionNode} message ConditionNode\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            ConditionNode.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                let object = {};\n                if (options.defaults) {\n                    object.condition = \"\";\n                    object.ifClause = null;\n                    object.elseClause = null;\n                }\n                if (message.condition != null && message.hasOwnProperty(\"condition\"))\n                    object.condition = message.condition;\n                if (message.ifClause != null && message.hasOwnProperty(\"ifClause\"))\n                    object.ifClause = $root.Trace.QueryPlanNode.toObject(message.ifClause, options);\n                if (message.elseClause != null && message.hasOwnProperty(\"elseClause\"))\n                    object.elseClause = $root.Trace.QueryPlanNode.toObject(message.elseClause, options);\n                return object;\n            };\n\n            /**\n             * Converts this ConditionNode to JSON.\n             * @function toJSON\n             * @memberof Trace.QueryPlanNode.ConditionNode\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            ConditionNode.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return ConditionNode;\n        })();\n\n        QueryPlanNode.DeferNodePrimary = (function() {\n\n            /**\n             * Properties of a DeferNodePrimary.\n             * @memberof Trace.QueryPlanNode\n             * @interface IDeferNodePrimary\n             * @property {Trace.IQueryPlanNode|null} [node] DeferNodePrimary node\n             */\n\n            /**\n             * Constructs a new DeferNodePrimary.\n             * @memberof Trace.QueryPlanNode\n             * @classdesc Represents a DeferNodePrimary.\n             * @implements IDeferNodePrimary\n             * @constructor\n             * @param {Trace.QueryPlanNode.IDeferNodePrimary=} [properties] Properties to set\n             */\n            function DeferNodePrimary(properties) {\n                if (properties)\n                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n\n            /**\n             * DeferNodePrimary node.\n             * @member {Trace.IQueryPlanNode|null|undefined} node\n             * @memberof Trace.QueryPlanNode.DeferNodePrimary\n             * @instance\n             */\n            DeferNodePrimary.prototype.node = null;\n\n            /**\n             * Creates a new DeferNodePrimary instance using the specified properties.\n             * @function create\n             * @memberof Trace.QueryPlanNode.DeferNodePrimary\n             * @static\n             * @param {Trace.QueryPlanNode.IDeferNodePrimary=} [properties] Properties to set\n             * @returns {Trace.QueryPlanNode.DeferNodePrimary} DeferNodePrimary instance\n             */\n            DeferNodePrimary.create = function create(properties) {\n                return new DeferNodePrimary(properties);\n            };\n\n            /**\n             * Encodes the specified DeferNodePrimary message. Does not implicitly {@link Trace.QueryPlanNode.DeferNodePrimary.verify|verify} messages.\n             * @function encode\n             * @memberof Trace.QueryPlanNode.DeferNodePrimary\n             * @static\n             * @param {Trace.QueryPlanNode.IDeferNodePrimary} message DeferNodePrimary message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            DeferNodePrimary.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.node != null && Object.hasOwnProperty.call(message, \"node\"))\n                    $root.Trace.QueryPlanNode.encode(message.node, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                return writer;\n            };\n\n            /**\n             * Encodes the specified DeferNodePrimary message, length delimited. Does not implicitly {@link Trace.QueryPlanNode.DeferNodePrimary.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof Trace.QueryPlanNode.DeferNodePrimary\n             * @static\n             * @param {Trace.QueryPlanNode.IDeferNodePrimary} message DeferNodePrimary message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            DeferNodePrimary.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n\n            /**\n             * Decodes a DeferNodePrimary message from the specified reader or buffer.\n             * @function decode\n             * @memberof Trace.QueryPlanNode.DeferNodePrimary\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {Trace.QueryPlanNode.DeferNodePrimary} DeferNodePrimary\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            DeferNodePrimary.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.DeferNodePrimary();\n                while (reader.pos < end) {\n                    let tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.node = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n\n            /**\n             * Decodes a DeferNodePrimary message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof Trace.QueryPlanNode.DeferNodePrimary\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {Trace.QueryPlanNode.DeferNodePrimary} DeferNodePrimary\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            DeferNodePrimary.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n\n            /**\n             * Verifies a DeferNodePrimary message.\n             * @function verify\n             * @memberof Trace.QueryPlanNode.DeferNodePrimary\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            DeferNodePrimary.verify = function verify(message) {\n                if (typeof message !== \"object\" || message === null)\n                    return \"object expected\";\n                if (message.node != null && message.hasOwnProperty(\"node\")) {\n                    let error = $root.Trace.QueryPlanNode.verify(message.node);\n                    if (error)\n                        return \"node.\" + error;\n                }\n                return null;\n            };\n\n            /**\n             * Creates a plain object from a DeferNodePrimary message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof Trace.QueryPlanNode.DeferNodePrimary\n             * @static\n             * @param {Trace.QueryPlanNode.DeferNodePrimary} message DeferNodePrimary\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            DeferNodePrimary.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                let object = {};\n                if (options.defaults)\n                    object.node = null;\n                if (message.node != null && message.hasOwnProperty(\"node\"))\n                    object.node = $root.Trace.QueryPlanNode.toObject(message.node, options);\n                return object;\n            };\n\n            /**\n             * Converts this DeferNodePrimary to JSON.\n             * @function toJSON\n             * @memberof Trace.QueryPlanNode.DeferNodePrimary\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            DeferNodePrimary.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return DeferNodePrimary;\n        })();\n\n        QueryPlanNode.DeferredNode = (function() {\n\n            /**\n             * Properties of a DeferredNode.\n             * @memberof Trace.QueryPlanNode\n             * @interface IDeferredNode\n             * @property {Array.<Trace.QueryPlanNode.IDeferredNodeDepends>|null} [depends] DeferredNode depends\n             * @property {string|null} [label] DeferredNode label\n             * @property {Array.<Trace.QueryPlanNode.IResponsePathElement>|null} [path] DeferredNode path\n             * @property {Trace.IQueryPlanNode|null} [node] DeferredNode node\n             */\n\n            /**\n             * Constructs a new DeferredNode.\n             * @memberof Trace.QueryPlanNode\n             * @classdesc Represents a DeferredNode.\n             * @implements IDeferredNode\n             * @constructor\n             * @param {Trace.QueryPlanNode.IDeferredNode=} [properties] Properties to set\n             */\n            function DeferredNode(properties) {\n                this.depends = [];\n                this.path = [];\n                if (properties)\n                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n\n            /**\n             * DeferredNode depends.\n             * @member {Array.<Trace.QueryPlanNode.IDeferredNodeDepends>} depends\n             * @memberof Trace.QueryPlanNode.DeferredNode\n             * @instance\n             */\n            DeferredNode.prototype.depends = $util.emptyArray;\n\n            /**\n             * DeferredNode label.\n             * @member {string} label\n             * @memberof Trace.QueryPlanNode.DeferredNode\n             * @instance\n             */\n            DeferredNode.prototype.label = \"\";\n\n            /**\n             * DeferredNode path.\n             * @member {Array.<Trace.QueryPlanNode.IResponsePathElement>} path\n             * @memberof Trace.QueryPlanNode.DeferredNode\n             * @instance\n             */\n            DeferredNode.prototype.path = $util.emptyArray;\n\n            /**\n             * DeferredNode node.\n             * @member {Trace.IQueryPlanNode|null|undefined} node\n             * @memberof Trace.QueryPlanNode.DeferredNode\n             * @instance\n             */\n            DeferredNode.prototype.node = null;\n\n            /**\n             * Creates a new DeferredNode instance using the specified properties.\n             * @function create\n             * @memberof Trace.QueryPlanNode.DeferredNode\n             * @static\n             * @param {Trace.QueryPlanNode.IDeferredNode=} [properties] Properties to set\n             * @returns {Trace.QueryPlanNode.DeferredNode} DeferredNode instance\n             */\n            DeferredNode.create = function create(properties) {\n                return new DeferredNode(properties);\n            };\n\n            /**\n             * Encodes the specified DeferredNode message. Does not implicitly {@link Trace.QueryPlanNode.DeferredNode.verify|verify} messages.\n             * @function encode\n             * @memberof Trace.QueryPlanNode.DeferredNode\n             * @static\n             * @param {Trace.QueryPlanNode.IDeferredNode} message DeferredNode message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            DeferredNode.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.depends != null && message.depends.length)\n                    for (let i = 0; i < message.depends.length; ++i)\n                        $root.Trace.QueryPlanNode.DeferredNodeDepends.encode(message.depends[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                if (message.label != null && Object.hasOwnProperty.call(message, \"label\"))\n                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.label);\n                if (message.path != null && message.path.length)\n                    for (let i = 0; i < message.path.length; ++i)\n                        $root.Trace.QueryPlanNode.ResponsePathElement.encode(message.path[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n                if (message.node != null && Object.hasOwnProperty.call(message, \"node\"))\n                    $root.Trace.QueryPlanNode.encode(message.node, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n                return writer;\n            };\n\n            /**\n             * Encodes the specified DeferredNode message, length delimited. Does not implicitly {@link Trace.QueryPlanNode.DeferredNode.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof Trace.QueryPlanNode.DeferredNode\n             * @static\n             * @param {Trace.QueryPlanNode.IDeferredNode} message DeferredNode message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            DeferredNode.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n\n            /**\n             * Decodes a DeferredNode message from the specified reader or buffer.\n             * @function decode\n             * @memberof Trace.QueryPlanNode.DeferredNode\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {Trace.QueryPlanNode.DeferredNode} DeferredNode\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            DeferredNode.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.DeferredNode();\n                while (reader.pos < end) {\n                    let tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        if (!(message.depends && message.depends.length))\n                            message.depends = [];\n                        message.depends.push($root.Trace.QueryPlanNode.DeferredNodeDepends.decode(reader, reader.uint32()));\n                        break;\n                    case 2:\n                        message.label = reader.string();\n                        break;\n                    case 3:\n                        if (!(message.path && message.path.length))\n                            message.path = [];\n                        message.path.push($root.Trace.QueryPlanNode.ResponsePathElement.decode(reader, reader.uint32()));\n                        break;\n                    case 4:\n                        message.node = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n\n            /**\n             * Decodes a DeferredNode message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof Trace.QueryPlanNode.DeferredNode\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {Trace.QueryPlanNode.DeferredNode} DeferredNode\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            DeferredNode.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n\n            /**\n             * Verifies a DeferredNode message.\n             * @function verify\n             * @memberof Trace.QueryPlanNode.DeferredNode\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            DeferredNode.verify = function verify(message) {\n                if (typeof message !== \"object\" || message === null)\n                    return \"object expected\";\n                if (message.depends != null && message.hasOwnProperty(\"depends\")) {\n                    if (!Array.isArray(message.depends))\n                        return \"depends: array expected\";\n                    for (let i = 0; i < message.depends.length; ++i) {\n                        let error = $root.Trace.QueryPlanNode.DeferredNodeDepends.verify(message.depends[i]);\n                        if (error)\n                            return \"depends.\" + error;\n                    }\n                }\n                if (message.label != null && message.hasOwnProperty(\"label\"))\n                    if (!$util.isString(message.label))\n                        return \"label: string expected\";\n                if (message.path != null && message.hasOwnProperty(\"path\")) {\n                    if (!Array.isArray(message.path))\n                        return \"path: array expected\";\n                    for (let i = 0; i < message.path.length; ++i) {\n                        let error = $root.Trace.QueryPlanNode.ResponsePathElement.verify(message.path[i]);\n                        if (error)\n                            return \"path.\" + error;\n                    }\n                }\n                if (message.node != null && message.hasOwnProperty(\"node\")) {\n                    let error = $root.Trace.QueryPlanNode.verify(message.node);\n                    if (error)\n                        return \"node.\" + error;\n                }\n                return null;\n            };\n\n            /**\n             * Creates a plain object from a DeferredNode message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof Trace.QueryPlanNode.DeferredNode\n             * @static\n             * @param {Trace.QueryPlanNode.DeferredNode} message DeferredNode\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            DeferredNode.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                let object = {};\n                if (options.arrays || options.defaults) {\n                    object.depends = [];\n                    object.path = [];\n                }\n                if (options.defaults) {\n                    object.label = \"\";\n                    object.node = null;\n                }\n                if (message.depends && message.depends.length) {\n                    object.depends = [];\n                    for (let j = 0; j < message.depends.length; ++j)\n                        object.depends[j] = $root.Trace.QueryPlanNode.DeferredNodeDepends.toObject(message.depends[j], options);\n                }\n                if (message.label != null && message.hasOwnProperty(\"label\"))\n                    object.label = message.label;\n                if (message.path && message.path.length) {\n                    object.path = [];\n                    for (let j = 0; j < message.path.length; ++j)\n                        object.path[j] = $root.Trace.QueryPlanNode.ResponsePathElement.toObject(message.path[j], options);\n                }\n                if (message.node != null && message.hasOwnProperty(\"node\"))\n                    object.node = $root.Trace.QueryPlanNode.toObject(message.node, options);\n                return object;\n            };\n\n            /**\n             * Converts this DeferredNode to JSON.\n             * @function toJSON\n             * @memberof Trace.QueryPlanNode.DeferredNode\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            DeferredNode.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return DeferredNode;\n        })();\n\n        QueryPlanNode.DeferredNodeDepends = (function() {\n\n            /**\n             * Properties of a DeferredNodeDepends.\n             * @memberof Trace.QueryPlanNode\n             * @interface IDeferredNodeDepends\n             * @property {string|null} [id] DeferredNodeDepends id\n             * @property {string|null} [deferLabel] DeferredNodeDepends deferLabel\n             */\n\n            /**\n             * Constructs a new DeferredNodeDepends.\n             * @memberof Trace.QueryPlanNode\n             * @classdesc Represents a DeferredNodeDepends.\n             * @implements IDeferredNodeDepends\n             * @constructor\n             * @param {Trace.QueryPlanNode.IDeferredNodeDepends=} [properties] Properties to set\n             */\n            function DeferredNodeDepends(properties) {\n                if (properties)\n                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n\n            /**\n             * DeferredNodeDepends id.\n             * @member {string} id\n             * @memberof Trace.QueryPlanNode.DeferredNodeDepends\n             * @instance\n             */\n            DeferredNodeDepends.prototype.id = \"\";\n\n            /**\n             * DeferredNodeDepends deferLabel.\n             * @member {string} deferLabel\n             * @memberof Trace.QueryPlanNode.DeferredNodeDepends\n             * @instance\n             */\n            DeferredNodeDepends.prototype.deferLabel = \"\";\n\n            /**\n             * Creates a new DeferredNodeDepends instance using the specified properties.\n             * @function create\n             * @memberof Trace.QueryPlanNode.DeferredNodeDepends\n             * @static\n             * @param {Trace.QueryPlanNode.IDeferredNodeDepends=} [properties] Properties to set\n             * @returns {Trace.QueryPlanNode.DeferredNodeDepends} DeferredNodeDepends instance\n             */\n            DeferredNodeDepends.create = function create(properties) {\n                return new DeferredNodeDepends(properties);\n            };\n\n            /**\n             * Encodes the specified DeferredNodeDepends message. Does not implicitly {@link Trace.QueryPlanNode.DeferredNodeDepends.verify|verify} messages.\n             * @function encode\n             * @memberof Trace.QueryPlanNode.DeferredNodeDepends\n             * @static\n             * @param {Trace.QueryPlanNode.IDeferredNodeDepends} message DeferredNodeDepends message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            DeferredNodeDepends.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.id != null && Object.hasOwnProperty.call(message, \"id\"))\n                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);\n                if (message.deferLabel != null && Object.hasOwnProperty.call(message, \"deferLabel\"))\n                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.deferLabel);\n                return writer;\n            };\n\n            /**\n             * Encodes the specified DeferredNodeDepends message, length delimited. Does not implicitly {@link Trace.QueryPlanNode.DeferredNodeDepends.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof Trace.QueryPlanNode.DeferredNodeDepends\n             * @static\n             * @param {Trace.QueryPlanNode.IDeferredNodeDepends} message DeferredNodeDepends message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            DeferredNodeDepends.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n\n            /**\n             * Decodes a DeferredNodeDepends message from the specified reader or buffer.\n             * @function decode\n             * @memberof Trace.QueryPlanNode.DeferredNodeDepends\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {Trace.QueryPlanNode.DeferredNodeDepends} DeferredNodeDepends\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            DeferredNodeDepends.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.DeferredNodeDepends();\n                while (reader.pos < end) {\n                    let tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.id = reader.string();\n                        break;\n                    case 2:\n                        message.deferLabel = reader.string();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n\n            /**\n             * Decodes a DeferredNodeDepends message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof Trace.QueryPlanNode.DeferredNodeDepends\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {Trace.QueryPlanNode.DeferredNodeDepends} DeferredNodeDepends\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            DeferredNodeDepends.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n\n            /**\n             * Verifies a DeferredNodeDepends message.\n             * @function verify\n             * @memberof Trace.QueryPlanNode.DeferredNodeDepends\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            DeferredNodeDepends.verify = function verify(message) {\n                if (typeof message !== \"object\" || message === null)\n                    return \"object expected\";\n                if (message.id != null && message.hasOwnProperty(\"id\"))\n                    if (!$util.isString(message.id))\n                        return \"id: string expected\";\n                if (message.deferLabel != null && message.hasOwnProperty(\"deferLabel\"))\n                    if (!$util.isString(message.deferLabel))\n                        return \"deferLabel: string expected\";\n                return null;\n            };\n\n            /**\n             * Creates a plain object from a DeferredNodeDepends message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof Trace.QueryPlanNode.DeferredNodeDepends\n             * @static\n             * @param {Trace.QueryPlanNode.DeferredNodeDepends} message DeferredNodeDepends\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            DeferredNodeDepends.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                let object = {};\n                if (options.defaults) {\n                    object.id = \"\";\n                    object.deferLabel = \"\";\n                }\n                if (message.id != null && message.hasOwnProperty(\"id\"))\n                    object.id = message.id;\n                if (message.deferLabel != null && message.hasOwnProperty(\"deferLabel\"))\n                    object.deferLabel = message.deferLabel;\n                return object;\n            };\n\n            /**\n             * Converts this DeferredNodeDepends to JSON.\n             * @function toJSON\n             * @memberof Trace.QueryPlanNode.DeferredNodeDepends\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            DeferredNodeDepends.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return DeferredNodeDepends;\n        })();\n\n        QueryPlanNode.ResponsePathElement = (function() {\n\n            /**\n             * Properties of a ResponsePathElement.\n             * @memberof Trace.QueryPlanNode\n             * @interface IResponsePathElement\n             * @property {string|null} [fieldName] ResponsePathElement fieldName\n             * @property {number|null} [index] ResponsePathElement index\n             */\n\n            /**\n             * Constructs a new ResponsePathElement.\n             * @memberof Trace.QueryPlanNode\n             * @classdesc Represents a ResponsePathElement.\n             * @implements IResponsePathElement\n             * @constructor\n             * @param {Trace.QueryPlanNode.IResponsePathElement=} [properties] Properties to set\n             */\n            function ResponsePathElement(properties) {\n                if (properties)\n                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n\n            /**\n             * ResponsePathElement fieldName.\n             * @member {string} fieldName\n             * @memberof Trace.QueryPlanNode.ResponsePathElement\n             * @instance\n             */\n            ResponsePathElement.prototype.fieldName = \"\";\n\n            /**\n             * ResponsePathElement index.\n             * @member {number} index\n             * @memberof Trace.QueryPlanNode.ResponsePathElement\n             * @instance\n             */\n            ResponsePathElement.prototype.index = 0;\n\n            // OneOf field names bound to virtual getters and setters\n            let $oneOfFields;\n\n            /**\n             * ResponsePathElement id.\n             * @member {\"fieldName\"|\"index\"|undefined} id\n             * @memberof Trace.QueryPlanNode.ResponsePathElement\n             * @instance\n             */\n            Object.defineProperty(ResponsePathElement.prototype, \"id\", {\n                get: $util.oneOfGetter($oneOfFields = [\"fieldName\", \"index\"]),\n                set: $util.oneOfSetter($oneOfFields)\n            });\n\n            /**\n             * Creates a new ResponsePathElement instance using the specified properties.\n             * @function create\n             * @memberof Trace.QueryPlanNode.ResponsePathElement\n             * @static\n             * @param {Trace.QueryPlanNode.IResponsePathElement=} [properties] Properties to set\n             * @returns {Trace.QueryPlanNode.ResponsePathElement} ResponsePathElement instance\n             */\n            ResponsePathElement.create = function create(properties) {\n                return new ResponsePathElement(properties);\n            };\n\n            /**\n             * Encodes the specified ResponsePathElement message. Does not implicitly {@link Trace.QueryPlanNode.ResponsePathElement.verify|verify} messages.\n             * @function encode\n             * @memberof Trace.QueryPlanNode.ResponsePathElement\n             * @static\n             * @param {Trace.QueryPlanNode.IResponsePathElement} message ResponsePathElement message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            ResponsePathElement.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.fieldName != null && Object.hasOwnProperty.call(message, \"fieldName\"))\n                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.fieldName);\n                if (message.index != null && Object.hasOwnProperty.call(message, \"index\"))\n                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.index);\n                return writer;\n            };\n\n            /**\n             * Encodes the specified ResponsePathElement message, length delimited. Does not implicitly {@link Trace.QueryPlanNode.ResponsePathElement.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof Trace.QueryPlanNode.ResponsePathElement\n             * @static\n             * @param {Trace.QueryPlanNode.IResponsePathElement} message ResponsePathElement message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            ResponsePathElement.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n\n            /**\n             * Decodes a ResponsePathElement message from the specified reader or buffer.\n             * @function decode\n             * @memberof Trace.QueryPlanNode.ResponsePathElement\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {Trace.QueryPlanNode.ResponsePathElement} ResponsePathElement\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            ResponsePathElement.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.ResponsePathElement();\n                while (reader.pos < end) {\n                    let tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.fieldName = reader.string();\n                        break;\n                    case 2:\n                        message.index = reader.uint32();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n\n            /**\n             * Decodes a ResponsePathElement message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof Trace.QueryPlanNode.ResponsePathElement\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {Trace.QueryPlanNode.ResponsePathElement} ResponsePathElement\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            ResponsePathElement.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n\n            /**\n             * Verifies a ResponsePathElement message.\n             * @function verify\n             * @memberof Trace.QueryPlanNode.ResponsePathElement\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            ResponsePathElement.verify = function verify(message) {\n                if (typeof message !== \"object\" || message === null)\n                    return \"object expected\";\n                let properties = {};\n                if (message.fieldName != null && message.hasOwnProperty(\"fieldName\")) {\n                    properties.id = 1;\n                    if (!$util.isString(message.fieldName))\n                        return \"fieldName: string expected\";\n                }\n                if (message.index != null && message.hasOwnProperty(\"index\")) {\n                    if (properties.id === 1)\n                        return \"id: multiple values\";\n                    properties.id = 1;\n                    if (!$util.isInteger(message.index))\n                        return \"index: integer expected\";\n                }\n                return null;\n            };\n\n            /**\n             * Creates a plain object from a ResponsePathElement message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof Trace.QueryPlanNode.ResponsePathElement\n             * @static\n             * @param {Trace.QueryPlanNode.ResponsePathElement} message ResponsePathElement\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            ResponsePathElement.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                let object = {};\n                if (message.fieldName != null && message.hasOwnProperty(\"fieldName\")) {\n                    object.fieldName = message.fieldName;\n                    if (options.oneofs)\n                        object.id = \"fieldName\";\n                }\n                if (message.index != null && message.hasOwnProperty(\"index\")) {\n                    object.index = message.index;\n                    if (options.oneofs)\n                        object.id = \"index\";\n                }\n                return object;\n            };\n\n            /**\n             * Converts this ResponsePathElement to JSON.\n             * @function toJSON\n             * @memberof Trace.QueryPlanNode.ResponsePathElement\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            ResponsePathElement.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return ResponsePathElement;\n        })();\n\n        return QueryPlanNode;\n    })();\n\n    return Trace;\n})();\n\nexport const ReportHeader = $root.ReportHeader = (() => {\n\n    /**\n     * Properties of a ReportHeader.\n     * @exports IReportHeader\n     * @interface IReportHeader\n     * @property {string|null} [graphRef] ReportHeader graphRef\n     * @property {string|null} [hostname] ReportHeader hostname\n     * @property {string|null} [agentVersion] ReportHeader agentVersion\n     * @property {string|null} [serviceVersion] ReportHeader serviceVersion\n     * @property {string|null} [runtimeVersion] ReportHeader runtimeVersion\n     * @property {string|null} [uname] ReportHeader uname\n     * @property {string|null} [executableSchemaId] ReportHeader executableSchemaId\n     */\n\n    /**\n     * Constructs a new ReportHeader.\n     * @exports ReportHeader\n     * @classdesc Represents a ReportHeader.\n     * @implements IReportHeader\n     * @constructor\n     * @param {IReportHeader=} [properties] Properties to set\n     */\n    function ReportHeader(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * ReportHeader graphRef.\n     * @member {string} graphRef\n     * @memberof ReportHeader\n     * @instance\n     */\n    ReportHeader.prototype.graphRef = \"\";\n\n    /**\n     * ReportHeader hostname.\n     * @member {string} hostname\n     * @memberof ReportHeader\n     * @instance\n     */\n    ReportHeader.prototype.hostname = \"\";\n\n    /**\n     * ReportHeader agentVersion.\n     * @member {string} agentVersion\n     * @memberof ReportHeader\n     * @instance\n     */\n    ReportHeader.prototype.agentVersion = \"\";\n\n    /**\n     * ReportHeader serviceVersion.\n     * @member {string} serviceVersion\n     * @memberof ReportHeader\n     * @instance\n     */\n    ReportHeader.prototype.serviceVersion = \"\";\n\n    /**\n     * ReportHeader runtimeVersion.\n     * @member {string} runtimeVersion\n     * @memberof ReportHeader\n     * @instance\n     */\n    ReportHeader.prototype.runtimeVersion = \"\";\n\n    /**\n     * ReportHeader uname.\n     * @member {string} uname\n     * @memberof ReportHeader\n     * @instance\n     */\n    ReportHeader.prototype.uname = \"\";\n\n    /**\n     * ReportHeader executableSchemaId.\n     * @member {string} executableSchemaId\n     * @memberof ReportHeader\n     * @instance\n     */\n    ReportHeader.prototype.executableSchemaId = \"\";\n\n    /**\n     * Creates a new ReportHeader instance using the specified properties.\n     * @function create\n     * @memberof ReportHeader\n     * @static\n     * @param {IReportHeader=} [properties] Properties to set\n     * @returns {ReportHeader} ReportHeader instance\n     */\n    ReportHeader.create = function create(properties) {\n        return new ReportHeader(properties);\n    };\n\n    /**\n     * Encodes the specified ReportHeader message. Does not implicitly {@link ReportHeader.verify|verify} messages.\n     * @function encode\n     * @memberof ReportHeader\n     * @static\n     * @param {IReportHeader} message ReportHeader message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    ReportHeader.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.hostname != null && Object.hasOwnProperty.call(message, \"hostname\"))\n            writer.uint32(/* id 5, wireType 2 =*/42).string(message.hostname);\n        if (message.agentVersion != null && Object.hasOwnProperty.call(message, \"agentVersion\"))\n            writer.uint32(/* id 6, wireType 2 =*/50).string(message.agentVersion);\n        if (message.serviceVersion != null && Object.hasOwnProperty.call(message, \"serviceVersion\"))\n            writer.uint32(/* id 7, wireType 2 =*/58).string(message.serviceVersion);\n        if (message.runtimeVersion != null && Object.hasOwnProperty.call(message, \"runtimeVersion\"))\n            writer.uint32(/* id 8, wireType 2 =*/66).string(message.runtimeVersion);\n        if (message.uname != null && Object.hasOwnProperty.call(message, \"uname\"))\n            writer.uint32(/* id 9, wireType 2 =*/74).string(message.uname);\n        if (message.executableSchemaId != null && Object.hasOwnProperty.call(message, \"executableSchemaId\"))\n            writer.uint32(/* id 11, wireType 2 =*/90).string(message.executableSchemaId);\n        if (message.graphRef != null && Object.hasOwnProperty.call(message, \"graphRef\"))\n            writer.uint32(/* id 12, wireType 2 =*/98).string(message.graphRef);\n        return writer;\n    };\n\n    /**\n     * Encodes the specified ReportHeader message, length delimited. Does not implicitly {@link ReportHeader.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof ReportHeader\n     * @static\n     * @param {IReportHeader} message ReportHeader message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    ReportHeader.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a ReportHeader message from the specified reader or buffer.\n     * @function decode\n     * @memberof ReportHeader\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {ReportHeader} ReportHeader\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    ReportHeader.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ReportHeader();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 12:\n                message.graphRef = reader.string();\n                break;\n            case 5:\n                message.hostname = reader.string();\n                break;\n            case 6:\n                message.agentVersion = reader.string();\n                break;\n            case 7:\n                message.serviceVersion = reader.string();\n                break;\n            case 8:\n                message.runtimeVersion = reader.string();\n                break;\n            case 9:\n                message.uname = reader.string();\n                break;\n            case 11:\n                message.executableSchemaId = reader.string();\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a ReportHeader message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof ReportHeader\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {ReportHeader} ReportHeader\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    ReportHeader.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a ReportHeader message.\n     * @function verify\n     * @memberof ReportHeader\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    ReportHeader.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.graphRef != null && message.hasOwnProperty(\"graphRef\"))\n            if (!$util.isString(message.graphRef))\n                return \"graphRef: string expected\";\n        if (message.hostname != null && message.hasOwnProperty(\"hostname\"))\n            if (!$util.isString(message.hostname))\n                return \"hostname: string expected\";\n        if (message.agentVersion != null && message.hasOwnProperty(\"agentVersion\"))\n            if (!$util.isString(message.agentVersion))\n                return \"agentVersion: string expected\";\n        if (message.serviceVersion != null && message.hasOwnProperty(\"serviceVersion\"))\n            if (!$util.isString(message.serviceVersion))\n                return \"serviceVersion: string expected\";\n        if (message.runtimeVersion != null && message.hasOwnProperty(\"runtimeVersion\"))\n            if (!$util.isString(message.runtimeVersion))\n                return \"runtimeVersion: string expected\";\n        if (message.uname != null && message.hasOwnProperty(\"uname\"))\n            if (!$util.isString(message.uname))\n                return \"uname: string expected\";\n        if (message.executableSchemaId != null && message.hasOwnProperty(\"executableSchemaId\"))\n            if (!$util.isString(message.executableSchemaId))\n                return \"executableSchemaId: string expected\";\n        return null;\n    };\n\n    /**\n     * Creates a plain object from a ReportHeader message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof ReportHeader\n     * @static\n     * @param {ReportHeader} message ReportHeader\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    ReportHeader.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.defaults) {\n            object.hostname = \"\";\n            object.agentVersion = \"\";\n            object.serviceVersion = \"\";\n            object.runtimeVersion = \"\";\n            object.uname = \"\";\n            object.executableSchemaId = \"\";\n            object.graphRef = \"\";\n        }\n        if (message.hostname != null && message.hasOwnProperty(\"hostname\"))\n            object.hostname = message.hostname;\n        if (message.agentVersion != null && message.hasOwnProperty(\"agentVersion\"))\n            object.agentVersion = message.agentVersion;\n        if (message.serviceVersion != null && message.hasOwnProperty(\"serviceVersion\"))\n            object.serviceVersion = message.serviceVersion;\n        if (message.runtimeVersion != null && message.hasOwnProperty(\"runtimeVersion\"))\n            object.runtimeVersion = message.runtimeVersion;\n        if (message.uname != null && message.hasOwnProperty(\"uname\"))\n            object.uname = message.uname;\n        if (message.executableSchemaId != null && message.hasOwnProperty(\"executableSchemaId\"))\n            object.executableSchemaId = message.executableSchemaId;\n        if (message.graphRef != null && message.hasOwnProperty(\"graphRef\"))\n            object.graphRef = message.graphRef;\n        return object;\n    };\n\n    /**\n     * Converts this ReportHeader to JSON.\n     * @function toJSON\n     * @memberof ReportHeader\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    ReportHeader.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return ReportHeader;\n})();\n\nexport const PathErrorStats = $root.PathErrorStats = (() => {\n\n    /**\n     * Properties of a PathErrorStats.\n     * @exports IPathErrorStats\n     * @interface IPathErrorStats\n     * @property {Object.<string,IPathErrorStats>|null} [children] PathErrorStats children\n     * @property {number|null} [errorsCount] PathErrorStats errorsCount\n     * @property {number|null} [requestsWithErrorsCount] PathErrorStats requestsWithErrorsCount\n     */\n\n    /**\n     * Constructs a new PathErrorStats.\n     * @exports PathErrorStats\n     * @classdesc Represents a PathErrorStats.\n     * @implements IPathErrorStats\n     * @constructor\n     * @param {IPathErrorStats=} [properties] Properties to set\n     */\n    function PathErrorStats(properties) {\n        this.children = {};\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * PathErrorStats children.\n     * @member {Object.<string,IPathErrorStats>} children\n     * @memberof PathErrorStats\n     * @instance\n     */\n    PathErrorStats.prototype.children = $util.emptyObject;\n\n    /**\n     * PathErrorStats errorsCount.\n     * @member {number} errorsCount\n     * @memberof PathErrorStats\n     * @instance\n     */\n    PathErrorStats.prototype.errorsCount = 0;\n\n    /**\n     * PathErrorStats requestsWithErrorsCount.\n     * @member {number} requestsWithErrorsCount\n     * @memberof PathErrorStats\n     * @instance\n     */\n    PathErrorStats.prototype.requestsWithErrorsCount = 0;\n\n    /**\n     * Creates a new PathErrorStats instance using the specified properties.\n     * @function create\n     * @memberof PathErrorStats\n     * @static\n     * @param {IPathErrorStats=} [properties] Properties to set\n     * @returns {PathErrorStats} PathErrorStats instance\n     */\n    PathErrorStats.create = function create(properties) {\n        return new PathErrorStats(properties);\n    };\n\n    /**\n     * Encodes the specified PathErrorStats message. Does not implicitly {@link PathErrorStats.verify|verify} messages.\n     * @function encode\n     * @memberof PathErrorStats\n     * @static\n     * @param {IPathErrorStats} message PathErrorStats message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    PathErrorStats.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.children != null && Object.hasOwnProperty.call(message, \"children\"))\n            for (let keys = Object.keys(message.children), i = 0; i < keys.length; ++i) {\n                writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);\n                $root.PathErrorStats.encode(message.children[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();\n            }\n        if (message.errorsCount != null && Object.hasOwnProperty.call(message, \"errorsCount\"))\n            writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.errorsCount);\n        if (message.requestsWithErrorsCount != null && Object.hasOwnProperty.call(message, \"requestsWithErrorsCount\"))\n            writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.requestsWithErrorsCount);\n        return writer;\n    };\n\n    /**\n     * Encodes the specified PathErrorStats message, length delimited. Does not implicitly {@link PathErrorStats.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof PathErrorStats\n     * @static\n     * @param {IPathErrorStats} message PathErrorStats message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    PathErrorStats.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a PathErrorStats message from the specified reader or buffer.\n     * @function decode\n     * @memberof PathErrorStats\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {PathErrorStats} PathErrorStats\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    PathErrorStats.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PathErrorStats(), key;\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                reader.skip().pos++;\n                if (message.children === $util.emptyObject)\n                    message.children = {};\n                key = reader.string();\n                reader.pos++;\n                message.children[key] = $root.PathErrorStats.decode(reader, reader.uint32());\n                break;\n            case 4:\n                message.errorsCount = reader.uint64();\n                break;\n            case 5:\n                message.requestsWithErrorsCount = reader.uint64();\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a PathErrorStats message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof PathErrorStats\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {PathErrorStats} PathErrorStats\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    PathErrorStats.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a PathErrorStats message.\n     * @function verify\n     * @memberof PathErrorStats\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    PathErrorStats.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.children != null && message.hasOwnProperty(\"children\")) {\n            if (!$util.isObject(message.children))\n                return \"children: object expected\";\n            let key = Object.keys(message.children);\n            for (let i = 0; i < key.length; ++i) {\n                let error = $root.PathErrorStats.verify(message.children[key[i]]);\n                if (error)\n                    return \"children.\" + error;\n            }\n        }\n        if (message.errorsCount != null && message.hasOwnProperty(\"errorsCount\"))\n            if (!$util.isInteger(message.errorsCount) && !(message.errorsCount && $util.isInteger(message.errorsCount.low) && $util.isInteger(message.errorsCount.high)))\n                return \"errorsCount: integer|Long expected\";\n        if (message.requestsWithErrorsCount != null && message.hasOwnProperty(\"requestsWithErrorsCount\"))\n            if (!$util.isInteger(message.requestsWithErrorsCount) && !(message.requestsWithErrorsCount && $util.isInteger(message.requestsWithErrorsCount.low) && $util.isInteger(message.requestsWithErrorsCount.high)))\n                return \"requestsWithErrorsCount: integer|Long expected\";\n        return null;\n    };\n\n    /**\n     * Creates a plain object from a PathErrorStats message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof PathErrorStats\n     * @static\n     * @param {PathErrorStats} message PathErrorStats\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    PathErrorStats.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.objects || options.defaults)\n            object.children = {};\n        if (options.defaults) {\n            object.errorsCount = 0;\n            object.requestsWithErrorsCount = 0;\n        }\n        let keys2;\n        if (message.children && (keys2 = Object.keys(message.children)).length) {\n            object.children = {};\n            for (let j = 0; j < keys2.length; ++j)\n                object.children[keys2[j]] = $root.PathErrorStats.toObject(message.children[keys2[j]], options);\n        }\n        if (message.errorsCount != null && message.hasOwnProperty(\"errorsCount\"))\n            if (typeof message.errorsCount === \"number\")\n                object.errorsCount = options.longs === String ? String(message.errorsCount) : message.errorsCount;\n            else\n                object.errorsCount = options.longs === String ? $util.Long.prototype.toString.call(message.errorsCount) : options.longs === Number ? new $util.LongBits(message.errorsCount.low >>> 0, message.errorsCount.high >>> 0).toNumber(true) : message.errorsCount;\n        if (message.requestsWithErrorsCount != null && message.hasOwnProperty(\"requestsWithErrorsCount\"))\n            if (typeof message.requestsWithErrorsCount === \"number\")\n                object.requestsWithErrorsCount = options.longs === String ? String(message.requestsWithErrorsCount) : message.requestsWithErrorsCount;\n            else\n                object.requestsWithErrorsCount = options.longs === String ? $util.Long.prototype.toString.call(message.requestsWithErrorsCount) : options.longs === Number ? new $util.LongBits(message.requestsWithErrorsCount.low >>> 0, message.requestsWithErrorsCount.high >>> 0).toNumber(true) : message.requestsWithErrorsCount;\n        return object;\n    };\n\n    /**\n     * Converts this PathErrorStats to JSON.\n     * @function toJSON\n     * @memberof PathErrorStats\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    PathErrorStats.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return PathErrorStats;\n})();\n\nexport const QueryLatencyStats = $root.QueryLatencyStats = (() => {\n\n    /**\n     * Properties of a QueryLatencyStats.\n     * @exports IQueryLatencyStats\n     * @interface IQueryLatencyStats\n     * @property {$protobuf.ToArray.<number>|Array.<number>|null} [latencyCount] QueryLatencyStats latencyCount\n     * @property {number|null} [requestCount] QueryLatencyStats requestCount\n     * @property {number|null} [cacheHits] QueryLatencyStats cacheHits\n     * @property {number|null} [persistedQueryHits] QueryLatencyStats persistedQueryHits\n     * @property {number|null} [persistedQueryMisses] QueryLatencyStats persistedQueryMisses\n     * @property {$protobuf.ToArray.<number>|Array.<number>|null} [cacheLatencyCount] QueryLatencyStats cacheLatencyCount\n     * @property {IPathErrorStats|null} [rootErrorStats] QueryLatencyStats rootErrorStats\n     * @property {number|null} [requestsWithErrorsCount] QueryLatencyStats requestsWithErrorsCount\n     * @property {$protobuf.ToArray.<number>|Array.<number>|null} [publicCacheTtlCount] QueryLatencyStats publicCacheTtlCount\n     * @property {$protobuf.ToArray.<number>|Array.<number>|null} [privateCacheTtlCount] QueryLatencyStats privateCacheTtlCount\n     * @property {number|null} [registeredOperationCount] QueryLatencyStats registeredOperationCount\n     * @property {number|null} [forbiddenOperationCount] QueryLatencyStats forbiddenOperationCount\n     * @property {number|null} [requestsWithoutFieldInstrumentation] QueryLatencyStats requestsWithoutFieldInstrumentation\n     */\n\n    /**\n     * Constructs a new QueryLatencyStats.\n     * @exports QueryLatencyStats\n     * @classdesc Represents a QueryLatencyStats.\n     * @implements IQueryLatencyStats\n     * @constructor\n     * @param {IQueryLatencyStats=} [properties] Properties to set\n     */\n    function QueryLatencyStats(properties) {\n        this.latencyCount = [];\n        this.cacheLatencyCount = [];\n        this.publicCacheTtlCount = [];\n        this.privateCacheTtlCount = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * QueryLatencyStats latencyCount.\n     * @member {Array.<number>} latencyCount\n     * @memberof QueryLatencyStats\n     * @instance\n     */\n    QueryLatencyStats.prototype.latencyCount = $util.emptyArray;\n\n    /**\n     * QueryLatencyStats requestCount.\n     * @member {number} requestCount\n     * @memberof QueryLatencyStats\n     * @instance\n     */\n    QueryLatencyStats.prototype.requestCount = 0;\n\n    /**\n     * QueryLatencyStats cacheHits.\n     * @member {number} cacheHits\n     * @memberof QueryLatencyStats\n     * @instance\n     */\n    QueryLatencyStats.prototype.cacheHits = 0;\n\n    /**\n     * QueryLatencyStats persistedQueryHits.\n     * @member {number} persistedQueryHits\n     * @memberof QueryLatencyStats\n     * @instance\n     */\n    QueryLatencyStats.prototype.persistedQueryHits = 0;\n\n    /**\n     * QueryLatencyStats persistedQueryMisses.\n     * @member {number} persistedQueryMisses\n     * @memberof QueryLatencyStats\n     * @instance\n     */\n    QueryLatencyStats.prototype.persistedQueryMisses = 0;\n\n    /**\n     * QueryLatencyStats cacheLatencyCount.\n     * @member {Array.<number>} cacheLatencyCount\n     * @memberof QueryLatencyStats\n     * @instance\n     */\n    QueryLatencyStats.prototype.cacheLatencyCount = $util.emptyArray;\n\n    /**\n     * QueryLatencyStats rootErrorStats.\n     * @member {IPathErrorStats|null|undefined} rootErrorStats\n     * @memberof QueryLatencyStats\n     * @instance\n     */\n    QueryLatencyStats.prototype.rootErrorStats = null;\n\n    /**\n     * QueryLatencyStats requestsWithErrorsCount.\n     * @member {number} requestsWithErrorsCount\n     * @memberof QueryLatencyStats\n     * @instance\n     */\n    QueryLatencyStats.prototype.requestsWithErrorsCount = 0;\n\n    /**\n     * QueryLatencyStats publicCacheTtlCount.\n     * @member {Array.<number>} publicCacheTtlCount\n     * @memberof QueryLatencyStats\n     * @instance\n     */\n    QueryLatencyStats.prototype.publicCacheTtlCount = $util.emptyArray;\n\n    /**\n     * QueryLatencyStats privateCacheTtlCount.\n     * @member {Array.<number>} privateCacheTtlCount\n     * @memberof QueryLatencyStats\n     * @instance\n     */\n    QueryLatencyStats.prototype.privateCacheTtlCount = $util.emptyArray;\n\n    /**\n     * QueryLatencyStats registeredOperationCount.\n     * @member {number} registeredOperationCount\n     * @memberof QueryLatencyStats\n     * @instance\n     */\n    QueryLatencyStats.prototype.registeredOperationCount = 0;\n\n    /**\n     * QueryLatencyStats forbiddenOperationCount.\n     * @member {number} forbiddenOperationCount\n     * @memberof QueryLatencyStats\n     * @instance\n     */\n    QueryLatencyStats.prototype.forbiddenOperationCount = 0;\n\n    /**\n     * QueryLatencyStats requestsWithoutFieldInstrumentation.\n     * @member {number} requestsWithoutFieldInstrumentation\n     * @memberof QueryLatencyStats\n     * @instance\n     */\n    QueryLatencyStats.prototype.requestsWithoutFieldInstrumentation = 0;\n\n    /**\n     * Creates a new QueryLatencyStats instance using the specified properties.\n     * @function create\n     * @memberof QueryLatencyStats\n     * @static\n     * @param {IQueryLatencyStats=} [properties] Properties to set\n     * @returns {QueryLatencyStats} QueryLatencyStats instance\n     */\n    QueryLatencyStats.create = function create(properties) {\n        return new QueryLatencyStats(properties);\n    };\n\n    /**\n     * Encodes the specified QueryLatencyStats message. Does not implicitly {@link QueryLatencyStats.verify|verify} messages.\n     * @function encode\n     * @memberof QueryLatencyStats\n     * @static\n     * @param {IQueryLatencyStats} message QueryLatencyStats message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    QueryLatencyStats.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.requestCount != null && Object.hasOwnProperty.call(message, \"requestCount\"))\n            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.requestCount);\n        if (message.cacheHits != null && Object.hasOwnProperty.call(message, \"cacheHits\"))\n            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.cacheHits);\n        if (message.persistedQueryHits != null && Object.hasOwnProperty.call(message, \"persistedQueryHits\"))\n            writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.persistedQueryHits);\n        if (message.persistedQueryMisses != null && Object.hasOwnProperty.call(message, \"persistedQueryMisses\"))\n            writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.persistedQueryMisses);\n        if (message.rootErrorStats != null && Object.hasOwnProperty.call(message, \"rootErrorStats\"))\n            $root.PathErrorStats.encode(message.rootErrorStats, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();\n        if (message.requestsWithErrorsCount != null && Object.hasOwnProperty.call(message, \"requestsWithErrorsCount\"))\n            writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.requestsWithErrorsCount);\n        if (message.registeredOperationCount != null && Object.hasOwnProperty.call(message, \"registeredOperationCount\"))\n            writer.uint32(/* id 11, wireType 0 =*/88).uint64(message.registeredOperationCount);\n        if (message.forbiddenOperationCount != null && Object.hasOwnProperty.call(message, \"forbiddenOperationCount\"))\n            writer.uint32(/* id 12, wireType 0 =*/96).uint64(message.forbiddenOperationCount);\n        let array13;\n        if (message.latencyCount != null && message.latencyCount.toArray)\n            array13 = message.latencyCount.toArray();\n        else\n            array13 = message.latencyCount;\n        if (array13 != null && array13.length) {\n            writer.uint32(/* id 13, wireType 2 =*/106).fork();\n            for (let i = 0; i < array13.length; ++i)\n                writer.sint64(array13[i]);\n            writer.ldelim();\n        }\n        let array14;\n        if (message.cacheLatencyCount != null && message.cacheLatencyCount.toArray)\n            array14 = message.cacheLatencyCount.toArray();\n        else\n            array14 = message.cacheLatencyCount;\n        if (array14 != null && array14.length) {\n            writer.uint32(/* id 14, wireType 2 =*/114).fork();\n            for (let i = 0; i < array14.length; ++i)\n                writer.sint64(array14[i]);\n            writer.ldelim();\n        }\n        let array15;\n        if (message.publicCacheTtlCount != null && message.publicCacheTtlCount.toArray)\n            array15 = message.publicCacheTtlCount.toArray();\n        else\n            array15 = message.publicCacheTtlCount;\n        if (array15 != null && array15.length) {\n            writer.uint32(/* id 15, wireType 2 =*/122).fork();\n            for (let i = 0; i < array15.length; ++i)\n                writer.sint64(array15[i]);\n            writer.ldelim();\n        }\n        let array16;\n        if (message.privateCacheTtlCount != null && message.privateCacheTtlCount.toArray)\n            array16 = message.privateCacheTtlCount.toArray();\n        else\n            array16 = message.privateCacheTtlCount;\n        if (array16 != null && array16.length) {\n            writer.uint32(/* id 16, wireType 2 =*/130).fork();\n            for (let i = 0; i < array16.length; ++i)\n                writer.sint64(array16[i]);\n            writer.ldelim();\n        }\n        if (message.requestsWithoutFieldInstrumentation != null && Object.hasOwnProperty.call(message, \"requestsWithoutFieldInstrumentation\"))\n            writer.uint32(/* id 17, wireType 0 =*/136).uint64(message.requestsWithoutFieldInstrumentation);\n        return writer;\n    };\n\n    /**\n     * Encodes the specified QueryLatencyStats message, length delimited. Does not implicitly {@link QueryLatencyStats.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof QueryLatencyStats\n     * @static\n     * @param {IQueryLatencyStats} message QueryLatencyStats message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    QueryLatencyStats.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a QueryLatencyStats message from the specified reader or buffer.\n     * @function decode\n     * @memberof QueryLatencyStats\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {QueryLatencyStats} QueryLatencyStats\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    QueryLatencyStats.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.QueryLatencyStats();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 13:\n                if (!(message.latencyCount && message.latencyCount.length))\n                    message.latencyCount = [];\n                if ((tag & 7) === 2) {\n                    let end2 = reader.uint32() + reader.pos;\n                    while (reader.pos < end2)\n                        message.latencyCount.push(reader.sint64());\n                } else\n                    message.latencyCount.push(reader.sint64());\n                break;\n            case 2:\n                message.requestCount = reader.uint64();\n                break;\n            case 3:\n                message.cacheHits = reader.uint64();\n                break;\n            case 4:\n                message.persistedQueryHits = reader.uint64();\n                break;\n            case 5:\n                message.persistedQueryMisses = reader.uint64();\n                break;\n            case 14:\n                if (!(message.cacheLatencyCount && message.cacheLatencyCount.length))\n                    message.cacheLatencyCount = [];\n                if ((tag & 7) === 2) {\n                    let end2 = reader.uint32() + reader.pos;\n                    while (reader.pos < end2)\n                        message.cacheLatencyCount.push(reader.sint64());\n                } else\n                    message.cacheLatencyCount.push(reader.sint64());\n                break;\n            case 7:\n                message.rootErrorStats = $root.PathErrorStats.decode(reader, reader.uint32());\n                break;\n            case 8:\n                message.requestsWithErrorsCount = reader.uint64();\n                break;\n            case 15:\n                if (!(message.publicCacheTtlCount && message.publicCacheTtlCount.length))\n                    message.publicCacheTtlCount = [];\n                if ((tag & 7) === 2) {\n                    let end2 = reader.uint32() + reader.pos;\n                    while (reader.pos < end2)\n                        message.publicCacheTtlCount.push(reader.sint64());\n                } else\n                    message.publicCacheTtlCount.push(reader.sint64());\n                break;\n            case 16:\n                if (!(message.privateCacheTtlCount && message.privateCacheTtlCount.length))\n                    message.privateCacheTtlCount = [];\n                if ((tag & 7) === 2) {\n                    let end2 = reader.uint32() + reader.pos;\n                    while (reader.pos < end2)\n                        message.privateCacheTtlCount.push(reader.sint64());\n                } else\n                    message.privateCacheTtlCount.push(reader.sint64());\n                break;\n            case 11:\n                message.registeredOperationCount = reader.uint64();\n                break;\n            case 12:\n                message.forbiddenOperationCount = reader.uint64();\n                break;\n            case 17:\n                message.requestsWithoutFieldInstrumentation = reader.uint64();\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a QueryLatencyStats message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof QueryLatencyStats\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {QueryLatencyStats} QueryLatencyStats\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    QueryLatencyStats.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a QueryLatencyStats message.\n     * @function verify\n     * @memberof QueryLatencyStats\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    QueryLatencyStats.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.latencyCount != null && message.hasOwnProperty(\"latencyCount\")) {\n            let array13;\n            if (message.latencyCount != null && message.latencyCount.toArray)\n                array13 = message.latencyCount.toArray();\n            else\n                array13 = message.latencyCount;\n            if (!Array.isArray(array13))\n                return \"latencyCount: array expected\";\n            for (let i = 0; i < array13.length; ++i)\n                if (!$util.isInteger(array13[i]) && !(array13[i] && $util.isInteger(array13[i].low) && $util.isInteger(array13[i].high)))\n                    return \"latencyCount: integer|Long[] expected\";\n        }\n        if (message.requestCount != null && message.hasOwnProperty(\"requestCount\"))\n            if (!$util.isInteger(message.requestCount) && !(message.requestCount && $util.isInteger(message.requestCount.low) && $util.isInteger(message.requestCount.high)))\n                return \"requestCount: integer|Long expected\";\n        if (message.cacheHits != null && message.hasOwnProperty(\"cacheHits\"))\n            if (!$util.isInteger(message.cacheHits) && !(message.cacheHits && $util.isInteger(message.cacheHits.low) && $util.isInteger(message.cacheHits.high)))\n                return \"cacheHits: integer|Long expected\";\n        if (message.persistedQueryHits != null && message.hasOwnProperty(\"persistedQueryHits\"))\n            if (!$util.isInteger(message.persistedQueryHits) && !(message.persistedQueryHits && $util.isInteger(message.persistedQueryHits.low) && $util.isInteger(message.persistedQueryHits.high)))\n                return \"persistedQueryHits: integer|Long expected\";\n        if (message.persistedQueryMisses != null && message.hasOwnProperty(\"persistedQueryMisses\"))\n            if (!$util.isInteger(message.persistedQueryMisses) && !(message.persistedQueryMisses && $util.isInteger(message.persistedQueryMisses.low) && $util.isInteger(message.persistedQueryMisses.high)))\n                return \"persistedQueryMisses: integer|Long expected\";\n        if (message.cacheLatencyCount != null && message.hasOwnProperty(\"cacheLatencyCount\")) {\n            let array14;\n            if (message.cacheLatencyCount != null && message.cacheLatencyCount.toArray)\n                array14 = message.cacheLatencyCount.toArray();\n            else\n                array14 = message.cacheLatencyCount;\n            if (!Array.isArray(array14))\n                return \"cacheLatencyCount: array expected\";\n            for (let i = 0; i < array14.length; ++i)\n                if (!$util.isInteger(array14[i]) && !(array14[i] && $util.isInteger(array14[i].low) && $util.isInteger(array14[i].high)))\n                    return \"cacheLatencyCount: integer|Long[] expected\";\n        }\n        if (message.rootErrorStats != null && message.hasOwnProperty(\"rootErrorStats\")) {\n            let error = $root.PathErrorStats.verify(message.rootErrorStats);\n            if (error)\n                return \"rootErrorStats.\" + error;\n        }\n        if (message.requestsWithErrorsCount != null && message.hasOwnProperty(\"requestsWithErrorsCount\"))\n            if (!$util.isInteger(message.requestsWithErrorsCount) && !(message.requestsWithErrorsCount && $util.isInteger(message.requestsWithErrorsCount.low) && $util.isInteger(message.requestsWithErrorsCount.high)))\n                return \"requestsWithErrorsCount: integer|Long expected\";\n        if (message.publicCacheTtlCount != null && message.hasOwnProperty(\"publicCacheTtlCount\")) {\n            let array15;\n            if (message.publicCacheTtlCount != null && message.publicCacheTtlCount.toArray)\n                array15 = message.publicCacheTtlCount.toArray();\n            else\n                array15 = message.publicCacheTtlCount;\n            if (!Array.isArray(array15))\n                return \"publicCacheTtlCount: array expected\";\n            for (let i = 0; i < array15.length; ++i)\n                if (!$util.isInteger(array15[i]) && !(array15[i] && $util.isInteger(array15[i].low) && $util.isInteger(array15[i].high)))\n                    return \"publicCacheTtlCount: integer|Long[] expected\";\n        }\n        if (message.privateCacheTtlCount != null && message.hasOwnProperty(\"privateCacheTtlCount\")) {\n            let array16;\n            if (message.privateCacheTtlCount != null && message.privateCacheTtlCount.toArray)\n                array16 = message.privateCacheTtlCount.toArray();\n            else\n                array16 = message.privateCacheTtlCount;\n            if (!Array.isArray(array16))\n                return \"privateCacheTtlCount: array expected\";\n            for (let i = 0; i < array16.length; ++i)\n                if (!$util.isInteger(array16[i]) && !(array16[i] && $util.isInteger(array16[i].low) && $util.isInteger(array16[i].high)))\n                    return \"privateCacheTtlCount: integer|Long[] expected\";\n        }\n        if (message.registeredOperationCount != null && message.hasOwnProperty(\"registeredOperationCount\"))\n            if (!$util.isInteger(message.registeredOperationCount) && !(message.registeredOperationCount && $util.isInteger(message.registeredOperationCount.low) && $util.isInteger(message.registeredOperationCount.high)))\n                return \"registeredOperationCount: integer|Long expected\";\n        if (message.forbiddenOperationCount != null && message.hasOwnProperty(\"forbiddenOperationCount\"))\n            if (!$util.isInteger(message.forbiddenOperationCount) && !(message.forbiddenOperationCount && $util.isInteger(message.forbiddenOperationCount.low) && $util.isInteger(message.forbiddenOperationCount.high)))\n                return \"forbiddenOperationCount: integer|Long expected\";\n        if (message.requestsWithoutFieldInstrumentation != null && message.hasOwnProperty(\"requestsWithoutFieldInstrumentation\"))\n            if (!$util.isInteger(message.requestsWithoutFieldInstrumentation) && !(message.requestsWithoutFieldInstrumentation && $util.isInteger(message.requestsWithoutFieldInstrumentation.low) && $util.isInteger(message.requestsWithoutFieldInstrumentation.high)))\n                return \"requestsWithoutFieldInstrumentation: integer|Long expected\";\n        return null;\n    };\n\n    /**\n     * Creates a plain object from a QueryLatencyStats message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof QueryLatencyStats\n     * @static\n     * @param {QueryLatencyStats} message QueryLatencyStats\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    QueryLatencyStats.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.arrays || options.defaults) {\n            object.latencyCount = [];\n            object.cacheLatencyCount = [];\n            object.publicCacheTtlCount = [];\n            object.privateCacheTtlCount = [];\n        }\n        if (options.defaults) {\n            object.requestCount = 0;\n            object.cacheHits = 0;\n            object.persistedQueryHits = 0;\n            object.persistedQueryMisses = 0;\n            object.rootErrorStats = null;\n            object.requestsWithErrorsCount = 0;\n            object.registeredOperationCount = 0;\n            object.forbiddenOperationCount = 0;\n            object.requestsWithoutFieldInstrumentation = 0;\n        }\n        if (message.requestCount != null && message.hasOwnProperty(\"requestCount\"))\n            if (typeof message.requestCount === \"number\")\n                object.requestCount = options.longs === String ? String(message.requestCount) : message.requestCount;\n            else\n                object.requestCount = options.longs === String ? $util.Long.prototype.toString.call(message.requestCount) : options.longs === Number ? new $util.LongBits(message.requestCount.low >>> 0, message.requestCount.high >>> 0).toNumber(true) : message.requestCount;\n        if (message.cacheHits != null && message.hasOwnProperty(\"cacheHits\"))\n            if (typeof message.cacheHits === \"number\")\n                object.cacheHits = options.longs === String ? String(message.cacheHits) : message.cacheHits;\n            else\n                object.cacheHits = options.longs === String ? $util.Long.prototype.toString.call(message.cacheHits) : options.longs === Number ? new $util.LongBits(message.cacheHits.low >>> 0, message.cacheHits.high >>> 0).toNumber(true) : message.cacheHits;\n        if (message.persistedQueryHits != null && message.hasOwnProperty(\"persistedQueryHits\"))\n            if (typeof message.persistedQueryHits === \"number\")\n                object.persistedQueryHits = options.longs === String ? String(message.persistedQueryHits) : message.persistedQueryHits;\n            else\n                object.persistedQueryHits = options.longs === String ? $util.Long.prototype.toString.call(message.persistedQueryHits) : options.longs === Number ? new $util.LongBits(message.persistedQueryHits.low >>> 0, message.persistedQueryHits.high >>> 0).toNumber(true) : message.persistedQueryHits;\n        if (message.persistedQueryMisses != null && message.hasOwnProperty(\"persistedQueryMisses\"))\n            if (typeof message.persistedQueryMisses === \"number\")\n                object.persistedQueryMisses = options.longs === String ? String(message.persistedQueryMisses) : message.persistedQueryMisses;\n            else\n                object.persistedQueryMisses = options.longs === String ? $util.Long.prototype.toString.call(message.persistedQueryMisses) : options.longs === Number ? new $util.LongBits(message.persistedQueryMisses.low >>> 0, message.persistedQueryMisses.high >>> 0).toNumber(true) : message.persistedQueryMisses;\n        if (message.rootErrorStats != null && message.hasOwnProperty(\"rootErrorStats\"))\n            object.rootErrorStats = $root.PathErrorStats.toObject(message.rootErrorStats, options);\n        if (message.requestsWithErrorsCount != null && message.hasOwnProperty(\"requestsWithErrorsCount\"))\n            if (typeof message.requestsWithErrorsCount === \"number\")\n                object.requestsWithErrorsCount = options.longs === String ? String(message.requestsWithErrorsCount) : message.requestsWithErrorsCount;\n            else\n                object.requestsWithErrorsCount = options.longs === String ? $util.Long.prototype.toString.call(message.requestsWithErrorsCount) : options.longs === Number ? new $util.LongBits(message.requestsWithErrorsCount.low >>> 0, message.requestsWithErrorsCount.high >>> 0).toNumber(true) : message.requestsWithErrorsCount;\n        if (message.registeredOperationCount != null && message.hasOwnProperty(\"registeredOperationCount\"))\n            if (typeof message.registeredOperationCount === \"number\")\n                object.registeredOperationCount = options.longs === String ? String(message.registeredOperationCount) : message.registeredOperationCount;\n            else\n                object.registeredOperationCount = options.longs === String ? $util.Long.prototype.toString.call(message.registeredOperationCount) : options.longs === Number ? new $util.LongBits(message.registeredOperationCount.low >>> 0, message.registeredOperationCount.high >>> 0).toNumber(true) : message.registeredOperationCount;\n        if (message.forbiddenOperationCount != null && message.hasOwnProperty(\"forbiddenOperationCount\"))\n            if (typeof message.forbiddenOperationCount === \"number\")\n                object.forbiddenOperationCount = options.longs === String ? String(message.forbiddenOperationCount) : message.forbiddenOperationCount;\n            else\n                object.forbiddenOperationCount = options.longs === String ? $util.Long.prototype.toString.call(message.forbiddenOperationCount) : options.longs === Number ? new $util.LongBits(message.forbiddenOperationCount.low >>> 0, message.forbiddenOperationCount.high >>> 0).toNumber(true) : message.forbiddenOperationCount;\n        if (message.latencyCount && message.latencyCount.length) {\n            object.latencyCount = [];\n            for (let j = 0; j < message.latencyCount.length; ++j)\n                if (typeof message.latencyCount[j] === \"number\")\n                    object.latencyCount[j] = options.longs === String ? String(message.latencyCount[j]) : message.latencyCount[j];\n                else\n                    object.latencyCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message.latencyCount[j]) : options.longs === Number ? new $util.LongBits(message.latencyCount[j].low >>> 0, message.latencyCount[j].high >>> 0).toNumber() : message.latencyCount[j];\n        }\n        if (message.cacheLatencyCount && message.cacheLatencyCount.length) {\n            object.cacheLatencyCount = [];\n            for (let j = 0; j < message.cacheLatencyCount.length; ++j)\n                if (typeof message.cacheLatencyCount[j] === \"number\")\n                    object.cacheLatencyCount[j] = options.longs === String ? String(message.cacheLatencyCount[j]) : message.cacheLatencyCount[j];\n                else\n                    object.cacheLatencyCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message.cacheLatencyCount[j]) : options.longs === Number ? new $util.LongBits(message.cacheLatencyCount[j].low >>> 0, message.cacheLatencyCount[j].high >>> 0).toNumber() : message.cacheLatencyCount[j];\n        }\n        if (message.publicCacheTtlCount && message.publicCacheTtlCount.length) {\n            object.publicCacheTtlCount = [];\n            for (let j = 0; j < message.publicCacheTtlCount.length; ++j)\n                if (typeof message.publicCacheTtlCount[j] === \"number\")\n                    object.publicCacheTtlCount[j] = options.longs === String ? String(message.publicCacheTtlCount[j]) : message.publicCacheTtlCount[j];\n                else\n                    object.publicCacheTtlCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message.publicCacheTtlCount[j]) : options.longs === Number ? new $util.LongBits(message.publicCacheTtlCount[j].low >>> 0, message.publicCacheTtlCount[j].high >>> 0).toNumber() : message.publicCacheTtlCount[j];\n        }\n        if (message.privateCacheTtlCount && message.privateCacheTtlCount.length) {\n            object.privateCacheTtlCount = [];\n            for (let j = 0; j < message.privateCacheTtlCount.length; ++j)\n                if (typeof message.privateCacheTtlCount[j] === \"number\")\n                    object.privateCacheTtlCount[j] = options.longs === String ? String(message.privateCacheTtlCount[j]) : message.privateCacheTtlCount[j];\n                else\n                    object.privateCacheTtlCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message.privateCacheTtlCount[j]) : options.longs === Number ? new $util.LongBits(message.privateCacheTtlCount[j].low >>> 0, message.privateCacheTtlCount[j].high >>> 0).toNumber() : message.privateCacheTtlCount[j];\n        }\n        if (message.requestsWithoutFieldInstrumentation != null && message.hasOwnProperty(\"requestsWithoutFieldInstrumentation\"))\n            if (typeof message.requestsWithoutFieldInstrumentation === \"number\")\n                object.requestsWithoutFieldInstrumentation = options.longs === String ? String(message.requestsWithoutFieldInstrumentation) : message.requestsWithoutFieldInstrumentation;\n            else\n                object.requestsWithoutFieldInstrumentation = options.longs === String ? $util.Long.prototype.toString.call(message.requestsWithoutFieldInstrumentation) : options.longs === Number ? new $util.LongBits(message.requestsWithoutFieldInstrumentation.low >>> 0, message.requestsWithoutFieldInstrumentation.high >>> 0).toNumber(true) : message.requestsWithoutFieldInstrumentation;\n        return object;\n    };\n\n    /**\n     * Converts this QueryLatencyStats to JSON.\n     * @function toJSON\n     * @memberof QueryLatencyStats\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    QueryLatencyStats.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return QueryLatencyStats;\n})();\n\nexport const StatsContext = $root.StatsContext = (() => {\n\n    /**\n     * Properties of a StatsContext.\n     * @exports IStatsContext\n     * @interface IStatsContext\n     * @property {string|null} [clientName] StatsContext clientName\n     * @property {string|null} [clientVersion] StatsContext clientVersion\n     */\n\n    /**\n     * Constructs a new StatsContext.\n     * @exports StatsContext\n     * @classdesc Represents a StatsContext.\n     * @implements IStatsContext\n     * @constructor\n     * @param {IStatsContext=} [properties] Properties to set\n     */\n    function StatsContext(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * StatsContext clientName.\n     * @member {string} clientName\n     * @memberof StatsContext\n     * @instance\n     */\n    StatsContext.prototype.clientName = \"\";\n\n    /**\n     * StatsContext clientVersion.\n     * @member {string} clientVersion\n     * @memberof StatsContext\n     * @instance\n     */\n    StatsContext.prototype.clientVersion = \"\";\n\n    /**\n     * Creates a new StatsContext instance using the specified properties.\n     * @function create\n     * @memberof StatsContext\n     * @static\n     * @param {IStatsContext=} [properties] Properties to set\n     * @returns {StatsContext} StatsContext instance\n     */\n    StatsContext.create = function create(properties) {\n        return new StatsContext(properties);\n    };\n\n    /**\n     * Encodes the specified StatsContext message. Does not implicitly {@link StatsContext.verify|verify} messages.\n     * @function encode\n     * @memberof StatsContext\n     * @static\n     * @param {IStatsContext} message StatsContext message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    StatsContext.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.clientName != null && Object.hasOwnProperty.call(message, \"clientName\"))\n            writer.uint32(/* id 2, wireType 2 =*/18).string(message.clientName);\n        if (message.clientVersion != null && Object.hasOwnProperty.call(message, \"clientVersion\"))\n            writer.uint32(/* id 3, wireType 2 =*/26).string(message.clientVersion);\n        return writer;\n    };\n\n    /**\n     * Encodes the specified StatsContext message, length delimited. Does not implicitly {@link StatsContext.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof StatsContext\n     * @static\n     * @param {IStatsContext} message StatsContext message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    StatsContext.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a StatsContext message from the specified reader or buffer.\n     * @function decode\n     * @memberof StatsContext\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {StatsContext} StatsContext\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    StatsContext.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.StatsContext();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 2:\n                message.clientName = reader.string();\n                break;\n            case 3:\n                message.clientVersion = reader.string();\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a StatsContext message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof StatsContext\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {StatsContext} StatsContext\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    StatsContext.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a StatsContext message.\n     * @function verify\n     * @memberof StatsContext\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    StatsContext.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.clientName != null && message.hasOwnProperty(\"clientName\"))\n            if (!$util.isString(message.clientName))\n                return \"clientName: string expected\";\n        if (message.clientVersion != null && message.hasOwnProperty(\"clientVersion\"))\n            if (!$util.isString(message.clientVersion))\n                return \"clientVersion: string expected\";\n        return null;\n    };\n\n    /**\n     * Creates a plain object from a StatsContext message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof StatsContext\n     * @static\n     * @param {StatsContext} message StatsContext\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    StatsContext.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.defaults) {\n            object.clientName = \"\";\n            object.clientVersion = \"\";\n        }\n        if (message.clientName != null && message.hasOwnProperty(\"clientName\"))\n            object.clientName = message.clientName;\n        if (message.clientVersion != null && message.hasOwnProperty(\"clientVersion\"))\n            object.clientVersion = message.clientVersion;\n        return object;\n    };\n\n    /**\n     * Converts this StatsContext to JSON.\n     * @function toJSON\n     * @memberof StatsContext\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    StatsContext.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return StatsContext;\n})();\n\nexport const ContextualizedQueryLatencyStats = $root.ContextualizedQueryLatencyStats = (() => {\n\n    /**\n     * Properties of a ContextualizedQueryLatencyStats.\n     * @exports IContextualizedQueryLatencyStats\n     * @interface IContextualizedQueryLatencyStats\n     * @property {IQueryLatencyStats|null} [queryLatencyStats] ContextualizedQueryLatencyStats queryLatencyStats\n     * @property {IStatsContext|null} [context] ContextualizedQueryLatencyStats context\n     */\n\n    /**\n     * Constructs a new ContextualizedQueryLatencyStats.\n     * @exports ContextualizedQueryLatencyStats\n     * @classdesc Represents a ContextualizedQueryLatencyStats.\n     * @implements IContextualizedQueryLatencyStats\n     * @constructor\n     * @param {IContextualizedQueryLatencyStats=} [properties] Properties to set\n     */\n    function ContextualizedQueryLatencyStats(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * ContextualizedQueryLatencyStats queryLatencyStats.\n     * @member {IQueryLatencyStats|null|undefined} queryLatencyStats\n     * @memberof ContextualizedQueryLatencyStats\n     * @instance\n     */\n    ContextualizedQueryLatencyStats.prototype.queryLatencyStats = null;\n\n    /**\n     * ContextualizedQueryLatencyStats context.\n     * @member {IStatsContext|null|undefined} context\n     * @memberof ContextualizedQueryLatencyStats\n     * @instance\n     */\n    ContextualizedQueryLatencyStats.prototype.context = null;\n\n    /**\n     * Creates a new ContextualizedQueryLatencyStats instance using the specified properties.\n     * @function create\n     * @memberof ContextualizedQueryLatencyStats\n     * @static\n     * @param {IContextualizedQueryLatencyStats=} [properties] Properties to set\n     * @returns {ContextualizedQueryLatencyStats} ContextualizedQueryLatencyStats instance\n     */\n    ContextualizedQueryLatencyStats.create = function create(properties) {\n        return new ContextualizedQueryLatencyStats(properties);\n    };\n\n    /**\n     * Encodes the specified ContextualizedQueryLatencyStats message. Does not implicitly {@link ContextualizedQueryLatencyStats.verify|verify} messages.\n     * @function encode\n     * @memberof ContextualizedQueryLatencyStats\n     * @static\n     * @param {IContextualizedQueryLatencyStats} message ContextualizedQueryLatencyStats message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    ContextualizedQueryLatencyStats.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.queryLatencyStats != null && Object.hasOwnProperty.call(message, \"queryLatencyStats\"))\n            $root.QueryLatencyStats.encode(message.queryLatencyStats, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n        if (message.context != null && Object.hasOwnProperty.call(message, \"context\"))\n            $root.StatsContext.encode(message.context, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n        return writer;\n    };\n\n    /**\n     * Encodes the specified ContextualizedQueryLatencyStats message, length delimited. Does not implicitly {@link ContextualizedQueryLatencyStats.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof ContextualizedQueryLatencyStats\n     * @static\n     * @param {IContextualizedQueryLatencyStats} message ContextualizedQueryLatencyStats message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    ContextualizedQueryLatencyStats.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a ContextualizedQueryLatencyStats message from the specified reader or buffer.\n     * @function decode\n     * @memberof ContextualizedQueryLatencyStats\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {ContextualizedQueryLatencyStats} ContextualizedQueryLatencyStats\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    ContextualizedQueryLatencyStats.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ContextualizedQueryLatencyStats();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                message.queryLatencyStats = $root.QueryLatencyStats.decode(reader, reader.uint32());\n                break;\n            case 2:\n                message.context = $root.StatsContext.decode(reader, reader.uint32());\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a ContextualizedQueryLatencyStats message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof ContextualizedQueryLatencyStats\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {ContextualizedQueryLatencyStats} ContextualizedQueryLatencyStats\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    ContextualizedQueryLatencyStats.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a ContextualizedQueryLatencyStats message.\n     * @function verify\n     * @memberof ContextualizedQueryLatencyStats\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    ContextualizedQueryLatencyStats.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.queryLatencyStats != null && message.hasOwnProperty(\"queryLatencyStats\")) {\n            let error = $root.QueryLatencyStats.verify(message.queryLatencyStats);\n            if (error)\n                return \"queryLatencyStats.\" + error;\n        }\n        if (message.context != null && message.hasOwnProperty(\"context\")) {\n            let error = $root.StatsContext.verify(message.context);\n            if (error)\n                return \"context.\" + error;\n        }\n        return null;\n    };\n\n    /**\n     * Creates a plain object from a ContextualizedQueryLatencyStats message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof ContextualizedQueryLatencyStats\n     * @static\n     * @param {ContextualizedQueryLatencyStats} message ContextualizedQueryLatencyStats\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    ContextualizedQueryLatencyStats.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.defaults) {\n            object.queryLatencyStats = null;\n            object.context = null;\n        }\n        if (message.queryLatencyStats != null && message.hasOwnProperty(\"queryLatencyStats\"))\n            object.queryLatencyStats = $root.QueryLatencyStats.toObject(message.queryLatencyStats, options);\n        if (message.context != null && message.hasOwnProperty(\"context\"))\n            object.context = $root.StatsContext.toObject(message.context, options);\n        return object;\n    };\n\n    /**\n     * Converts this ContextualizedQueryLatencyStats to JSON.\n     * @function toJSON\n     * @memberof ContextualizedQueryLatencyStats\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    ContextualizedQueryLatencyStats.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return ContextualizedQueryLatencyStats;\n})();\n\nexport const ContextualizedTypeStats = $root.ContextualizedTypeStats = (() => {\n\n    /**\n     * Properties of a ContextualizedTypeStats.\n     * @exports IContextualizedTypeStats\n     * @interface IContextualizedTypeStats\n     * @property {IStatsContext|null} [context] ContextualizedTypeStats context\n     * @property {Object.<string,ITypeStat>|null} [perTypeStat] ContextualizedTypeStats perTypeStat\n     */\n\n    /**\n     * Constructs a new ContextualizedTypeStats.\n     * @exports ContextualizedTypeStats\n     * @classdesc Represents a ContextualizedTypeStats.\n     * @implements IContextualizedTypeStats\n     * @constructor\n     * @param {IContextualizedTypeStats=} [properties] Properties to set\n     */\n    function ContextualizedTypeStats(properties) {\n        this.perTypeStat = {};\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * ContextualizedTypeStats context.\n     * @member {IStatsContext|null|undefined} context\n     * @memberof ContextualizedTypeStats\n     * @instance\n     */\n    ContextualizedTypeStats.prototype.context = null;\n\n    /**\n     * ContextualizedTypeStats perTypeStat.\n     * @member {Object.<string,ITypeStat>} perTypeStat\n     * @memberof ContextualizedTypeStats\n     * @instance\n     */\n    ContextualizedTypeStats.prototype.perTypeStat = $util.emptyObject;\n\n    /**\n     * Creates a new ContextualizedTypeStats instance using the specified properties.\n     * @function create\n     * @memberof ContextualizedTypeStats\n     * @static\n     * @param {IContextualizedTypeStats=} [properties] Properties to set\n     * @returns {ContextualizedTypeStats} ContextualizedTypeStats instance\n     */\n    ContextualizedTypeStats.create = function create(properties) {\n        return new ContextualizedTypeStats(properties);\n    };\n\n    /**\n     * Encodes the specified ContextualizedTypeStats message. Does not implicitly {@link ContextualizedTypeStats.verify|verify} messages.\n     * @function encode\n     * @memberof ContextualizedTypeStats\n     * @static\n     * @param {IContextualizedTypeStats} message ContextualizedTypeStats message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    ContextualizedTypeStats.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.context != null && Object.hasOwnProperty.call(message, \"context\"))\n            $root.StatsContext.encode(message.context, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n        if (message.perTypeStat != null && Object.hasOwnProperty.call(message, \"perTypeStat\"))\n            for (let keys = Object.keys(message.perTypeStat), i = 0; i < keys.length; ++i) {\n                writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);\n                $root.TypeStat.encode(message.perTypeStat[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();\n            }\n        return writer;\n    };\n\n    /**\n     * Encodes the specified ContextualizedTypeStats message, length delimited. Does not implicitly {@link ContextualizedTypeStats.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof ContextualizedTypeStats\n     * @static\n     * @param {IContextualizedTypeStats} message ContextualizedTypeStats message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    ContextualizedTypeStats.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a ContextualizedTypeStats message from the specified reader or buffer.\n     * @function decode\n     * @memberof ContextualizedTypeStats\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {ContextualizedTypeStats} ContextualizedTypeStats\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    ContextualizedTypeStats.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ContextualizedTypeStats(), key;\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                message.context = $root.StatsContext.decode(reader, reader.uint32());\n                break;\n            case 2:\n                reader.skip().pos++;\n                if (message.perTypeStat === $util.emptyObject)\n                    message.perTypeStat = {};\n                key = reader.string();\n                reader.pos++;\n                message.perTypeStat[key] = $root.TypeStat.decode(reader, reader.uint32());\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a ContextualizedTypeStats message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof ContextualizedTypeStats\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {ContextualizedTypeStats} ContextualizedTypeStats\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    ContextualizedTypeStats.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a ContextualizedTypeStats message.\n     * @function verify\n     * @memberof ContextualizedTypeStats\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    ContextualizedTypeStats.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.context != null && message.hasOwnProperty(\"context\")) {\n            let error = $root.StatsContext.verify(message.context);\n            if (error)\n                return \"context.\" + error;\n        }\n        if (message.perTypeStat != null && message.hasOwnProperty(\"perTypeStat\")) {\n            if (!$util.isObject(message.perTypeStat))\n                return \"perTypeStat: object expected\";\n            let key = Object.keys(message.perTypeStat);\n            for (let i = 0; i < key.length; ++i) {\n                let error = $root.TypeStat.verify(message.perTypeStat[key[i]]);\n                if (error)\n                    return \"perTypeStat.\" + error;\n            }\n        }\n        return null;\n    };\n\n    /**\n     * Creates a plain object from a ContextualizedTypeStats message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof ContextualizedTypeStats\n     * @static\n     * @param {ContextualizedTypeStats} message ContextualizedTypeStats\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    ContextualizedTypeStats.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.objects || options.defaults)\n            object.perTypeStat = {};\n        if (options.defaults)\n            object.context = null;\n        if (message.context != null && message.hasOwnProperty(\"context\"))\n            object.context = $root.StatsContext.toObject(message.context, options);\n        let keys2;\n        if (message.perTypeStat && (keys2 = Object.keys(message.perTypeStat)).length) {\n            object.perTypeStat = {};\n            for (let j = 0; j < keys2.length; ++j)\n                object.perTypeStat[keys2[j]] = $root.TypeStat.toObject(message.perTypeStat[keys2[j]], options);\n        }\n        return object;\n    };\n\n    /**\n     * Converts this ContextualizedTypeStats to JSON.\n     * @function toJSON\n     * @memberof ContextualizedTypeStats\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    ContextualizedTypeStats.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return ContextualizedTypeStats;\n})();\n\nexport const FieldStat = $root.FieldStat = (() => {\n\n    /**\n     * Properties of a FieldStat.\n     * @exports IFieldStat\n     * @interface IFieldStat\n     * @property {string|null} [returnType] FieldStat returnType\n     * @property {number|null} [errorsCount] FieldStat errorsCount\n     * @property {number|null} [observedExecutionCount] FieldStat observedExecutionCount\n     * @property {number|null} [estimatedExecutionCount] FieldStat estimatedExecutionCount\n     * @property {number|null} [requestsWithErrorsCount] FieldStat requestsWithErrorsCount\n     * @property {$protobuf.ToArray.<number>|Array.<number>|null} [latencyCount] FieldStat latencyCount\n     */\n\n    /**\n     * Constructs a new FieldStat.\n     * @exports FieldStat\n     * @classdesc Represents a FieldStat.\n     * @implements IFieldStat\n     * @constructor\n     * @param {IFieldStat=} [properties] Properties to set\n     */\n    function FieldStat(properties) {\n        this.latencyCount = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * FieldStat returnType.\n     * @member {string} returnType\n     * @memberof FieldStat\n     * @instance\n     */\n    FieldStat.prototype.returnType = \"\";\n\n    /**\n     * FieldStat errorsCount.\n     * @member {number} errorsCount\n     * @memberof FieldStat\n     * @instance\n     */\n    FieldStat.prototype.errorsCount = 0;\n\n    /**\n     * FieldStat observedExecutionCount.\n     * @member {number} observedExecutionCount\n     * @memberof FieldStat\n     * @instance\n     */\n    FieldStat.prototype.observedExecutionCount = 0;\n\n    /**\n     * FieldStat estimatedExecutionCount.\n     * @member {number} estimatedExecutionCount\n     * @memberof FieldStat\n     * @instance\n     */\n    FieldStat.prototype.estimatedExecutionCount = 0;\n\n    /**\n     * FieldStat requestsWithErrorsCount.\n     * @member {number} requestsWithErrorsCount\n     * @memberof FieldStat\n     * @instance\n     */\n    FieldStat.prototype.requestsWithErrorsCount = 0;\n\n    /**\n     * FieldStat latencyCount.\n     * @member {Array.<number>} latencyCount\n     * @memberof FieldStat\n     * @instance\n     */\n    FieldStat.prototype.latencyCount = $util.emptyArray;\n\n    /**\n     * Creates a new FieldStat instance using the specified properties.\n     * @function create\n     * @memberof FieldStat\n     * @static\n     * @param {IFieldStat=} [properties] Properties to set\n     * @returns {FieldStat} FieldStat instance\n     */\n    FieldStat.create = function create(properties) {\n        return new FieldStat(properties);\n    };\n\n    /**\n     * Encodes the specified FieldStat message. Does not implicitly {@link FieldStat.verify|verify} messages.\n     * @function encode\n     * @memberof FieldStat\n     * @static\n     * @param {IFieldStat} message FieldStat message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    FieldStat.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.returnType != null && Object.hasOwnProperty.call(message, \"returnType\"))\n            writer.uint32(/* id 3, wireType 2 =*/26).string(message.returnType);\n        if (message.errorsCount != null && Object.hasOwnProperty.call(message, \"errorsCount\"))\n            writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.errorsCount);\n        if (message.observedExecutionCount != null && Object.hasOwnProperty.call(message, \"observedExecutionCount\"))\n            writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.observedExecutionCount);\n        if (message.requestsWithErrorsCount != null && Object.hasOwnProperty.call(message, \"requestsWithErrorsCount\"))\n            writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.requestsWithErrorsCount);\n        let array9;\n        if (message.latencyCount != null && message.latencyCount.toArray)\n            array9 = message.latencyCount.toArray();\n        else\n            array9 = message.latencyCount;\n        if (array9 != null && array9.length) {\n            writer.uint32(/* id 9, wireType 2 =*/74).fork();\n            for (let i = 0; i < array9.length; ++i)\n                writer.sint64(array9[i]);\n            writer.ldelim();\n        }\n        if (message.estimatedExecutionCount != null && Object.hasOwnProperty.call(message, \"estimatedExecutionCount\"))\n            writer.uint32(/* id 10, wireType 0 =*/80).uint64(message.estimatedExecutionCount);\n        return writer;\n    };\n\n    /**\n     * Encodes the specified FieldStat message, length delimited. Does not implicitly {@link FieldStat.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof FieldStat\n     * @static\n     * @param {IFieldStat} message FieldStat message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    FieldStat.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a FieldStat message from the specified reader or buffer.\n     * @function decode\n     * @memberof FieldStat\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {FieldStat} FieldStat\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    FieldStat.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.FieldStat();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 3:\n                message.returnType = reader.string();\n                break;\n            case 4:\n                message.errorsCount = reader.uint64();\n                break;\n            case 5:\n                message.observedExecutionCount = reader.uint64();\n                break;\n            case 10:\n                message.estimatedExecutionCount = reader.uint64();\n                break;\n            case 6:\n                message.requestsWithErrorsCount = reader.uint64();\n                break;\n            case 9:\n                if (!(message.latencyCount && message.latencyCount.length))\n                    message.latencyCount = [];\n                if ((tag & 7) === 2) {\n                    let end2 = reader.uint32() + reader.pos;\n                    while (reader.pos < end2)\n                        message.latencyCount.push(reader.sint64());\n                } else\n                    message.latencyCount.push(reader.sint64());\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a FieldStat message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof FieldStat\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {FieldStat} FieldStat\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    FieldStat.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a FieldStat message.\n     * @function verify\n     * @memberof FieldStat\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    FieldStat.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.returnType != null && message.hasOwnProperty(\"returnType\"))\n            if (!$util.isString(message.returnType))\n                return \"returnType: string expected\";\n        if (message.errorsCount != null && message.hasOwnProperty(\"errorsCount\"))\n            if (!$util.isInteger(message.errorsCount) && !(message.errorsCount && $util.isInteger(message.errorsCount.low) && $util.isInteger(message.errorsCount.high)))\n                return \"errorsCount: integer|Long expected\";\n        if (message.observedExecutionCount != null && message.hasOwnProperty(\"observedExecutionCount\"))\n            if (!$util.isInteger(message.observedExecutionCount) && !(message.observedExecutionCount && $util.isInteger(message.observedExecutionCount.low) && $util.isInteger(message.observedExecutionCount.high)))\n                return \"observedExecutionCount: integer|Long expected\";\n        if (message.estimatedExecutionCount != null && message.hasOwnProperty(\"estimatedExecutionCount\"))\n            if (!$util.isInteger(message.estimatedExecutionCount) && !(message.estimatedExecutionCount && $util.isInteger(message.estimatedExecutionCount.low) && $util.isInteger(message.estimatedExecutionCount.high)))\n                return \"estimatedExecutionCount: integer|Long expected\";\n        if (message.requestsWithErrorsCount != null && message.hasOwnProperty(\"requestsWithErrorsCount\"))\n            if (!$util.isInteger(message.requestsWithErrorsCount) && !(message.requestsWithErrorsCount && $util.isInteger(message.requestsWithErrorsCount.low) && $util.isInteger(message.requestsWithErrorsCount.high)))\n                return \"requestsWithErrorsCount: integer|Long expected\";\n        if (message.latencyCount != null && message.hasOwnProperty(\"latencyCount\")) {\n            let array9;\n            if (message.latencyCount != null && message.latencyCount.toArray)\n                array9 = message.latencyCount.toArray();\n            else\n                array9 = message.latencyCount;\n            if (!Array.isArray(array9))\n                return \"latencyCount: array expected\";\n            for (let i = 0; i < array9.length; ++i)\n                if (!$util.isInteger(array9[i]) && !(array9[i] && $util.isInteger(array9[i].low) && $util.isInteger(array9[i].high)))\n                    return \"latencyCount: integer|Long[] expected\";\n        }\n        return null;\n    };\n\n    /**\n     * Creates a plain object from a FieldStat message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof FieldStat\n     * @static\n     * @param {FieldStat} message FieldStat\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    FieldStat.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.arrays || options.defaults)\n            object.latencyCount = [];\n        if (options.defaults) {\n            object.returnType = \"\";\n            object.errorsCount = 0;\n            object.observedExecutionCount = 0;\n            object.requestsWithErrorsCount = 0;\n            object.estimatedExecutionCount = 0;\n        }\n        if (message.returnType != null && message.hasOwnProperty(\"returnType\"))\n            object.returnType = message.returnType;\n        if (message.errorsCount != null && message.hasOwnProperty(\"errorsCount\"))\n            if (typeof message.errorsCount === \"number\")\n                object.errorsCount = options.longs === String ? String(message.errorsCount) : message.errorsCount;\n            else\n                object.errorsCount = options.longs === String ? $util.Long.prototype.toString.call(message.errorsCount) : options.longs === Number ? new $util.LongBits(message.errorsCount.low >>> 0, message.errorsCount.high >>> 0).toNumber(true) : message.errorsCount;\n        if (message.observedExecutionCount != null && message.hasOwnProperty(\"observedExecutionCount\"))\n            if (typeof message.observedExecutionCount === \"number\")\n                object.observedExecutionCount = options.longs === String ? String(message.observedExecutionCount) : message.observedExecutionCount;\n            else\n                object.observedExecutionCount = options.longs === String ? $util.Long.prototype.toString.call(message.observedExecutionCount) : options.longs === Number ? new $util.LongBits(message.observedExecutionCount.low >>> 0, message.observedExecutionCount.high >>> 0).toNumber(true) : message.observedExecutionCount;\n        if (message.requestsWithErrorsCount != null && message.hasOwnProperty(\"requestsWithErrorsCount\"))\n            if (typeof message.requestsWithErrorsCount === \"number\")\n                object.requestsWithErrorsCount = options.longs === String ? String(message.requestsWithErrorsCount) : message.requestsWithErrorsCount;\n            else\n                object.requestsWithErrorsCount = options.longs === String ? $util.Long.prototype.toString.call(message.requestsWithErrorsCount) : options.longs === Number ? new $util.LongBits(message.requestsWithErrorsCount.low >>> 0, message.requestsWithErrorsCount.high >>> 0).toNumber(true) : message.requestsWithErrorsCount;\n        if (message.latencyCount && message.latencyCount.length) {\n            object.latencyCount = [];\n            for (let j = 0; j < message.latencyCount.length; ++j)\n                if (typeof message.latencyCount[j] === \"number\")\n                    object.latencyCount[j] = options.longs === String ? String(message.latencyCount[j]) : message.latencyCount[j];\n                else\n                    object.latencyCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message.latencyCount[j]) : options.longs === Number ? new $util.LongBits(message.latencyCount[j].low >>> 0, message.latencyCount[j].high >>> 0).toNumber() : message.latencyCount[j];\n        }\n        if (message.estimatedExecutionCount != null && message.hasOwnProperty(\"estimatedExecutionCount\"))\n            if (typeof message.estimatedExecutionCount === \"number\")\n                object.estimatedExecutionCount = options.longs === String ? String(message.estimatedExecutionCount) : message.estimatedExecutionCount;\n            else\n                object.estimatedExecutionCount = options.longs === String ? $util.Long.prototype.toString.call(message.estimatedExecutionCount) : options.longs === Number ? new $util.LongBits(message.estimatedExecutionCount.low >>> 0, message.estimatedExecutionCount.high >>> 0).toNumber(true) : message.estimatedExecutionCount;\n        return object;\n    };\n\n    /**\n     * Converts this FieldStat to JSON.\n     * @function toJSON\n     * @memberof FieldStat\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    FieldStat.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return FieldStat;\n})();\n\nexport const TypeStat = $root.TypeStat = (() => {\n\n    /**\n     * Properties of a TypeStat.\n     * @exports ITypeStat\n     * @interface ITypeStat\n     * @property {Object.<string,IFieldStat>|null} [perFieldStat] TypeStat perFieldStat\n     */\n\n    /**\n     * Constructs a new TypeStat.\n     * @exports TypeStat\n     * @classdesc Represents a TypeStat.\n     * @implements ITypeStat\n     * @constructor\n     * @param {ITypeStat=} [properties] Properties to set\n     */\n    function TypeStat(properties) {\n        this.perFieldStat = {};\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * TypeStat perFieldStat.\n     * @member {Object.<string,IFieldStat>} perFieldStat\n     * @memberof TypeStat\n     * @instance\n     */\n    TypeStat.prototype.perFieldStat = $util.emptyObject;\n\n    /**\n     * Creates a new TypeStat instance using the specified properties.\n     * @function create\n     * @memberof TypeStat\n     * @static\n     * @param {ITypeStat=} [properties] Properties to set\n     * @returns {TypeStat} TypeStat instance\n     */\n    TypeStat.create = function create(properties) {\n        return new TypeStat(properties);\n    };\n\n    /**\n     * Encodes the specified TypeStat message. Does not implicitly {@link TypeStat.verify|verify} messages.\n     * @function encode\n     * @memberof TypeStat\n     * @static\n     * @param {ITypeStat} message TypeStat message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    TypeStat.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.perFieldStat != null && Object.hasOwnProperty.call(message, \"perFieldStat\"))\n            for (let keys = Object.keys(message.perFieldStat), i = 0; i < keys.length; ++i) {\n                writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);\n                $root.FieldStat.encode(message.perFieldStat[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();\n            }\n        return writer;\n    };\n\n    /**\n     * Encodes the specified TypeStat message, length delimited. Does not implicitly {@link TypeStat.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof TypeStat\n     * @static\n     * @param {ITypeStat} message TypeStat message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    TypeStat.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a TypeStat message from the specified reader or buffer.\n     * @function decode\n     * @memberof TypeStat\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {TypeStat} TypeStat\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    TypeStat.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.TypeStat(), key;\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 3:\n                reader.skip().pos++;\n                if (message.perFieldStat === $util.emptyObject)\n                    message.perFieldStat = {};\n                key = reader.string();\n                reader.pos++;\n                message.perFieldStat[key] = $root.FieldStat.decode(reader, reader.uint32());\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a TypeStat message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof TypeStat\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {TypeStat} TypeStat\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    TypeStat.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a TypeStat message.\n     * @function verify\n     * @memberof TypeStat\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    TypeStat.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.perFieldStat != null && message.hasOwnProperty(\"perFieldStat\")) {\n            if (!$util.isObject(message.perFieldStat))\n                return \"perFieldStat: object expected\";\n            let key = Object.keys(message.perFieldStat);\n            for (let i = 0; i < key.length; ++i) {\n                let error = $root.FieldStat.verify(message.perFieldStat[key[i]]);\n                if (error)\n                    return \"perFieldStat.\" + error;\n            }\n        }\n        return null;\n    };\n\n    /**\n     * Creates a plain object from a TypeStat message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof TypeStat\n     * @static\n     * @param {TypeStat} message TypeStat\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    TypeStat.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.objects || options.defaults)\n            object.perFieldStat = {};\n        let keys2;\n        if (message.perFieldStat && (keys2 = Object.keys(message.perFieldStat)).length) {\n            object.perFieldStat = {};\n            for (let j = 0; j < keys2.length; ++j)\n                object.perFieldStat[keys2[j]] = $root.FieldStat.toObject(message.perFieldStat[keys2[j]], options);\n        }\n        return object;\n    };\n\n    /**\n     * Converts this TypeStat to JSON.\n     * @function toJSON\n     * @memberof TypeStat\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    TypeStat.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return TypeStat;\n})();\n\nexport const ReferencedFieldsForType = $root.ReferencedFieldsForType = (() => {\n\n    /**\n     * Properties of a ReferencedFieldsForType.\n     * @exports IReferencedFieldsForType\n     * @interface IReferencedFieldsForType\n     * @property {Array.<string>|null} [fieldNames] ReferencedFieldsForType fieldNames\n     * @property {boolean|null} [isInterface] ReferencedFieldsForType isInterface\n     */\n\n    /**\n     * Constructs a new ReferencedFieldsForType.\n     * @exports ReferencedFieldsForType\n     * @classdesc Represents a ReferencedFieldsForType.\n     * @implements IReferencedFieldsForType\n     * @constructor\n     * @param {IReferencedFieldsForType=} [properties] Properties to set\n     */\n    function ReferencedFieldsForType(properties) {\n        this.fieldNames = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * ReferencedFieldsForType fieldNames.\n     * @member {Array.<string>} fieldNames\n     * @memberof ReferencedFieldsForType\n     * @instance\n     */\n    ReferencedFieldsForType.prototype.fieldNames = $util.emptyArray;\n\n    /**\n     * ReferencedFieldsForType isInterface.\n     * @member {boolean} isInterface\n     * @memberof ReferencedFieldsForType\n     * @instance\n     */\n    ReferencedFieldsForType.prototype.isInterface = false;\n\n    /**\n     * Creates a new ReferencedFieldsForType instance using the specified properties.\n     * @function create\n     * @memberof ReferencedFieldsForType\n     * @static\n     * @param {IReferencedFieldsForType=} [properties] Properties to set\n     * @returns {ReferencedFieldsForType} ReferencedFieldsForType instance\n     */\n    ReferencedFieldsForType.create = function create(properties) {\n        return new ReferencedFieldsForType(properties);\n    };\n\n    /**\n     * Encodes the specified ReferencedFieldsForType message. Does not implicitly {@link ReferencedFieldsForType.verify|verify} messages.\n     * @function encode\n     * @memberof ReferencedFieldsForType\n     * @static\n     * @param {IReferencedFieldsForType} message ReferencedFieldsForType message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    ReferencedFieldsForType.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.fieldNames != null && message.fieldNames.length)\n            for (let i = 0; i < message.fieldNames.length; ++i)\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.fieldNames[i]);\n        if (message.isInterface != null && Object.hasOwnProperty.call(message, \"isInterface\"))\n            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isInterface);\n        return writer;\n    };\n\n    /**\n     * Encodes the specified ReferencedFieldsForType message, length delimited. Does not implicitly {@link ReferencedFieldsForType.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof ReferencedFieldsForType\n     * @static\n     * @param {IReferencedFieldsForType} message ReferencedFieldsForType message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    ReferencedFieldsForType.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a ReferencedFieldsForType message from the specified reader or buffer.\n     * @function decode\n     * @memberof ReferencedFieldsForType\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {ReferencedFieldsForType} ReferencedFieldsForType\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    ReferencedFieldsForType.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ReferencedFieldsForType();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                if (!(message.fieldNames && message.fieldNames.length))\n                    message.fieldNames = [];\n                message.fieldNames.push(reader.string());\n                break;\n            case 2:\n                message.isInterface = reader.bool();\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a ReferencedFieldsForType message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof ReferencedFieldsForType\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {ReferencedFieldsForType} ReferencedFieldsForType\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    ReferencedFieldsForType.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a ReferencedFieldsForType message.\n     * @function verify\n     * @memberof ReferencedFieldsForType\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    ReferencedFieldsForType.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.fieldNames != null && message.hasOwnProperty(\"fieldNames\")) {\n            if (!Array.isArray(message.fieldNames))\n                return \"fieldNames: array expected\";\n            for (let i = 0; i < message.fieldNames.length; ++i)\n                if (!$util.isString(message.fieldNames[i]))\n                    return \"fieldNames: string[] expected\";\n        }\n        if (message.isInterface != null && message.hasOwnProperty(\"isInterface\"))\n            if (typeof message.isInterface !== \"boolean\")\n                return \"isInterface: boolean expected\";\n        return null;\n    };\n\n    /**\n     * Creates a plain object from a ReferencedFieldsForType message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof ReferencedFieldsForType\n     * @static\n     * @param {ReferencedFieldsForType} message ReferencedFieldsForType\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    ReferencedFieldsForType.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.arrays || options.defaults)\n            object.fieldNames = [];\n        if (options.defaults)\n            object.isInterface = false;\n        if (message.fieldNames && message.fieldNames.length) {\n            object.fieldNames = [];\n            for (let j = 0; j < message.fieldNames.length; ++j)\n                object.fieldNames[j] = message.fieldNames[j];\n        }\n        if (message.isInterface != null && message.hasOwnProperty(\"isInterface\"))\n            object.isInterface = message.isInterface;\n        return object;\n    };\n\n    /**\n     * Converts this ReferencedFieldsForType to JSON.\n     * @function toJSON\n     * @memberof ReferencedFieldsForType\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    ReferencedFieldsForType.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return ReferencedFieldsForType;\n})();\n\nexport const Report = $root.Report = (() => {\n\n    /**\n     * Properties of a Report.\n     * @exports IReport\n     * @interface IReport\n     * @property {IReportHeader|null} [header] Report header\n     * @property {Object.<string,ITracesAndStats>|null} [tracesPerQuery] Report tracesPerQuery\n     * @property {google.protobuf.ITimestamp|null} [endTime] Report endTime\n     * @property {number|null} [operationCount] Report operationCount\n     * @property {boolean|null} [tracesPreAggregated] Report tracesPreAggregated\n     */\n\n    /**\n     * Constructs a new Report.\n     * @exports Report\n     * @classdesc Represents a Report.\n     * @implements IReport\n     * @constructor\n     * @param {IReport=} [properties] Properties to set\n     */\n    function Report(properties) {\n        this.tracesPerQuery = {};\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * Report header.\n     * @member {IReportHeader|null|undefined} header\n     * @memberof Report\n     * @instance\n     */\n    Report.prototype.header = null;\n\n    /**\n     * Report tracesPerQuery.\n     * @member {Object.<string,ITracesAndStats>} tracesPerQuery\n     * @memberof Report\n     * @instance\n     */\n    Report.prototype.tracesPerQuery = $util.emptyObject;\n\n    /**\n     * Report endTime.\n     * @member {google.protobuf.ITimestamp|null|undefined} endTime\n     * @memberof Report\n     * @instance\n     */\n    Report.prototype.endTime = null;\n\n    /**\n     * Report operationCount.\n     * @member {number} operationCount\n     * @memberof Report\n     * @instance\n     */\n    Report.prototype.operationCount = 0;\n\n    /**\n     * Report tracesPreAggregated.\n     * @member {boolean} tracesPreAggregated\n     * @memberof Report\n     * @instance\n     */\n    Report.prototype.tracesPreAggregated = false;\n\n    /**\n     * Creates a new Report instance using the specified properties.\n     * @function create\n     * @memberof Report\n     * @static\n     * @param {IReport=} [properties] Properties to set\n     * @returns {Report} Report instance\n     */\n    Report.create = function create(properties) {\n        return new Report(properties);\n    };\n\n    /**\n     * Encodes the specified Report message. Does not implicitly {@link Report.verify|verify} messages.\n     * @function encode\n     * @memberof Report\n     * @static\n     * @param {IReport} message Report message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Report.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.header != null && Object.hasOwnProperty.call(message, \"header\"))\n            $root.ReportHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n        if (message.endTime != null && Object.hasOwnProperty.call(message, \"endTime\"))\n            $root.google.protobuf.Timestamp.encode(message.endTime, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n        if (message.tracesPerQuery != null && Object.hasOwnProperty.call(message, \"tracesPerQuery\"))\n            for (let keys = Object.keys(message.tracesPerQuery), i = 0; i < keys.length; ++i) {\n                writer.uint32(/* id 5, wireType 2 =*/42).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);\n                $root.TracesAndStats.encode(message.tracesPerQuery[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();\n            }\n        if (message.operationCount != null && Object.hasOwnProperty.call(message, \"operationCount\"))\n            writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.operationCount);\n        if (message.tracesPreAggregated != null && Object.hasOwnProperty.call(message, \"tracesPreAggregated\"))\n            writer.uint32(/* id 7, wireType 0 =*/56).bool(message.tracesPreAggregated);\n        return writer;\n    };\n\n    /**\n     * Encodes the specified Report message, length delimited. Does not implicitly {@link Report.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof Report\n     * @static\n     * @param {IReport} message Report message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Report.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a Report message from the specified reader or buffer.\n     * @function decode\n     * @memberof Report\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {Report} Report\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Report.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Report(), key;\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                message.header = $root.ReportHeader.decode(reader, reader.uint32());\n                break;\n            case 5:\n                reader.skip().pos++;\n                if (message.tracesPerQuery === $util.emptyObject)\n                    message.tracesPerQuery = {};\n                key = reader.string();\n                reader.pos++;\n                message.tracesPerQuery[key] = $root.TracesAndStats.decode(reader, reader.uint32());\n                break;\n            case 2:\n                message.endTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());\n                break;\n            case 6:\n                message.operationCount = reader.uint64();\n                break;\n            case 7:\n                message.tracesPreAggregated = reader.bool();\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a Report message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof Report\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {Report} Report\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Report.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a Report message.\n     * @function verify\n     * @memberof Report\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    Report.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.header != null && message.hasOwnProperty(\"header\")) {\n            let error = $root.ReportHeader.verify(message.header);\n            if (error)\n                return \"header.\" + error;\n        }\n        if (message.tracesPerQuery != null && message.hasOwnProperty(\"tracesPerQuery\")) {\n            if (!$util.isObject(message.tracesPerQuery))\n                return \"tracesPerQuery: object expected\";\n            let key = Object.keys(message.tracesPerQuery);\n            for (let i = 0; i < key.length; ++i) {\n                let error = $root.TracesAndStats.verify(message.tracesPerQuery[key[i]]);\n                if (error)\n                    return \"tracesPerQuery.\" + error;\n            }\n        }\n        if (message.endTime != null && message.hasOwnProperty(\"endTime\")) {\n            let error = $root.google.protobuf.Timestamp.verify(message.endTime);\n            if (error)\n                return \"endTime.\" + error;\n        }\n        if (message.operationCount != null && message.hasOwnProperty(\"operationCount\"))\n            if (!$util.isInteger(message.operationCount) && !(message.operationCount && $util.isInteger(message.operationCount.low) && $util.isInteger(message.operationCount.high)))\n                return \"operationCount: integer|Long expected\";\n        if (message.tracesPreAggregated != null && message.hasOwnProperty(\"tracesPreAggregated\"))\n            if (typeof message.tracesPreAggregated !== \"boolean\")\n                return \"tracesPreAggregated: boolean expected\";\n        return null;\n    };\n\n    /**\n     * Creates a plain object from a Report message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Report\n     * @static\n     * @param {Report} message Report\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    Report.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.objects || options.defaults)\n            object.tracesPerQuery = {};\n        if (options.defaults) {\n            object.header = null;\n            object.endTime = null;\n            object.operationCount = 0;\n            object.tracesPreAggregated = false;\n        }\n        if (message.header != null && message.hasOwnProperty(\"header\"))\n            object.header = $root.ReportHeader.toObject(message.header, options);\n        if (message.endTime != null && message.hasOwnProperty(\"endTime\"))\n            object.endTime = $root.google.protobuf.Timestamp.toObject(message.endTime, options);\n        let keys2;\n        if (message.tracesPerQuery && (keys2 = Object.keys(message.tracesPerQuery)).length) {\n            object.tracesPerQuery = {};\n            for (let j = 0; j < keys2.length; ++j)\n                object.tracesPerQuery[keys2[j]] = $root.TracesAndStats.toObject(message.tracesPerQuery[keys2[j]], options);\n        }\n        if (message.operationCount != null && message.hasOwnProperty(\"operationCount\"))\n            if (typeof message.operationCount === \"number\")\n                object.operationCount = options.longs === String ? String(message.operationCount) : message.operationCount;\n            else\n                object.operationCount = options.longs === String ? $util.Long.prototype.toString.call(message.operationCount) : options.longs === Number ? new $util.LongBits(message.operationCount.low >>> 0, message.operationCount.high >>> 0).toNumber(true) : message.operationCount;\n        if (message.tracesPreAggregated != null && message.hasOwnProperty(\"tracesPreAggregated\"))\n            object.tracesPreAggregated = message.tracesPreAggregated;\n        return object;\n    };\n\n    /**\n     * Converts this Report to JSON.\n     * @function toJSON\n     * @memberof Report\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    Report.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return Report;\n})();\n\nexport const ContextualizedStats = $root.ContextualizedStats = (() => {\n\n    /**\n     * Properties of a ContextualizedStats.\n     * @exports IContextualizedStats\n     * @interface IContextualizedStats\n     * @property {IStatsContext|null} [context] ContextualizedStats context\n     * @property {IQueryLatencyStats|null} [queryLatencyStats] ContextualizedStats queryLatencyStats\n     * @property {Object.<string,ITypeStat>|null} [perTypeStat] ContextualizedStats perTypeStat\n     */\n\n    /**\n     * Constructs a new ContextualizedStats.\n     * @exports ContextualizedStats\n     * @classdesc Represents a ContextualizedStats.\n     * @implements IContextualizedStats\n     * @constructor\n     * @param {IContextualizedStats=} [properties] Properties to set\n     */\n    function ContextualizedStats(properties) {\n        this.perTypeStat = {};\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * ContextualizedStats context.\n     * @member {IStatsContext|null|undefined} context\n     * @memberof ContextualizedStats\n     * @instance\n     */\n    ContextualizedStats.prototype.context = null;\n\n    /**\n     * ContextualizedStats queryLatencyStats.\n     * @member {IQueryLatencyStats|null|undefined} queryLatencyStats\n     * @memberof ContextualizedStats\n     * @instance\n     */\n    ContextualizedStats.prototype.queryLatencyStats = null;\n\n    /**\n     * ContextualizedStats perTypeStat.\n     * @member {Object.<string,ITypeStat>} perTypeStat\n     * @memberof ContextualizedStats\n     * @instance\n     */\n    ContextualizedStats.prototype.perTypeStat = $util.emptyObject;\n\n    /**\n     * Creates a new ContextualizedStats instance using the specified properties.\n     * @function create\n     * @memberof ContextualizedStats\n     * @static\n     * @param {IContextualizedStats=} [properties] Properties to set\n     * @returns {ContextualizedStats} ContextualizedStats instance\n     */\n    ContextualizedStats.create = function create(properties) {\n        return new ContextualizedStats(properties);\n    };\n\n    /**\n     * Encodes the specified ContextualizedStats message. Does not implicitly {@link ContextualizedStats.verify|verify} messages.\n     * @function encode\n     * @memberof ContextualizedStats\n     * @static\n     * @param {IContextualizedStats} message ContextualizedStats message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    ContextualizedStats.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.context != null && Object.hasOwnProperty.call(message, \"context\"))\n            $root.StatsContext.encode(message.context, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n        if (message.queryLatencyStats != null && Object.hasOwnProperty.call(message, \"queryLatencyStats\"))\n            $root.QueryLatencyStats.encode(message.queryLatencyStats, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n        if (message.perTypeStat != null && Object.hasOwnProperty.call(message, \"perTypeStat\"))\n            for (let keys = Object.keys(message.perTypeStat), i = 0; i < keys.length; ++i) {\n                writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);\n                $root.TypeStat.encode(message.perTypeStat[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();\n            }\n        return writer;\n    };\n\n    /**\n     * Encodes the specified ContextualizedStats message, length delimited. Does not implicitly {@link ContextualizedStats.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof ContextualizedStats\n     * @static\n     * @param {IContextualizedStats} message ContextualizedStats message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    ContextualizedStats.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a ContextualizedStats message from the specified reader or buffer.\n     * @function decode\n     * @memberof ContextualizedStats\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {ContextualizedStats} ContextualizedStats\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    ContextualizedStats.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ContextualizedStats(), key;\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                message.context = $root.StatsContext.decode(reader, reader.uint32());\n                break;\n            case 2:\n                message.queryLatencyStats = $root.QueryLatencyStats.decode(reader, reader.uint32());\n                break;\n            case 3:\n                reader.skip().pos++;\n                if (message.perTypeStat === $util.emptyObject)\n                    message.perTypeStat = {};\n                key = reader.string();\n                reader.pos++;\n                message.perTypeStat[key] = $root.TypeStat.decode(reader, reader.uint32());\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a ContextualizedStats message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof ContextualizedStats\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {ContextualizedStats} ContextualizedStats\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    ContextualizedStats.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a ContextualizedStats message.\n     * @function verify\n     * @memberof ContextualizedStats\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    ContextualizedStats.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.context != null && message.hasOwnProperty(\"context\")) {\n            let error = $root.StatsContext.verify(message.context);\n            if (error)\n                return \"context.\" + error;\n        }\n        if (message.queryLatencyStats != null && message.hasOwnProperty(\"queryLatencyStats\")) {\n            let error = $root.QueryLatencyStats.verify(message.queryLatencyStats);\n            if (error)\n                return \"queryLatencyStats.\" + error;\n        }\n        if (message.perTypeStat != null && message.hasOwnProperty(\"perTypeStat\")) {\n            if (!$util.isObject(message.perTypeStat))\n                return \"perTypeStat: object expected\";\n            let key = Object.keys(message.perTypeStat);\n            for (let i = 0; i < key.length; ++i) {\n                let error = $root.TypeStat.verify(message.perTypeStat[key[i]]);\n                if (error)\n                    return \"perTypeStat.\" + error;\n            }\n        }\n        return null;\n    };\n\n    /**\n     * Creates a plain object from a ContextualizedStats message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof ContextualizedStats\n     * @static\n     * @param {ContextualizedStats} message ContextualizedStats\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    ContextualizedStats.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.objects || options.defaults)\n            object.perTypeStat = {};\n        if (options.defaults) {\n            object.context = null;\n            object.queryLatencyStats = null;\n        }\n        if (message.context != null && message.hasOwnProperty(\"context\"))\n            object.context = $root.StatsContext.toObject(message.context, options);\n        if (message.queryLatencyStats != null && message.hasOwnProperty(\"queryLatencyStats\"))\n            object.queryLatencyStats = $root.QueryLatencyStats.toObject(message.queryLatencyStats, options);\n        let keys2;\n        if (message.perTypeStat && (keys2 = Object.keys(message.perTypeStat)).length) {\n            object.perTypeStat = {};\n            for (let j = 0; j < keys2.length; ++j)\n                object.perTypeStat[keys2[j]] = $root.TypeStat.toObject(message.perTypeStat[keys2[j]], options);\n        }\n        return object;\n    };\n\n    /**\n     * Converts this ContextualizedStats to JSON.\n     * @function toJSON\n     * @memberof ContextualizedStats\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    ContextualizedStats.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return ContextualizedStats;\n})();\n\nexport const TracesAndStats = $root.TracesAndStats = (() => {\n\n    /**\n     * Properties of a TracesAndStats.\n     * @exports ITracesAndStats\n     * @interface ITracesAndStats\n     * @property {Array.<ITrace|Uint8Array>|null} [trace] TracesAndStats trace\n     * @property {$protobuf.ToArray.<IContextualizedStats>|Array.<IContextualizedStats>|null} [statsWithContext] TracesAndStats statsWithContext\n     * @property {Object.<string,IReferencedFieldsForType>|null} [referencedFieldsByType] TracesAndStats referencedFieldsByType\n     * @property {Array.<ITrace|Uint8Array>|null} [internalTracesContributingToStats] TracesAndStats internalTracesContributingToStats\n     */\n\n    /**\n     * Constructs a new TracesAndStats.\n     * @exports TracesAndStats\n     * @classdesc Represents a TracesAndStats.\n     * @implements ITracesAndStats\n     * @constructor\n     * @param {ITracesAndStats=} [properties] Properties to set\n     */\n    function TracesAndStats(properties) {\n        this.trace = [];\n        this.statsWithContext = [];\n        this.referencedFieldsByType = {};\n        this.internalTracesContributingToStats = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * TracesAndStats trace.\n     * @member {Array.<ITrace|Uint8Array>} trace\n     * @memberof TracesAndStats\n     * @instance\n     */\n    TracesAndStats.prototype.trace = $util.emptyArray;\n\n    /**\n     * TracesAndStats statsWithContext.\n     * @member {Array.<IContextualizedStats>} statsWithContext\n     * @memberof TracesAndStats\n     * @instance\n     */\n    TracesAndStats.prototype.statsWithContext = $util.emptyArray;\n\n    /**\n     * TracesAndStats referencedFieldsByType.\n     * @member {Object.<string,IReferencedFieldsForType>} referencedFieldsByType\n     * @memberof TracesAndStats\n     * @instance\n     */\n    TracesAndStats.prototype.referencedFieldsByType = $util.emptyObject;\n\n    /**\n     * TracesAndStats internalTracesContributingToStats.\n     * @member {Array.<ITrace|Uint8Array>} internalTracesContributingToStats\n     * @memberof TracesAndStats\n     * @instance\n     */\n    TracesAndStats.prototype.internalTracesContributingToStats = $util.emptyArray;\n\n    /**\n     * Creates a new TracesAndStats instance using the specified properties.\n     * @function create\n     * @memberof TracesAndStats\n     * @static\n     * @param {ITracesAndStats=} [properties] Properties to set\n     * @returns {TracesAndStats} TracesAndStats instance\n     */\n    TracesAndStats.create = function create(properties) {\n        return new TracesAndStats(properties);\n    };\n\n    /**\n     * Encodes the specified TracesAndStats message. Does not implicitly {@link TracesAndStats.verify|verify} messages.\n     * @function encode\n     * @memberof TracesAndStats\n     * @static\n     * @param {ITracesAndStats} message TracesAndStats message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    TracesAndStats.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.trace != null && message.trace.length)\n            for (let i = 0; i < message.trace.length; ++i)\n                if (message.trace[i] instanceof Uint8Array) {\n                    writer.uint32(/* id 1, wireType 2 =*/10);\n                    writer.bytes(message.trace[i]);\n                } else\n                    $root.Trace.encode(message.trace[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n        let array2;\n        if (message.statsWithContext != null && message.statsWithContext.toArray)\n            array2 = message.statsWithContext.toArray();\n        else\n            array2 = message.statsWithContext;\n        if (array2 != null && array2.length)\n            for (let i = 0; i < array2.length; ++i)\n                $root.ContextualizedStats.encode(array2[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n        if (message.internalTracesContributingToStats != null && message.internalTracesContributingToStats.length)\n            for (let i = 0; i < message.internalTracesContributingToStats.length; ++i)\n                if (message.internalTracesContributingToStats[i] instanceof Uint8Array) {\n                    writer.uint32(/* id 3, wireType 2 =*/26);\n                    writer.bytes(message.internalTracesContributingToStats[i]);\n                } else\n                    $root.Trace.encode(message.internalTracesContributingToStats[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n        if (message.referencedFieldsByType != null && Object.hasOwnProperty.call(message, \"referencedFieldsByType\"))\n            for (let keys = Object.keys(message.referencedFieldsByType), i = 0; i < keys.length; ++i) {\n                writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);\n                $root.ReferencedFieldsForType.encode(message.referencedFieldsByType[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();\n            }\n        return writer;\n    };\n\n    /**\n     * Encodes the specified TracesAndStats message, length delimited. Does not implicitly {@link TracesAndStats.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof TracesAndStats\n     * @static\n     * @param {ITracesAndStats} message TracesAndStats message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    TracesAndStats.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a TracesAndStats message from the specified reader or buffer.\n     * @function decode\n     * @memberof TracesAndStats\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {TracesAndStats} TracesAndStats\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    TracesAndStats.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.TracesAndStats(), key;\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                if (!(message.trace && message.trace.length))\n                    message.trace = [];\n                message.trace.push($root.Trace.decode(reader, reader.uint32()));\n                break;\n            case 2:\n                if (!(message.statsWithContext && message.statsWithContext.length))\n                    message.statsWithContext = [];\n                message.statsWithContext.push($root.ContextualizedStats.decode(reader, reader.uint32()));\n                break;\n            case 4:\n                reader.skip().pos++;\n                if (message.referencedFieldsByType === $util.emptyObject)\n                    message.referencedFieldsByType = {};\n                key = reader.string();\n                reader.pos++;\n                message.referencedFieldsByType[key] = $root.ReferencedFieldsForType.decode(reader, reader.uint32());\n                break;\n            case 3:\n                if (!(message.internalTracesContributingToStats && message.internalTracesContributingToStats.length))\n                    message.internalTracesContributingToStats = [];\n                message.internalTracesContributingToStats.push($root.Trace.decode(reader, reader.uint32()));\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a TracesAndStats message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof TracesAndStats\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {TracesAndStats} TracesAndStats\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    TracesAndStats.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a TracesAndStats message.\n     * @function verify\n     * @memberof TracesAndStats\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    TracesAndStats.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.trace != null && message.hasOwnProperty(\"trace\")) {\n            if (!Array.isArray(message.trace))\n                return \"trace: array expected\";\n            for (let i = 0; i < message.trace.length; ++i)\n                if (!(message.trace[i] instanceof Uint8Array)) {\n                    let error = $root.Trace.verify(message.trace[i]);\n                    if (error)\n                        return \"trace.\" + error;\n                }\n        }\n        if (message.statsWithContext != null && message.hasOwnProperty(\"statsWithContext\")) {\n            let array2;\n            if (message.statsWithContext != null && message.statsWithContext.toArray)\n                array2 = message.statsWithContext.toArray();\n            else\n                array2 = message.statsWithContext;\n            if (!Array.isArray(array2))\n                return \"statsWithContext: array expected\";\n            for (let i = 0; i < array2.length; ++i) {\n                let error = $root.ContextualizedStats.verify(array2[i]);\n                if (error)\n                    return \"statsWithContext.\" + error;\n            }\n        }\n        if (message.referencedFieldsByType != null && message.hasOwnProperty(\"referencedFieldsByType\")) {\n            if (!$util.isObject(message.referencedFieldsByType))\n                return \"referencedFieldsByType: object expected\";\n            let key = Object.keys(message.referencedFieldsByType);\n            for (let i = 0; i < key.length; ++i) {\n                let error = $root.ReferencedFieldsForType.verify(message.referencedFieldsByType[key[i]]);\n                if (error)\n                    return \"referencedFieldsByType.\" + error;\n            }\n        }\n        if (message.internalTracesContributingToStats != null && message.hasOwnProperty(\"internalTracesContributingToStats\")) {\n            if (!Array.isArray(message.internalTracesContributingToStats))\n                return \"internalTracesContributingToStats: array expected\";\n            for (let i = 0; i < message.internalTracesContributingToStats.length; ++i)\n                if (!(message.internalTracesContributingToStats[i] instanceof Uint8Array)) {\n                    let error = $root.Trace.verify(message.internalTracesContributingToStats[i]);\n                    if (error)\n                        return \"internalTracesContributingToStats.\" + error;\n                }\n        }\n        return null;\n    };\n\n    /**\n     * Creates a plain object from a TracesAndStats message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof TracesAndStats\n     * @static\n     * @param {TracesAndStats} message TracesAndStats\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    TracesAndStats.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        let object = {};\n        if (options.arrays || options.defaults) {\n            object.trace = [];\n            object.statsWithContext = [];\n            object.internalTracesContributingToStats = [];\n        }\n        if (options.objects || options.defaults)\n            object.referencedFieldsByType = {};\n        if (message.trace && message.trace.length) {\n            object.trace = [];\n            for (let j = 0; j < message.trace.length; ++j)\n                object.trace[j] = $root.Trace.toObject(message.trace[j], options);\n        }\n        if (message.statsWithContext && message.statsWithContext.length) {\n            object.statsWithContext = [];\n            for (let j = 0; j < message.statsWithContext.length; ++j)\n                object.statsWithContext[j] = $root.ContextualizedStats.toObject(message.statsWithContext[j], options);\n        }\n        if (message.internalTracesContributingToStats && message.internalTracesContributingToStats.length) {\n            object.internalTracesContributingToStats = [];\n            for (let j = 0; j < message.internalTracesContributingToStats.length; ++j)\n                object.internalTracesContributingToStats[j] = $root.Trace.toObject(message.internalTracesContributingToStats[j], options);\n        }\n        let keys2;\n        if (message.referencedFieldsByType && (keys2 = Object.keys(message.referencedFieldsByType)).length) {\n            object.referencedFieldsByType = {};\n            for (let j = 0; j < keys2.length; ++j)\n                object.referencedFieldsByType[keys2[j]] = $root.ReferencedFieldsForType.toObject(message.referencedFieldsByType[keys2[j]], options);\n        }\n        return object;\n    };\n\n    /**\n     * Converts this TracesAndStats to JSON.\n     * @function toJSON\n     * @memberof TracesAndStats\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    TracesAndStats.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return TracesAndStats;\n})();\n\nexport const google = $root.google = (() => {\n\n    /**\n     * Namespace google.\n     * @exports google\n     * @namespace\n     */\n    const google = {};\n\n    google.protobuf = (function() {\n\n        /**\n         * Namespace protobuf.\n         * @memberof google\n         * @namespace\n         */\n        const protobuf = {};\n\n        protobuf.Timestamp = (function() {\n\n            /**\n             * Properties of a Timestamp.\n             * @memberof google.protobuf\n             * @interface ITimestamp\n             * @property {number|null} [seconds] Timestamp seconds\n             * @property {number|null} [nanos] Timestamp nanos\n             */\n\n            /**\n             * Constructs a new Timestamp.\n             * @memberof google.protobuf\n             * @classdesc Represents a Timestamp.\n             * @implements ITimestamp\n             * @constructor\n             * @param {google.protobuf.ITimestamp=} [properties] Properties to set\n             */\n            function Timestamp(properties) {\n                if (properties)\n                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n\n            /**\n             * Timestamp seconds.\n             * @member {number} seconds\n             * @memberof google.protobuf.Timestamp\n             * @instance\n             */\n            Timestamp.prototype.seconds = 0;\n\n            /**\n             * Timestamp nanos.\n             * @member {number} nanos\n             * @memberof google.protobuf.Timestamp\n             * @instance\n             */\n            Timestamp.prototype.nanos = 0;\n\n            /**\n             * Creates a new Timestamp instance using the specified properties.\n             * @function create\n             * @memberof google.protobuf.Timestamp\n             * @static\n             * @param {google.protobuf.ITimestamp=} [properties] Properties to set\n             * @returns {google.protobuf.Timestamp} Timestamp instance\n             */\n            Timestamp.create = function create(properties) {\n                return new Timestamp(properties);\n            };\n\n            /**\n             * Encodes the specified Timestamp message. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.\n             * @function encode\n             * @memberof google.protobuf.Timestamp\n             * @static\n             * @param {google.protobuf.ITimestamp} message Timestamp message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Timestamp.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.seconds != null && Object.hasOwnProperty.call(message, \"seconds\"))\n                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.seconds);\n                if (message.nanos != null && Object.hasOwnProperty.call(message, \"nanos\"))\n                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.nanos);\n                return writer;\n            };\n\n            /**\n             * Encodes the specified Timestamp message, length delimited. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof google.protobuf.Timestamp\n             * @static\n             * @param {google.protobuf.ITimestamp} message Timestamp message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Timestamp.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n\n            /**\n             * Decodes a Timestamp message from the specified reader or buffer.\n             * @function decode\n             * @memberof google.protobuf.Timestamp\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {google.protobuf.Timestamp} Timestamp\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Timestamp.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Timestamp();\n                while (reader.pos < end) {\n                    let tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.seconds = reader.int64();\n                        break;\n                    case 2:\n                        message.nanos = reader.int32();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n\n            /**\n             * Decodes a Timestamp message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof google.protobuf.Timestamp\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {google.protobuf.Timestamp} Timestamp\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Timestamp.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n\n            /**\n             * Verifies a Timestamp message.\n             * @function verify\n             * @memberof google.protobuf.Timestamp\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            Timestamp.verify = function verify(message) {\n                if (typeof message !== \"object\" || message === null)\n                    return \"object expected\";\n                if (message.seconds != null && message.hasOwnProperty(\"seconds\"))\n                    if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high)))\n                        return \"seconds: integer|Long expected\";\n                if (message.nanos != null && message.hasOwnProperty(\"nanos\"))\n                    if (!$util.isInteger(message.nanos))\n                        return \"nanos: integer expected\";\n                return null;\n            };\n\n            /**\n             * Creates a plain object from a Timestamp message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof google.protobuf.Timestamp\n             * @static\n             * @param {google.protobuf.Timestamp} message Timestamp\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            Timestamp.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                let object = {};\n                if (options.defaults) {\n                    object.seconds = 0;\n                    object.nanos = 0;\n                }\n                if (message.seconds != null && message.hasOwnProperty(\"seconds\"))\n                    if (typeof message.seconds === \"number\")\n                        object.seconds = options.longs === String ? String(message.seconds) : message.seconds;\n                    else\n                        object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message.seconds) : options.longs === Number ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber() : message.seconds;\n                if (message.nanos != null && message.hasOwnProperty(\"nanos\"))\n                    object.nanos = message.nanos;\n                return object;\n            };\n\n            /**\n             * Converts this Timestamp to JSON.\n             * @function toJSON\n             * @memberof google.protobuf.Timestamp\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            Timestamp.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return Timestamp;\n        })();\n\n        return protobuf;\n    })();\n\n    return google;\n})();\n\nexport { $root as default };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 6603, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@apollo/server/dist/esm/plugin/traceTreeBuilder.js","sources":["file:///E:/wark/Next.graphQL/nextTyar/node_modules/%40apollo/server/src/plugin/traceTreeBuilder.ts"],"sourcesContent":["// This class is a helper for ApolloServerPluginUsageReporting and\n// ApolloServerPluginInlineTrace.\nimport {\n  GraphQLError,\n  type GraphQLResolveInfo,\n  type ResponsePath,\n} from 'graphql';\nimport { Trace, google } from '@apollo/usage-reporting-protobuf';\nimport type { SendErrorsOptions } from './usageReporting';\nimport { UnreachableCaseError } from '../utils/UnreachableCaseError.js';\n\nfunction internalError(message: string) {\n  return new Error(`[internal apollo-server error] ${message}`);\n}\n\nexport class TraceTreeBuilder {\n  private rootNode = new Trace.Node();\n  public trace = new Trace({\n    root: this.rootNode,\n    // By default, each trace counts as one operation for the sake of field\n    // execution counts. If we end up calling the fieldLevelInstrumentation\n    // callback (once we've successfully resolved the operation) then we\n    // may set this to a higher number; but we'll start it at 1 so that traces\n    // that don't successfully resolve the operation (eg parse failures) or\n    // where we don't call the callback because a plugin set captureTraces to\n    // true have a reasonable default.\n    fieldExecutionWeight: 1,\n  });\n  public startHrTime?: [number, number];\n  private stopped = false;\n  private nodes = new Map<string, Trace.Node>([\n    [responsePathAsString(), this.rootNode],\n  ]);\n  private readonly transformError:\n    | ((err: GraphQLError) => GraphQLError | null)\n    | null;\n\n  public constructor(options: {\n    maskedBy: string;\n    sendErrors?: SendErrorsOptions;\n  }) {\n    const { sendErrors, maskedBy } = options;\n    if (!sendErrors || 'masked' in sendErrors) {\n      this.transformError = () =>\n        new GraphQLError('<masked>', {\n          extensions: { maskedBy },\n        });\n    } else if ('transform' in sendErrors) {\n      this.transformError = sendErrors.transform;\n    } else if ('unmodified' in sendErrors) {\n      this.transformError = null;\n    } else {\n      throw new UnreachableCaseError(sendErrors);\n    }\n  }\n\n  public startTiming() {\n    if (this.startHrTime) {\n      throw internalError('startTiming called twice!');\n    }\n    if (this.stopped) {\n      throw internalError('startTiming called after stopTiming!');\n    }\n    this.trace.startTime = dateToProtoTimestamp(new Date());\n    this.startHrTime = process.hrtime();\n  }\n\n  public stopTiming() {\n    if (!this.startHrTime) {\n      throw internalError('stopTiming called before startTiming!');\n    }\n    if (this.stopped) {\n      throw internalError('stopTiming called twice!');\n    }\n\n    this.trace.durationNs = durationHrTimeToNanos(\n      process.hrtime(this.startHrTime),\n    );\n    this.trace.endTime = dateToProtoTimestamp(new Date());\n    this.stopped = true;\n  }\n\n  public willResolveField(info: GraphQLResolveInfo): () => void {\n    if (!this.startHrTime) {\n      throw internalError('willResolveField called before startTiming!');\n    }\n    if (this.stopped) {\n      // We've been stopped, which means execution is done... and yet we're\n      // still resolving more fields? How can that be? Shouldn't we throw an\n      // error or something?\n      //\n      // Well... we used to do exactly that. But this \"shouldn't happen\" error\n      // showed up in practice! Turns out that graphql-js can actually continue\n      // to execute more fields indefinitely long after `execute()` resolves!\n      // That's because parallelism on a selection set is implemented using\n      // `Promise.all`, and as soon as one of its arguments (ie, one field)\n      // throws an error, the combined Promise resolves, but there's no\n      // \"cancellation\" of the Promises that are the other arguments to\n      // `Promise.all`. So the code contributing to those Promises keeps on\n      // chugging away indefinitely.\n      //\n      // Concrete example: lets say you have\n      //\n      //    { x y { ARBITRARY_SELECTION_SET } }\n      //\n      // where x has a non-null return type, and x and y both have resolvers\n      // that return Promises. And lets say that x returns a Promise that\n      // rejects (or resolves to null). What this means is that were going to\n      // eventually end up with `data: null` (nothing under y will actually\n      // matter), but graphql-js execution will continue running whatever is\n      // under ARBITRARY_SELECTION_SET without any sort of short circuiting. In\n      // fact, the Promise returned from execute itself can happily resolve\n      // while execution is still chugging away on an arbitrary amount of fields\n      // under that ARBITRARY_SELECTION_SET. Theres no way to detect from the\n      // outside \"all the execution related to this operation is done\", nor to\n      // \"short-circuit\" execution so that it stops going.\n      //\n      // So, um. We will record any field whose execution we manage to observe\n      // before we \"stop\" the TraceTreeBuilder (whether it is one that actually\n      // ends up in the response or whether it gets thrown away due to null\n      // bubbling), but if we get any more fields afterwards, we just ignore\n      // them rather than throwing a confusing error.\n      //\n      // (That said, the error we used to throw here generally was hidden\n      // anyway, for the same reason: it comes from a branch of execution that\n      // ends up not being included in the response. But\n      // https://github.com/graphql/graphql-js/pull/3529 means that this\n      // sometimes crashed execution anyway. Our error never caught any actual\n      // problematic cases, so keeping it around doesn't really help.)\n      return () => {};\n    }\n\n    const path = info.path;\n    const node = this.newNode(path);\n    node.type = info.returnType.toString();\n    node.parentType = info.parentType.toString();\n    node.startTime = durationHrTimeToNanos(process.hrtime(this.startHrTime));\n    if (typeof path.key === 'string' && path.key !== info.fieldName) {\n      // This field was aliased; send the original field name too (for FieldStats).\n      node.originalFieldName = info.fieldName;\n    }\n\n    return () => {\n      node.endTime = durationHrTimeToNanos(process.hrtime(this.startHrTime));\n    };\n  }\n\n  public didEncounterErrors(errors: readonly GraphQLError[]) {\n    errors.forEach((err) => {\n      // This is an error from a federated service. We will already be reporting\n      // it in the nested Trace in the query plan.\n      //\n      // XXX This probably shouldn't skip query or validation errors, which are\n      //      not in nested Traces because format() isn't called in this case! Or\n      //      maybe format() should be called in that case?\n      if (err.extensions?.serviceName) {\n        return;\n      }\n\n      // In terms of reporting, errors can be re-written by the user by\n      // utilizing the `transformError` parameter.  This allows changing\n      // the message or stack to remove potentially sensitive information.\n      // Returning `null` will result in the error not being reported at all.\n      const errorForReporting = this.transformAndNormalizeError(err);\n\n      if (errorForReporting === null) {\n        return;\n      }\n\n      this.addProtobufError(\n        errorForReporting.path,\n        errorToProtobufError(errorForReporting),\n      );\n    });\n  }\n\n  private addProtobufError(\n    path: ReadonlyArray<string | number> | undefined,\n    error: Trace.Error,\n  ) {\n    if (!this.startHrTime) {\n      throw internalError('addProtobufError called before startTiming!');\n    }\n    if (this.stopped) {\n      throw internalError('addProtobufError called after stopTiming!');\n    }\n\n    // By default, put errors on the root node.\n    let node = this.rootNode;\n    // If a non-GraphQLError Error sneaks in here somehow with a non-array\n    // path, don't crash.\n    if (Array.isArray(path)) {\n      const specificNode = this.nodes.get(path.join('.'));\n      if (specificNode) {\n        node = specificNode;\n      } else {\n        const responsePath = responsePathFromArray(path, this.rootNode);\n        if (!responsePath) {\n          throw internalError('addProtobufError called with invalid path!');\n        }\n        node = this.newNode(responsePath);\n      }\n    }\n\n    node.error.push(error);\n  }\n\n  private newNode(path: ResponsePath): Trace.Node {\n    const node = new Trace.Node();\n    const id = path.key;\n    if (typeof id === 'number') {\n      node.index = id;\n    } else {\n      node.responseName = id;\n    }\n    this.nodes.set(responsePathAsString(path), node);\n    const parentNode = this.ensureParentNode(path);\n    parentNode.child.push(node);\n    return node;\n  }\n\n  private ensureParentNode(path: ResponsePath): Trace.Node {\n    const parentPath = responsePathAsString(path.prev);\n    const parentNode = this.nodes.get(parentPath);\n    if (parentNode) {\n      return parentNode;\n    }\n    // Because we set up the root path when creating this.nodes, we now know\n    // that path.prev isn't undefined.\n    return this.newNode(path.prev!);\n  }\n\n  private transformAndNormalizeError(err: GraphQLError): GraphQLError | null {\n    if (this.transformError) {\n      // Before passing the error to the user-provided `transformError` function,\n      // we'll make a shadow copy of the error so the user is free to change\n      // the object as they see fit.\n\n      // At this stage, this error is only for the purposes of reporting, but\n      // this is even more important since this is still a reference to the\n      // original error object and changing it would also change the error which\n      // is returned in the response to the client.\n\n      // For the clone, we'll create a new object which utilizes the exact same\n      // prototype of the error being reported.\n      const clonedError = Object.assign(\n        Object.create(Object.getPrototypeOf(err)),\n        err,\n      );\n\n      const rewrittenError = this.transformError(clonedError);\n\n      // Returning an explicit `null` means the user is requesting that the error\n      // not be reported to Apollo.\n      if (rewrittenError === null) {\n        return null;\n      }\n\n      // We don't want users to be inadvertently not reporting errors, so if\n      // they haven't returned an explicit `GraphQLError` (or `null`, handled\n      // above), then we'll report the error as usual.\n      if (!(rewrittenError instanceof GraphQLError)) {\n        return err;\n      }\n\n      // We only allow transformError to change the message and extensions of the\n      // error; we keep everything else the same. That way people don't have to\n      // do extra work to keep the error on the same trace node. We also keep\n      // extensions the same if it isn't explicitly changed (to, eg, {}). (Note\n      // that many of the fields of GraphQLError are not enumerable and won't\n      // show up in the trace (even in the json field) anyway.)\n      return new GraphQLError(rewrittenError.message, {\n        nodes: err.nodes,\n        source: err.source,\n        positions: err.positions,\n        path: err.path,\n        originalError: err.originalError,\n        extensions: rewrittenError.extensions || err.extensions,\n      });\n    }\n    return err;\n  }\n}\n\n// Converts an hrtime array (as returned from process.hrtime) to nanoseconds.\n//\n// ONLY CALL THIS ON VALUES REPRESENTING DELTAS, NOT ON THE RAW RETURN VALUE\n// FROM process.hrtime() WITH NO ARGUMENTS.\n//\n// The entire point of the hrtime data structure is that the JavaScript Number\n// type can't represent all int64 values without loss of precision:\n// Number.MAX_SAFE_INTEGER nanoseconds is about 104 days. Calling this function\n// on a duration that represents a value less than 104 days is fine. Calling\n// this function on an absolute time (which is generally roughly time since\n// system boot) is not a good idea.\n//\n// XXX We should probably use google.protobuf.Duration on the wire instead of\n// ever trying to store durations in a single number.\nfunction durationHrTimeToNanos(hrtime: [number, number]) {\n  return hrtime[0] * 1e9 + hrtime[1];\n}\n\n// Convert from the linked-list ResponsePath format to a dot-joined\n// string. Includes the full path (field names and array indices).\nfunction responsePathAsString(p?: ResponsePath): string {\n  if (p === undefined) {\n    return '';\n  }\n\n  // A previous implementation used `responsePathAsArray` from `graphql-js/execution`,\n  // however, that employed an approach that created new arrays unnecessarily.\n  let res = String(p.key);\n\n  while ((p = p.prev) !== undefined) {\n    res = `${p.key}.${res}`;\n  }\n\n  return res;\n}\n\nfunction responsePathFromArray(\n  path: ReadonlyArray<string | number>,\n  node: Trace.Node,\n): ResponsePath | undefined {\n  let responsePath: ResponsePath | undefined;\n  let nodePtr: Trace.INode | undefined = node;\n  for (const key of path) {\n    nodePtr = nodePtr?.child?.find((child) => child.responseName === key);\n    responsePath = {\n      key,\n      prev: responsePath,\n      typename: nodePtr?.type ?? undefined,\n    };\n  }\n  return responsePath;\n}\n\nfunction errorToProtobufError(error: GraphQLError): Trace.Error {\n  return new Trace.Error({\n    message: error.message,\n    location: (error.locations || []).map(\n      ({ line, column }) => new Trace.Location({ line, column }),\n    ),\n    json: JSON.stringify(error),\n  });\n}\n\n// Converts a JS Date into a Timestamp.\nexport function dateToProtoTimestamp(date: Date): google.protobuf.Timestamp {\n  const totalMillis = +date;\n  const millis = totalMillis % 1000;\n  return new google.protobuf.Timestamp({\n    seconds: (totalMillis - millis) / 1000,\n    nanos: millis * 1e6,\n  });\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 6814, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@apollo/server/node_modules/lru-cache/dist/esm/index.js","sources":["file:///E:/wark/Next.graphQL/nextTyar/node_modules/%40apollo/server/node_modules/lru-cache/src/index.ts"],"sourcesContent":["/**\n * @module LRUCache\n */\n\n// module-private names and types\n// this provides the default Perf object source.\n// it can be passed in via configuration to override it\n// for a single LRU object.\nexport type Perf = { now: () => number }\nconst defaultPerf: Perf =\n  (\n    typeof performance === 'object' &&\n    performance &&\n    typeof performance.now === 'function'\n  ) ?\n    performance\n  : Date\n\nconst warned = new Set<string>()\n\n// either a function or a class\ntype ForC = ((...a: any[]) => any) | { new (...a: any[]): any }\n\n/* c8 ignore start */\nconst PROCESS = (\n  typeof process === 'object' && !!process ?\n    process\n  : {}) as { [k: string]: any }\n/* c8 ignore start */\n\nconst emitWarning = (\n  msg: string,\n  type: string,\n  code: string,\n  fn: ForC,\n) => {\n  typeof PROCESS.emitWarning === 'function' ?\n    PROCESS.emitWarning(msg, type, code, fn)\n  : console.error(`[${code}] ${type}: ${msg}`)\n}\n\nlet AC = globalThis.AbortController\nlet AS = globalThis.AbortSignal\n\n/* c8 ignore start */\nif (typeof AC === 'undefined') {\n  //@ts-ignore\n  AS = class AbortSignal {\n    onabort?: (...a: any[]) => any\n    _onabort: ((...a: any[]) => any)[] = []\n    reason?: any\n    aborted: boolean = false\n    addEventListener(_: string, fn: (...a: any[]) => any) {\n      this._onabort.push(fn)\n    }\n  }\n  //@ts-ignore\n  AC = class AbortController {\n    constructor() {\n      warnACPolyfill()\n    }\n    signal = new AS()\n    abort(reason: any) {\n      if (this.signal.aborted) return\n      //@ts-ignore\n      this.signal.reason = reason\n      //@ts-ignore\n      this.signal.aborted = true\n      //@ts-ignore\n      for (const fn of this.signal._onabort) {\n        fn(reason)\n      }\n      this.signal.onabort?.(reason)\n    }\n  }\n  let printACPolyfillWarning =\n    PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1'\n  const warnACPolyfill = () => {\n    if (!printACPolyfillWarning) return\n    printACPolyfillWarning = false\n    emitWarning(\n      'AbortController is not defined. If using lru-cache in ' +\n        'node 14, load an AbortController polyfill from the ' +\n        '`node-abort-controller` package. A minimal polyfill is ' +\n        'provided for use by LRUCache.fetch(), but it should not be ' +\n        'relied upon in other contexts (eg, passing it to other APIs that ' +\n        'use AbortController/AbortSignal might have undesirable effects). ' +\n        'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.',\n      'NO_ABORT_CONTROLLER',\n      'ENOTSUP',\n      warnACPolyfill,\n    )\n  }\n}\n/* c8 ignore stop */\n\nconst shouldWarn = (code: string) => !warned.has(code)\n\nconst TYPE = Symbol('type')\nexport type PosInt = number & { [TYPE]: 'Positive Integer' }\nexport type Index = number & { [TYPE]: 'LRUCache Index' }\n\nconst isPosInt = (n: any): n is PosInt =>\n  n && n === Math.floor(n) && n > 0 && isFinite(n)\n\nexport type UintArray = Uint8Array | Uint16Array | Uint32Array\nexport type NumberArray = UintArray | number[]\n\n/* c8 ignore start */\n// This is a little bit ridiculous, tbh.\n// The maximum array length is 2^32-1 or thereabouts on most JS impls.\n// And well before that point, you're caching the entire world, I mean,\n// that's ~32GB of just integers for the next/prev links, plus whatever\n// else to hold that many keys and values.  Just filling the memory with\n// zeroes at init time is brutal when you get that big.\n// But why not be complete?\n// Maybe in the future, these limits will have expanded.\nconst getUintArray = (max: number) =>\n  !isPosInt(max) ? null\n  : max <= Math.pow(2, 8) ? Uint8Array\n  : max <= Math.pow(2, 16) ? Uint16Array\n  : max <= Math.pow(2, 32) ? Uint32Array\n  : max <= Number.MAX_SAFE_INTEGER ? ZeroArray\n  : null\n/* c8 ignore stop */\n\nclass ZeroArray extends Array<number> {\n  constructor(size: number) {\n    super(size)\n    this.fill(0)\n  }\n}\nexport type { ZeroArray }\nexport type { Stack }\n\nexport type StackLike = Stack | Index[]\nclass Stack {\n  heap: NumberArray\n  length: number\n  // private constructor\n  static #constructing: boolean = false\n  static create(max: number): StackLike {\n    const HeapCls = getUintArray(max)\n    if (!HeapCls) return []\n    Stack.#constructing = true\n    const s = new Stack(max, HeapCls)\n    Stack.#constructing = false\n    return s\n  }\n  constructor(max: number, HeapCls: { new (n: number): NumberArray }) {\n    /* c8 ignore start */\n    if (!Stack.#constructing) {\n      throw new TypeError('instantiate Stack using Stack.create(n)')\n    }\n    /* c8 ignore stop */\n    this.heap = new HeapCls(max)\n    this.length = 0\n  }\n  push(n: Index) {\n    this.heap[this.length++] = n\n  }\n  pop(): Index {\n    return this.heap[--this.length] as Index\n  }\n}\n\n/**\n * Promise representing an in-progress {@link LRUCache#fetch} call\n */\nexport type BackgroundFetch<V> = Promise<V | undefined> & {\n  __returned: BackgroundFetch<V> | undefined\n  __abortController: AbortController\n  __staleWhileFetching: V | undefined\n}\n\nexport type DisposeTask<K, V> = [\n  value: V,\n  key: K,\n  reason: LRUCache.DisposeReason,\n]\n\nexport namespace LRUCache {\n  /**\n   * An integer greater than 0, reflecting the calculated size of items\n   */\n  export type Size = number\n\n  /**\n   * Integer greater than 0, representing some number of milliseconds, or the\n   * time at which a TTL started counting from.\n   */\n  export type Milliseconds = number\n\n  /**\n   * An integer greater than 0, reflecting a number of items\n   */\n  export type Count = number\n\n  /**\n   * The reason why an item was removed from the cache, passed\n   * to the {@link Disposer} methods.\n   *\n   * - `evict`: The item was evicted because it is the least recently used,\n   *   and the cache is full.\n   * - `set`: A new value was set, overwriting the old value being disposed.\n   * - `delete`: The item was explicitly deleted, either by calling\n   *   {@link LRUCache#delete}, {@link LRUCache#clear}, or\n   *   {@link LRUCache#set} with an undefined value.\n   * - `expire`: The item was removed due to exceeding its TTL.\n   * - `fetch`: A {@link OptionsBase#fetchMethod} operation returned\n   *   `undefined` or was aborted, causing the item to be deleted.\n   */\n  export type DisposeReason =\n    | 'evict'\n    | 'set'\n    | 'delete'\n    | 'expire'\n    | 'fetch'\n  /**\n   * A method called upon item removal, passed as the\n   * {@link OptionsBase.dispose} and/or\n   * {@link OptionsBase.disposeAfter} options.\n   */\n  export type Disposer<K, V> = (\n    value: V,\n    key: K,\n    reason: DisposeReason,\n  ) => void\n\n  /**\n   * The reason why an item was added to the cache, passed\n   * to the {@link Inserter} methods.\n   *\n   * - `add`: the item was not found in the cache, and was added\n   * - `update`: the item was in the cache, with the same value provided\n   * - `replace`: the item was in the cache, and replaced\n   */\n  export type InsertReason = 'add' | 'update' | 'replace'\n\n  /**\n   * A method called upon item insertion, passed as the\n   * {@link OptionsBase.insert}\n   */\n  export type Inserter<K, V> = (\n    value: V,\n    key: K,\n    reason: InsertReason,\n  ) => void\n\n  /**\n   * A function that returns the effective calculated size\n   * of an entry in the cache.\n   */\n  export type SizeCalculator<K, V> = (value: V, key: K) => Size\n\n  /**\n   * Options provided to the\n   * {@link OptionsBase.fetchMethod} function.\n   */\n  export interface FetcherOptions<K, V, FC = unknown> {\n    signal: AbortSignal\n    options: FetcherFetchOptions<K, V, FC>\n    /**\n     * Object provided in the {@link FetchOptions.context} option to\n     * {@link LRUCache#fetch}\n     */\n    context: FC\n  }\n\n  /**\n   * Occasionally, it may be useful to track the internal behavior of the\n   * cache, particularly for logging, debugging, or for behavior within the\n   * `fetchMethod`. To do this, you can pass a `status` object to the\n   * {@link LRUCache#fetch}, {@link LRUCache#get}, {@link LRUCache#set},\n   * {@link LRUCache#memo}, and {@link LRUCache#has} methods.\n   *\n   * The `status` option should be a plain JavaScript object. The following\n   * fields will be set on it appropriately, depending on the situation.\n   */\n  export interface Status<V> {\n    /**\n     * The status of a set() operation.\n     *\n     * - add: the item was not found in the cache, and was added\n     * - update: the item was in the cache, with the same value provided\n     * - replace: the item was in the cache, and replaced\n     * - miss: the item was not added to the cache for some reason\n     */\n    set?: 'add' | 'update' | 'replace' | 'miss'\n\n    /**\n     * the ttl stored for the item, or undefined if ttls are not used.\n     */\n    ttl?: Milliseconds\n\n    /**\n     * the start time for the item, or undefined if ttls are not used.\n     */\n    start?: Milliseconds\n\n    /**\n     * The timestamp used for TTL calculation\n     */\n    now?: Milliseconds\n\n    /**\n     * the remaining ttl for the item, or undefined if ttls are not used.\n     */\n    remainingTTL?: Milliseconds\n\n    /**\n     * The calculated size for the item, if sizes are used.\n     */\n    entrySize?: Size\n\n    /**\n     * The total calculated size of the cache, if sizes are used.\n     */\n    totalCalculatedSize?: Size\n\n    /**\n     * A flag indicating that the item was not stored, due to exceeding the\n     * {@link OptionsBase.maxEntrySize}\n     */\n    maxEntrySizeExceeded?: true\n\n    /**\n     * The old value, specified in the case of `set:'update'` or\n     * `set:'replace'`\n     */\n    oldValue?: V\n\n    /**\n     * The results of a {@link LRUCache#has} operation\n     *\n     * - hit: the item was found in the cache\n     * - stale: the item was found in the cache, but is stale\n     * - miss: the item was not found in the cache\n     */\n    has?: 'hit' | 'stale' | 'miss'\n\n    /**\n     * The status of a {@link LRUCache#fetch} operation.\n     * Note that this can change as the underlying fetch() moves through\n     * various states.\n     *\n     * - inflight: there is another fetch() for this key which is in process\n     * - get: there is no {@link OptionsBase.fetchMethod}, so\n     *   {@link LRUCache#get} was called.\n     * - miss: the item is not in cache, and will be fetched.\n     * - hit: the item is in the cache, and was resolved immediately.\n     * - stale: the item is in the cache, but stale.\n     * - refresh: the item is in the cache, and not stale, but\n     *   {@link FetchOptions.forceRefresh} was specified.\n     */\n    fetch?: 'get' | 'inflight' | 'miss' | 'hit' | 'stale' | 'refresh'\n\n    /**\n     * The {@link OptionsBase.fetchMethod} was called\n     */\n    fetchDispatched?: true\n\n    /**\n     * The cached value was updated after a successful call to\n     * {@link OptionsBase.fetchMethod}\n     */\n    fetchUpdated?: true\n\n    /**\n     * The reason for a fetch() rejection.  Either the error raised by the\n     * {@link OptionsBase.fetchMethod}, or the reason for an\n     * AbortSignal.\n     */\n    fetchError?: Error\n\n    /**\n     * The fetch received an abort signal\n     */\n    fetchAborted?: true\n\n    /**\n     * The abort signal received was ignored, and the fetch was allowed to\n     * continue.\n     */\n    fetchAbortIgnored?: true\n\n    /**\n     * The fetchMethod promise resolved successfully\n     */\n    fetchResolved?: true\n\n    /**\n     * The fetchMethod promise was rejected\n     */\n    fetchRejected?: true\n\n    /**\n     * The status of a {@link LRUCache#get} operation.\n     *\n     * - fetching: The item is currently being fetched.  If a previous value\n     *   is present and allowed, that will be returned.\n     * - stale: The item is in the cache, and is stale.\n     * - hit: the item is in the cache\n     * - miss: the item is not in the cache\n     */\n    get?: 'stale' | 'hit' | 'miss'\n\n    /**\n     * A fetch or get operation returned a stale value.\n     */\n    returnedStale?: true\n  }\n\n  /**\n   * options which override the options set in the LRUCache constructor\n   * when calling {@link LRUCache#fetch}.\n   *\n   * This is the union of {@link GetOptions} and {@link SetOptions}, plus\n   * {@link OptionsBase.noDeleteOnFetchRejection},\n   * {@link OptionsBase.allowStaleOnFetchRejection},\n   * {@link FetchOptions.forceRefresh}, and\n   * {@link FetcherOptions.context}\n   *\n   * Any of these may be modified in the {@link OptionsBase.fetchMethod}\n   * function, but the {@link GetOptions} fields will of course have no\n   * effect, as the {@link LRUCache#get} call already happened by the time\n   * the fetchMethod is called.\n   */\n  export interface FetcherFetchOptions<K, V, FC = unknown>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      | 'allowStale'\n      | 'updateAgeOnGet'\n      | 'noDeleteOnStaleGet'\n      | 'sizeCalculation'\n      | 'ttl'\n      | 'noDisposeOnSet'\n      | 'noUpdateTTL'\n      | 'noDeleteOnFetchRejection'\n      | 'allowStaleOnFetchRejection'\n      | 'ignoreFetchAbort'\n      | 'allowStaleOnFetchAbort'\n    > {\n    status?: Status<V>\n    size?: Size\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#fetch} method.\n   */\n  export interface FetchOptions<K, V, FC>\n    extends FetcherFetchOptions<K, V, FC> {\n    /**\n     * Set to true to force a re-load of the existing data, even if it\n     * is not yet stale.\n     */\n    forceRefresh?: boolean\n    /**\n     * Context provided to the {@link OptionsBase.fetchMethod} as\n     * the {@link FetcherOptions.context} param.\n     *\n     * If the FC type is specified as unknown (the default),\n     * undefined or void, then this is optional.  Otherwise, it will\n     * be required.\n     */\n    context?: FC\n    signal?: AbortSignal\n    status?: Status<V>\n  }\n  /**\n   * Options provided to {@link LRUCache#fetch} when the FC type is something\n   * other than `unknown`, `undefined`, or `void`\n   */\n  export interface FetchOptionsWithContext<K, V, FC>\n    extends FetchOptions<K, V, FC> {\n    context: FC\n  }\n  /**\n   * Options provided to {@link LRUCache#fetch} when the FC type is\n   * `undefined` or `void`\n   */\n  export interface FetchOptionsNoContext<K, V>\n    extends FetchOptions<K, V, undefined> {\n    context?: undefined\n  }\n\n  export interface MemoOptions<K, V, FC = unknown>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      | 'allowStale'\n      | 'updateAgeOnGet'\n      | 'noDeleteOnStaleGet'\n      | 'sizeCalculation'\n      | 'ttl'\n      | 'noDisposeOnSet'\n      | 'noUpdateTTL'\n      | 'noDeleteOnFetchRejection'\n      | 'allowStaleOnFetchRejection'\n      | 'ignoreFetchAbort'\n      | 'allowStaleOnFetchAbort'\n    > {\n    /**\n     * Set to true to force a re-load of the existing data, even if it\n     * is not yet stale.\n     */\n    forceRefresh?: boolean\n    /**\n     * Context provided to the {@link OptionsBase.memoMethod} as\n     * the {@link MemoizerOptions.context} param.\n     *\n     * If the FC type is specified as unknown (the default),\n     * undefined or void, then this is optional.  Otherwise, it will\n     * be required.\n     */\n    context?: FC\n    status?: Status<V>\n  }\n  /**\n   * Options provided to {@link LRUCache#memo} when the FC type is something\n   * other than `unknown`, `undefined`, or `void`\n   */\n  export interface MemoOptionsWithContext<K, V, FC>\n    extends MemoOptions<K, V, FC> {\n    context: FC\n  }\n  /**\n   * Options provided to {@link LRUCache#memo} when the FC type is\n   * `undefined` or `void`\n   */\n  export interface MemoOptionsNoContext<K, V>\n    extends MemoOptions<K, V, undefined> {\n    context?: undefined\n  }\n\n  /**\n   * Options provided to the\n   * {@link OptionsBase.memoMethod} function.\n   */\n  export interface MemoizerOptions<K, V, FC = unknown> {\n    options: MemoizerMemoOptions<K, V, FC>\n    /**\n     * Object provided in the {@link MemoOptions.context} option to\n     * {@link LRUCache#memo}\n     */\n    context: FC\n  }\n\n  /**\n   * options which override the options set in the LRUCache constructor\n   * when calling {@link LRUCache#memo}.\n   *\n   * This is the union of {@link GetOptions} and {@link SetOptions}, plus\n   * {@link MemoOptions.forceRefresh}, and\n   * {@link MemoOptions.context}\n   *\n   * Any of these may be modified in the {@link OptionsBase.memoMethod}\n   * function, but the {@link GetOptions} fields will of course have no\n   * effect, as the {@link LRUCache#get} call already happened by the time\n   * the memoMethod is called.\n   */\n  export interface MemoizerMemoOptions<K, V, FC = unknown>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      | 'allowStale'\n      | 'updateAgeOnGet'\n      | 'noDeleteOnStaleGet'\n      | 'sizeCalculation'\n      | 'ttl'\n      | 'noDisposeOnSet'\n      | 'noUpdateTTL'\n    > {\n    status?: Status<V>\n    size?: Size\n    start?: Milliseconds\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#has} method.\n   */\n  export interface HasOptions<K, V, FC>\n    extends Pick<OptionsBase<K, V, FC>, 'updateAgeOnHas'> {\n    status?: Status<V>\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#get} method.\n   */\n  export interface GetOptions<K, V, FC>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      'allowStale' | 'updateAgeOnGet' | 'noDeleteOnStaleGet'\n    > {\n    status?: Status<V>\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#peek} method.\n   */\n  export interface PeekOptions<K, V, FC>\n    extends Pick<OptionsBase<K, V, FC>, 'allowStale'> {}\n\n  /**\n   * Options that may be passed to the {@link LRUCache#set} method.\n   */\n  export interface SetOptions<K, V, FC>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      'sizeCalculation' | 'ttl' | 'noDisposeOnSet' | 'noUpdateTTL'\n    > {\n    /**\n     * If size tracking is enabled, then setting an explicit size\n     * in the {@link LRUCache#set} call will prevent calling the\n     * {@link OptionsBase.sizeCalculation} function.\n     */\n    size?: Size\n    /**\n     * If TTL tracking is enabled, then setting an explicit start\n     * time in the {@link LRUCache#set} call will override the\n     * default time from `performance.now()` or `Date.now()`.\n     *\n     * Note that it must be a valid value for whichever time-tracking\n     * method is in use.\n     */\n    start?: Milliseconds\n    status?: Status<V>\n  }\n\n  /**\n   * The type signature for the {@link OptionsBase.fetchMethod} option.\n   */\n  export type Fetcher<K, V, FC = unknown> = (\n    key: K,\n    staleValue: V | undefined,\n    options: FetcherOptions<K, V, FC>,\n  ) => Promise<V | undefined | void> | V | undefined | void\n\n  /**\n   * the type signature for the {@link OptionsBase.memoMethod} option.\n   */\n  export type Memoizer<K, V, FC = unknown> = (\n    key: K,\n    staleValue: V | undefined,\n    options: MemoizerOptions<K, V, FC>,\n  ) => V\n\n  /**\n   * Options which may be passed to the {@link LRUCache} constructor.\n   *\n   * Most of these may be overridden in the various options that use\n   * them.\n   *\n   * Despite all being technically optional, the constructor requires that\n   * a cache is at minimum limited by one or more of {@link OptionsBase.max},\n   * {@link OptionsBase.ttl}, or {@link OptionsBase.maxSize}.\n   *\n   * If {@link OptionsBase.ttl} is used alone, then it is strongly advised\n   * (and in fact required by the type definitions here) that the cache\n   * also set {@link OptionsBase.ttlAutopurge}, to prevent potentially\n   * unbounded storage.\n   *\n   * All options are also available on the {@link LRUCache} instance, making\n   * it safe to pass an LRUCache instance as the options argumemnt to\n   * make another empty cache of the same type.\n   *\n   * Some options are marked as read-only, because changing them after\n   * instantiation is not safe. Changing any of the other options will of\n   * course only have an effect on subsequent method calls.\n   */\n  export interface OptionsBase<K, V, FC> {\n    /**\n     * The maximum number of items to store in the cache before evicting\n     * old entries. This is read-only on the {@link LRUCache} instance,\n     * and may not be overridden.\n     *\n     * If set, then storage space will be pre-allocated at construction\n     * time, and the cache will perform significantly faster.\n     *\n     * Note that significantly fewer items may be stored, if\n     * {@link OptionsBase.maxSize} and/or {@link OptionsBase.ttl} are also\n     * set.\n     *\n     * **It is strongly recommended to set a `max` to prevent unbounded growth\n     * of the cache.**\n     */\n    max?: Count\n\n    /**\n     * Max time in milliseconds for items to live in cache before they are\n     * considered stale.  Note that stale items are NOT preemptively removed by\n     * default, and MAY live in the cache, contributing to its LRU max, long\n     * after they have expired, unless {@link OptionsBase.ttlAutopurge} is\n     * set.\n     *\n     * If set to `0` (the default value), then that means \"do not track\n     * TTL\", not \"expire immediately\".\n     *\n     * Also, as this cache is optimized for LRU/MRU operations, some of\n     * the staleness/TTL checks will reduce performance, as they will incur\n     * overhead by deleting items.\n     *\n     * This is not primarily a TTL cache, and does not make strong TTL\n     * guarantees. There is no pre-emptive pruning of expired items, but you\n     * _may_ set a TTL on the cache, and it will treat expired items as missing\n     * when they are fetched, and delete them.\n     *\n     * Optional, but must be a non-negative integer in ms if specified.\n     *\n     * This may be overridden by passing an options object to `cache.set()`.\n     *\n     * At least one of `max`, `maxSize`, or `TTL` is required. This must be a\n     * positive integer if set.\n     *\n     * Even if ttl tracking is enabled, **it is strongly recommended to set a\n     * `max` to prevent unbounded growth of the cache.**\n     *\n     * If ttl tracking is enabled, and `max` and `maxSize` are not set,\n     * and `ttlAutopurge` is not set, then a warning will be emitted\n     * cautioning about the potential for unbounded memory consumption.\n     * (The TypeScript definitions will also discourage this.)\n     */\n    ttl?: Milliseconds\n\n    /**\n     * Minimum amount of time in ms in which to check for staleness.\n     * Defaults to 1, which means that the current time is checked\n     * at most once per millisecond.\n     *\n     * Set to 0 to check the current time every time staleness is tested.\n     * (This reduces performance, and is theoretically unnecessary.)\n     *\n     * Setting this to a higher value will improve performance somewhat\n     * while using ttl tracking, albeit at the expense of keeping stale\n     * items around a bit longer than their TTLs would indicate.\n     *\n     * @default 1\n     */\n    ttlResolution?: Milliseconds\n\n    /**\n     * Preemptively remove stale items from the cache.\n     *\n     * Note that this may *significantly* degrade performance, especially if\n     * the cache is storing a large number of items. It is almost always best\n     * to just leave the stale items in the cache, and let them fall out as new\n     * items are added.\n     *\n     * Note that this means that {@link OptionsBase.allowStale} is a bit\n     * pointless, as stale items will be deleted almost as soon as they\n     * expire.\n     *\n     * Use with caution!\n     */\n    ttlAutopurge?: boolean\n\n    /**\n     * When using time-expiring entries with `ttl`, setting this to `true` will\n     * make each item's age reset to 0 whenever it is retrieved from cache with\n     * {@link LRUCache#get}, causing it to not expire. (It can still fall out\n     * of cache based on recency of use, of course.)\n     *\n     * Has no effect if {@link OptionsBase.ttl} is not set.\n     *\n     * This may be overridden by passing an options object to `cache.get()`.\n     */\n    updateAgeOnGet?: boolean\n\n    /**\n     * When using time-expiring entries with `ttl`, setting this to `true` will\n     * make each item's age reset to 0 whenever its presence in the cache is\n     * checked with {@link LRUCache#has}, causing it to not expire. (It can\n     * still fall out of cache based on recency of use, of course.)\n     *\n     * Has no effect if {@link OptionsBase.ttl} is not set.\n     */\n    updateAgeOnHas?: boolean\n\n    /**\n     * Allow {@link LRUCache#get} and {@link LRUCache#fetch} calls to return\n     * stale data, if available.\n     *\n     * By default, if you set `ttl`, stale items will only be deleted from the\n     * cache when you `get(key)`. That is, it's not preemptively pruning items,\n     * unless {@link OptionsBase.ttlAutopurge} is set.\n     *\n     * If you set `allowStale:true`, it'll return the stale value *as well as*\n     * deleting it. If you don't set this, then it'll return `undefined` when\n     * you try to get a stale entry.\n     *\n     * Note that when a stale entry is fetched, _even if it is returned due to\n     * `allowStale` being set_, it is removed from the cache immediately. You\n     * can suppress this behavior by setting\n     * {@link OptionsBase.noDeleteOnStaleGet}, either in the constructor, or in\n     * the options provided to {@link LRUCache#get}.\n     *\n     * This may be overridden by passing an options object to `cache.get()`.\n     * The `cache.has()` method will always return `false` for stale items.\n     *\n     * Only relevant if a ttl is set.\n     */\n    allowStale?: boolean\n\n    /**\n     * Function that is called on items when they are dropped from the\n     * cache, as `dispose(value, key, reason)`.\n     *\n     * This can be handy if you want to close file descriptors or do\n     * other cleanup tasks when items are no longer stored in the cache.\n     *\n     * **NOTE**: It is called _before_ the item has been fully removed\n     * from the cache, so if you want to put it right back in, you need\n     * to wait until the next tick. If you try to add it back in during\n     * the `dispose()` function call, it will break things in subtle and\n     * weird ways.\n     *\n     * Unlike several other options, this may _not_ be overridden by\n     * passing an option to `set()`, for performance reasons.\n     *\n     * The `reason` will be one of the following strings, corresponding\n     * to the reason for the item's deletion:\n     *\n     * - `evict` Item was evicted to make space for a new addition\n     * - `set` Item was overwritten by a new value\n     * - `expire` Item expired its TTL\n     * - `fetch` Item was deleted due to a failed or aborted fetch, or a\n     *   fetchMethod returning `undefined.\n     * - `delete` Item was removed by explicit `cache.delete(key)`,\n     *   `cache.clear()`, or `cache.set(key, undefined)`.\n     */\n    dispose?: Disposer<K, V>\n\n    /**\n     * Function that is called when new items are inserted into the cache,\n     * as `onInsert(value, key, reason)`.\n     *\n     * This can be useful if you need to perform actions when an item is\n     * added, such as logging or tracking insertions.\n     *\n     * Unlike some other options, this may _not_ be overridden by passing\n     * an option to `set()`, for performance and consistency reasons.\n     */\n    onInsert?: Inserter<K, V>\n\n    /**\n     * The same as {@link OptionsBase.dispose}, but called *after* the entry\n     * is completely removed and the cache is once again in a clean state.\n     *\n     * It is safe to add an item right back into the cache at this point.\n     * However, note that it is *very* easy to inadvertently create infinite\n     * recursion this way.\n     */\n    disposeAfter?: Disposer<K, V>\n\n    /**\n     * Set to true to suppress calling the\n     * {@link OptionsBase.dispose} function if the entry key is\n     * still accessible within the cache.\n     *\n     * This may be overridden by passing an options object to\n     * {@link LRUCache#set}.\n     *\n     * Only relevant if `dispose` or `disposeAfter` are set.\n     */\n    noDisposeOnSet?: boolean\n\n    /**\n     * Boolean flag to tell the cache to not update the TTL when setting a new\n     * value for an existing key (ie, when updating a value rather than\n     * inserting a new value).  Note that the TTL value is _always_ set (if\n     * provided) when adding a new entry into the cache.\n     *\n     * Has no effect if a {@link OptionsBase.ttl} is not set.\n     *\n     * May be passed as an option to {@link LRUCache#set}.\n     */\n    noUpdateTTL?: boolean\n\n    /**\n     * Set to a positive integer to track the sizes of items added to the\n     * cache, and automatically evict items in order to stay below this size.\n     * Note that this may result in fewer than `max` items being stored.\n     *\n     * Attempting to add an item to the cache whose calculated size is greater\n     * that this amount will be a no-op. The item will not be cached, and no\n     * other items will be evicted.\n     *\n     * Optional, must be a positive integer if provided.\n     *\n     * Sets `maxEntrySize` to the same value, unless a different value is\n     * provided for `maxEntrySize`.\n     *\n     * At least one of `max`, `maxSize`, or `TTL` is required. This must be a\n     * positive integer if set.\n     *\n     * Even if size tracking is enabled, **it is strongly recommended to set a\n     * `max` to prevent unbounded growth of the cache.**\n     *\n     * Note also that size tracking can negatively impact performance,\n     * though for most cases, only minimally.\n     */\n    maxSize?: Size\n\n    /**\n     * The maximum allowed size for any single item in the cache.\n     *\n     * If a larger item is passed to {@link LRUCache#set} or returned by a\n     * {@link OptionsBase.fetchMethod} or {@link OptionsBase.memoMethod}, then\n     * it will not be stored in the cache.\n     *\n     * Attempting to add an item whose calculated size is greater than\n     * this amount will not cache the item or evict any old items, but\n     * WILL delete an existing value if one is already present.\n     *\n     * Optional, must be a positive integer if provided. Defaults to\n     * the value of `maxSize` if provided.\n     */\n    maxEntrySize?: Size\n\n    /**\n     * A function that returns a number indicating the item's size.\n     *\n     * Requires {@link OptionsBase.maxSize} to be set.\n     *\n     * If not provided, and {@link OptionsBase.maxSize} or\n     * {@link OptionsBase.maxEntrySize} are set, then all\n     * {@link LRUCache#set} calls **must** provide an explicit\n     * {@link SetOptions.size} or sizeCalculation param.\n     */\n    sizeCalculation?: SizeCalculator<K, V>\n\n    /**\n     * Method that provides the implementation for {@link LRUCache#fetch}\n     *\n     * ```ts\n     * fetchMethod(key, staleValue, { signal, options, context })\n     * ```\n     *\n     * If `fetchMethod` is not provided, then `cache.fetch(key)` is equivalent\n     * to `Promise.resolve(cache.get(key))`.\n     *\n     * If at any time, `signal.aborted` is set to `true`, or if the\n     * `signal.onabort` method is called, or if it emits an `'abort'` event\n     * which you can listen to with `addEventListener`, then that means that\n     * the fetch should be abandoned. This may be passed along to async\n     * functions aware of AbortController/AbortSignal behavior.\n     *\n     * The `fetchMethod` should **only** return `undefined` or a Promise\n     * resolving to `undefined` if the AbortController signaled an `abort`\n     * event. In all other cases, it should return or resolve to a value\n     * suitable for adding to the cache.\n     *\n     * The `options` object is a union of the options that may be provided to\n     * `set()` and `get()`. If they are modified, then that will result in\n     * modifying the settings to `cache.set()` when the value is resolved, and\n     * in the case of\n     * {@link OptionsBase.noDeleteOnFetchRejection} and\n     * {@link OptionsBase.allowStaleOnFetchRejection}, the handling of\n     * `fetchMethod` failures.\n     *\n     * For example, a DNS cache may update the TTL based on the value returned\n     * from a remote DNS server by changing `options.ttl` in the `fetchMethod`.\n     */\n    fetchMethod?: Fetcher<K, V, FC>\n\n    /**\n     * Method that provides the implementation for {@link LRUCache#memo}\n     */\n    memoMethod?: Memoizer<K, V, FC>\n\n    /**\n     * Set to true to suppress the deletion of stale data when a\n     * {@link OptionsBase.fetchMethod} returns a rejected promise.\n     */\n    noDeleteOnFetchRejection?: boolean\n\n    /**\n     * Do not delete stale items when they are retrieved with\n     * {@link LRUCache#get}.\n     *\n     * Note that the `get` return value will still be `undefined`\n     * unless {@link OptionsBase.allowStale} is true.\n     *\n     * When using time-expiring entries with `ttl`, by default stale\n     * items will be removed from the cache when the key is accessed\n     * with `cache.get()`.\n     *\n     * Setting this option will cause stale items to remain in the cache, until\n     * they are explicitly deleted with `cache.delete(key)`, or retrieved with\n     * `noDeleteOnStaleGet` set to `false`.\n     *\n     * This may be overridden by passing an options object to `cache.get()`.\n     *\n     * Only relevant if a ttl is used.\n     */\n    noDeleteOnStaleGet?: boolean\n\n    /**\n     * Set to true to allow returning stale data when a\n     * {@link OptionsBase.fetchMethod} throws an error or returns a rejected\n     * promise.\n     *\n     * This differs from using {@link OptionsBase.allowStale} in that stale\n     * data will ONLY be returned in the case that the {@link LRUCache#fetch}\n     * fails, not any other times.\n     *\n     * If a `fetchMethod` fails, and there is no stale value available, the\n     * `fetch()` will resolve to `undefined`. Ie, all `fetchMethod` errors are\n     * suppressed.\n     *\n     * Implies `noDeleteOnFetchRejection`.\n     *\n     * This may be set in calls to `fetch()`, or defaulted on the constructor,\n     * or overridden by modifying the options object in the `fetchMethod`.\n     */\n    allowStaleOnFetchRejection?: boolean\n\n    /**\n     * Set to true to return a stale value from the cache when the\n     * `AbortSignal` passed to the {@link OptionsBase.fetchMethod} dispatches\n     * an `'abort'` event, whether user-triggered, or due to internal cache\n     * behavior.\n     *\n     * Unless {@link OptionsBase.ignoreFetchAbort} is also set, the underlying\n     * {@link OptionsBase.fetchMethod} will still be considered canceled, and\n     * any value it returns will be ignored and not cached.\n     *\n     * Caveat: since fetches are aborted when a new value is explicitly\n     * set in the cache, this can lead to fetch returning a stale value,\n     * since that was the fallback value _at the moment the `fetch()` was\n     * initiated_, even though the new updated value is now present in\n     * the cache.\n     *\n     * For example:\n     *\n     * ```ts\n     * const cache = new LRUCache<string, any>({\n     *   ttl: 100,\n     *   fetchMethod: async (url, oldValue, { signal }) =>  {\n     *     const res = await fetch(url, { signal })\n     *     return await res.json()\n     *   }\n     * })\n     * cache.set('https://example.com/', { some: 'data' })\n     * // 100ms go by...\n     * const result = cache.fetch('https://example.com/')\n     * cache.set('https://example.com/', { other: 'thing' })\n     * console.log(await result) // { some: 'data' }\n     * console.log(cache.get('https://example.com/')) // { other: 'thing' }\n     * ```\n     */\n    allowStaleOnFetchAbort?: boolean\n\n    /**\n     * Set to true to ignore the `abort` event emitted by the `AbortSignal`\n     * object passed to {@link OptionsBase.fetchMethod}, and still cache the\n     * resulting resolution value, as long as it is not `undefined`.\n     *\n     * When used on its own, this means aborted {@link LRUCache#fetch} calls\n     * are not immediately resolved or rejected when they are aborted, and\n     * instead take the full time to await.\n     *\n     * When used with {@link OptionsBase.allowStaleOnFetchAbort}, aborted\n     * {@link LRUCache#fetch} calls will resolve immediately to their stale\n     * cached value or `undefined`, and will continue to process and eventually\n     * update the cache when they resolve, as long as the resulting value is\n     * not `undefined`, thus supporting a \"return stale on timeout while\n     * refreshing\" mechanism by passing `AbortSignal.timeout(n)` as the signal.\n     *\n     * For example:\n     *\n     * ```ts\n     * const c = new LRUCache({\n     *   ttl: 100,\n     *   ignoreFetchAbort: true,\n     *   allowStaleOnFetchAbort: true,\n     *   fetchMethod: async (key, oldValue, { signal }) => {\n     *     // note: do NOT pass the signal to fetch()!\n     *     // let's say this fetch can take a long time.\n     *     const res = await fetch(`https://slow-backend-server/${key}`)\n     *     return await res.json()\n     *   },\n     * })\n     *\n     * // this will return the stale value after 100ms, while still\n     * // updating in the background for next time.\n     * const val = await c.fetch('key', { signal: AbortSignal.timeout(100) })\n     * ```\n     *\n     * **Note**: regardless of this setting, an `abort` event _is still\n     * emitted on the `AbortSignal` object_, so may result in invalid results\n     * when passed to other underlying APIs that use AbortSignals.\n     *\n     * This may be overridden in the {@link OptionsBase.fetchMethod} or the\n     * call to {@link LRUCache#fetch}.\n     */\n    ignoreFetchAbort?: boolean\n\n    /**\n     * In some cases, you may want to swap out the performance/Date object\n     * used for TTL tracking. This should almost certainly NOT be done in\n     * production environments!\n     *\n     * This value defaults to `global.performance` if it has a `now()` method,\n     * or the `global.Date` object otherwise.\n     */\n    perf?: Perf\n  }\n\n  export interface OptionsMaxLimit<K, V, FC>\n    extends OptionsBase<K, V, FC> {\n    max: Count\n  }\n  export interface OptionsTTLLimit<K, V, FC>\n    extends OptionsBase<K, V, FC> {\n    ttl: Milliseconds\n    ttlAutopurge: boolean\n  }\n  export interface OptionsSizeLimit<K, V, FC>\n    extends OptionsBase<K, V, FC> {\n    maxSize: Size\n  }\n\n  /**\n   * The valid safe options for the {@link LRUCache} constructor\n   */\n  export type Options<K, V, FC> =\n    | OptionsMaxLimit<K, V, FC>\n    | OptionsSizeLimit<K, V, FC>\n    | OptionsTTLLimit<K, V, FC>\n\n  /**\n   * Entry objects used by {@link LRUCache#load} and {@link LRUCache#dump},\n   * and returned by {@link LRUCache#info}.\n   */\n  export interface Entry<V> {\n    value: V\n    ttl?: Milliseconds\n    size?: Size\n    start?: Milliseconds\n  }\n}\n\n/**\n * Default export, the thing you're using this module to get.\n *\n * The `K` and `V` types define the key and value types, respectively. The\n * optional `FC` type defines the type of the `context` object passed to\n * `cache.fetch()` and `cache.memo()`.\n *\n * Keys and values **must not** be `null` or `undefined`.\n *\n * All properties from the options object (with the exception of `max`,\n * `maxSize`, `fetchMethod`, `memoMethod`, `dispose` and `disposeAfter`) are\n * added as normal public members. (The listed options are read-only getters.)\n *\n * Changing any of these will alter the defaults for subsequent method calls.\n */\nexport class LRUCache<K extends {}, V extends {}, FC = unknown> {\n  // options that cannot be changed without disaster\n  readonly #max: LRUCache.Count\n  readonly #maxSize: LRUCache.Size\n  readonly #dispose?: LRUCache.Disposer<K, V>\n  readonly #onInsert?: LRUCache.Inserter<K, V>\n  readonly #disposeAfter?: LRUCache.Disposer<K, V>\n  readonly #fetchMethod?: LRUCache.Fetcher<K, V, FC>\n  readonly #memoMethod?: LRUCache.Memoizer<K, V, FC>\n  readonly #perf: Perf\n\n  /**\n   * {@link LRUCache.OptionsBase.perf}\n   */\n  get perf() {\n    return this.#perf\n  }\n\n  /**\n   * {@link LRUCache.OptionsBase.ttl}\n   */\n  ttl: LRUCache.Milliseconds\n\n  /**\n   * {@link LRUCache.OptionsBase.ttlResolution}\n   */\n  ttlResolution: LRUCache.Milliseconds\n  /**\n   * {@link LRUCache.OptionsBase.ttlAutopurge}\n   */\n  ttlAutopurge: boolean\n  /**\n   * {@link LRUCache.OptionsBase.updateAgeOnGet}\n   */\n  updateAgeOnGet: boolean\n  /**\n   * {@link LRUCache.OptionsBase.updateAgeOnHas}\n   */\n  updateAgeOnHas: boolean\n  /**\n   * {@link LRUCache.OptionsBase.allowStale}\n   */\n  allowStale: boolean\n\n  /**\n   * {@link LRUCache.OptionsBase.noDisposeOnSet}\n   */\n  noDisposeOnSet: boolean\n  /**\n   * {@link LRUCache.OptionsBase.noUpdateTTL}\n   */\n  noUpdateTTL: boolean\n  /**\n   * {@link LRUCache.OptionsBase.maxEntrySize}\n   */\n  maxEntrySize: LRUCache.Size\n  /**\n   * {@link LRUCache.OptionsBase.sizeCalculation}\n   */\n  sizeCalculation?: LRUCache.SizeCalculator<K, V>\n  /**\n   * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}\n   */\n  noDeleteOnFetchRejection: boolean\n  /**\n   * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}\n   */\n  noDeleteOnStaleGet: boolean\n  /**\n   * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}\n   */\n  allowStaleOnFetchAbort: boolean\n  /**\n   * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}\n   */\n  allowStaleOnFetchRejection: boolean\n  /**\n   * {@link LRUCache.OptionsBase.ignoreFetchAbort}\n   */\n  ignoreFetchAbort: boolean\n\n  // computed properties\n  #size: LRUCache.Count\n  #calculatedSize: LRUCache.Size\n  #keyMap: Map<K, Index>\n  #keyList: (K | undefined)[]\n  #valList: (V | BackgroundFetch<V> | undefined)[]\n  #next: NumberArray\n  #prev: NumberArray\n  #head: Index\n  #tail: Index\n  #free: StackLike\n  #disposed?: DisposeTask<K, V>[]\n  #sizes?: ZeroArray\n  #starts?: ZeroArray\n  #ttls?: ZeroArray\n  #autopurgeTimers?: (undefined | ReturnType<typeof setTimeout>)[]\n\n  #hasDispose: boolean\n  #hasFetchMethod: boolean\n  #hasDisposeAfter: boolean\n  #hasOnInsert: boolean\n\n  /**\n   * Do not call this method unless you need to inspect the\n   * inner workings of the cache.  If anything returned by this\n   * object is modified in any way, strange breakage may occur.\n   *\n   * These fields are private for a reason!\n   *\n   * @internal\n   */\n  static unsafeExposeInternals<\n    K extends {},\n    V extends {},\n    FC extends unknown = unknown,\n  >(c: LRUCache<K, V, FC>) {\n    return {\n      // properties\n      starts: c.#starts,\n      ttls: c.#ttls,\n      autopurgeTimers: c.#autopurgeTimers,\n      sizes: c.#sizes,\n      keyMap: c.#keyMap as Map<K, number>,\n      keyList: c.#keyList,\n      valList: c.#valList,\n      next: c.#next,\n      prev: c.#prev,\n      get head() {\n        return c.#head\n      },\n      get tail() {\n        return c.#tail\n      },\n      free: c.#free,\n      // methods\n      isBackgroundFetch: (p: any) => c.#isBackgroundFetch(p),\n      backgroundFetch: (\n        k: K,\n        index: number | undefined,\n        options: LRUCache.FetchOptions<K, V, FC>,\n        context: any,\n      ): BackgroundFetch<V> =>\n        c.#backgroundFetch(\n          k,\n          index as Index | undefined,\n          options,\n          context,\n        ),\n      moveToTail: (index: number): void => c.#moveToTail(index as Index),\n      indexes: (options?: { allowStale: boolean }) => c.#indexes(options),\n      rindexes: (options?: { allowStale: boolean }) =>\n        c.#rindexes(options),\n      isStale: (index: number | undefined) => c.#isStale(index as Index),\n    }\n  }\n\n  // Protected read-only members\n\n  /**\n   * {@link LRUCache.OptionsBase.max} (read-only)\n   */\n  get max(): LRUCache.Count {\n    return this.#max\n  }\n  /**\n   * {@link LRUCache.OptionsBase.maxSize} (read-only)\n   */\n  get maxSize(): LRUCache.Count {\n    return this.#maxSize\n  }\n  /**\n   * The total computed size of items in the cache (read-only)\n   */\n  get calculatedSize(): LRUCache.Size {\n    return this.#calculatedSize\n  }\n  /**\n   * The number of items stored in the cache (read-only)\n   */\n  get size(): LRUCache.Count {\n    return this.#size\n  }\n  /**\n   * {@link LRUCache.OptionsBase.fetchMethod} (read-only)\n   */\n  get fetchMethod(): LRUCache.Fetcher<K, V, FC> | undefined {\n    return this.#fetchMethod\n  }\n  get memoMethod(): LRUCache.Memoizer<K, V, FC> | undefined {\n    return this.#memoMethod\n  }\n  /**\n   * {@link LRUCache.OptionsBase.dispose} (read-only)\n   */\n  get dispose() {\n    return this.#dispose\n  }\n  /**\n   * {@link LRUCache.OptionsBase.onInsert} (read-only)\n   */\n  get onInsert() {\n    return this.#onInsert\n  }\n  /**\n   * {@link LRUCache.OptionsBase.disposeAfter} (read-only)\n   */\n  get disposeAfter() {\n    return this.#disposeAfter\n  }\n\n  constructor(options: LRUCache.Options<K, V, FC> | LRUCache<K, V, FC>) {\n    const {\n      max = 0,\n      ttl,\n      ttlResolution = 1,\n      ttlAutopurge,\n      updateAgeOnGet,\n      updateAgeOnHas,\n      allowStale,\n      dispose,\n      onInsert,\n      disposeAfter,\n      noDisposeOnSet,\n      noUpdateTTL,\n      maxSize = 0,\n      maxEntrySize = 0,\n      sizeCalculation,\n      fetchMethod,\n      memoMethod,\n      noDeleteOnFetchRejection,\n      noDeleteOnStaleGet,\n      allowStaleOnFetchRejection,\n      allowStaleOnFetchAbort,\n      ignoreFetchAbort,\n      perf,\n    } = options\n\n    if (perf !== undefined) {\n      if (typeof perf?.now !== 'function') {\n        throw new TypeError(\n          'perf option must have a now() method if specified',\n        )\n      }\n    }\n\n    this.#perf = perf ?? defaultPerf\n\n    if (max !== 0 && !isPosInt(max)) {\n      throw new TypeError('max option must be a nonnegative integer')\n    }\n\n    const UintArray = max ? getUintArray(max) : Array\n    if (!UintArray) {\n      throw new Error('invalid max value: ' + max)\n    }\n\n    this.#max = max\n    this.#maxSize = maxSize\n    this.maxEntrySize = maxEntrySize || this.#maxSize\n    this.sizeCalculation = sizeCalculation\n    if (this.sizeCalculation) {\n      if (!this.#maxSize && !this.maxEntrySize) {\n        throw new TypeError(\n          'cannot set sizeCalculation without setting maxSize or maxEntrySize',\n        )\n      }\n      if (typeof this.sizeCalculation !== 'function') {\n        throw new TypeError('sizeCalculation set to non-function')\n      }\n    }\n\n    if (memoMethod !== undefined && typeof memoMethod !== 'function') {\n      throw new TypeError('memoMethod must be a function if defined')\n    }\n    this.#memoMethod = memoMethod\n\n    if (fetchMethod !== undefined && typeof fetchMethod !== 'function') {\n      throw new TypeError('fetchMethod must be a function if specified')\n    }\n    this.#fetchMethod = fetchMethod\n    this.#hasFetchMethod = !!fetchMethod\n\n    this.#keyMap = new Map()\n    this.#keyList = new Array(max).fill(undefined)\n    this.#valList = new Array(max).fill(undefined)\n    this.#next = new UintArray(max)\n    this.#prev = new UintArray(max)\n    this.#head = 0 as Index\n    this.#tail = 0 as Index\n    this.#free = Stack.create(max)\n    this.#size = 0\n    this.#calculatedSize = 0\n\n    if (typeof dispose === 'function') {\n      this.#dispose = dispose\n    }\n    if (typeof onInsert === 'function') {\n      this.#onInsert = onInsert\n    }\n    if (typeof disposeAfter === 'function') {\n      this.#disposeAfter = disposeAfter\n      this.#disposed = []\n    } else {\n      this.#disposeAfter = undefined\n      this.#disposed = undefined\n    }\n    this.#hasDispose = !!this.#dispose\n    this.#hasOnInsert = !!this.#onInsert\n    this.#hasDisposeAfter = !!this.#disposeAfter\n\n    this.noDisposeOnSet = !!noDisposeOnSet\n    this.noUpdateTTL = !!noUpdateTTL\n    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection\n    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection\n    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort\n    this.ignoreFetchAbort = !!ignoreFetchAbort\n\n    // NB: maxEntrySize is set to maxSize if it's set\n    if (this.maxEntrySize !== 0) {\n      if (this.#maxSize !== 0) {\n        if (!isPosInt(this.#maxSize)) {\n          throw new TypeError(\n            'maxSize must be a positive integer if specified',\n          )\n        }\n      }\n      if (!isPosInt(this.maxEntrySize)) {\n        throw new TypeError(\n          'maxEntrySize must be a positive integer if specified',\n        )\n      }\n      this.#initializeSizeTracking()\n    }\n\n    this.allowStale = !!allowStale\n    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet\n    this.updateAgeOnGet = !!updateAgeOnGet\n    this.updateAgeOnHas = !!updateAgeOnHas\n    this.ttlResolution =\n      isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1\n    this.ttlAutopurge = !!ttlAutopurge\n    this.ttl = ttl || 0\n    if (this.ttl) {\n      if (!isPosInt(this.ttl)) {\n        throw new TypeError('ttl must be a positive integer if specified')\n      }\n      this.#initializeTTLTracking()\n    }\n\n    // do not allow completely unbounded caches\n    if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {\n      throw new TypeError(\n        'At least one of max, maxSize, or ttl is required',\n      )\n    }\n    if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {\n      const code = 'LRU_CACHE_UNBOUNDED'\n      if (shouldWarn(code)) {\n        warned.add(code)\n        const msg =\n          'TTL caching without ttlAutopurge, max, or maxSize can ' +\n          'result in unbounded memory consumption.'\n        emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache)\n      }\n    }\n  }\n\n  /**\n   * Return the number of ms left in the item's TTL. If item is not in cache,\n   * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.\n   */\n  getRemainingTTL(key: K) {\n    return this.#keyMap.has(key) ? Infinity : 0\n  }\n\n  #initializeTTLTracking() {\n    const ttls = new ZeroArray(this.#max)\n    const starts = new ZeroArray(this.#max)\n    this.#ttls = ttls\n    this.#starts = starts\n    const purgeTimers =\n      this.ttlAutopurge ?\n        new Array<undefined | ReturnType<typeof setTimeout>>(this.#max)\n      : undefined\n    this.#autopurgeTimers = purgeTimers\n\n    this.#setItemTTL = (index, ttl, start = this.#perf.now()) => {\n      starts[index] = ttl !== 0 ? start : 0\n      ttls[index] = ttl\n      // clear out the purge timer if we're setting TTL to 0, and\n      // previously had a ttl purge timer running, so it doesn't\n      // fire unnecessarily.\n      if (purgeTimers?.[index]) {\n        clearTimeout(purgeTimers[index])\n        purgeTimers[index] = undefined\n      }\n      if (ttl !== 0 && purgeTimers) {\n        const t = setTimeout(() => {\n          if (this.#isStale(index)) {\n            this.#delete(this.#keyList[index] as K, 'expire')\n          }\n        }, ttl + 1)\n        // unref() not supported on all platforms\n        /* c8 ignore start */\n        if (t.unref) {\n          t.unref()\n        }\n        /* c8 ignore stop */\n        purgeTimers[index] = t\n      }\n    }\n\n    this.#updateItemAge = index => {\n      starts[index] = ttls[index] !== 0 ? this.#perf.now() : 0\n    }\n\n    this.#statusTTL = (status, index) => {\n      if (ttls[index]) {\n        const ttl = ttls[index]\n        const start = starts[index]\n        /* c8 ignore next */\n        if (!ttl || !start) return\n        status.ttl = ttl\n        status.start = start\n        status.now = cachedNow || getNow()\n        const age = status.now - start\n        status.remainingTTL = ttl - age\n      }\n    }\n\n    // debounce calls to perf.now() to 1s so we're not hitting\n    // that costly call repeatedly.\n    let cachedNow = 0\n    const getNow = () => {\n      const n = this.#perf.now()\n      if (this.ttlResolution > 0) {\n        cachedNow = n\n        const t = setTimeout(() => (cachedNow = 0), this.ttlResolution)\n        // not available on all platforms\n        /* c8 ignore start */\n        if (t.unref) {\n          t.unref()\n        }\n        /* c8 ignore stop */\n      }\n      return n\n    }\n\n    this.getRemainingTTL = key => {\n      const index = this.#keyMap.get(key)\n      if (index === undefined) {\n        return 0\n      }\n      const ttl = ttls[index]\n      const start = starts[index]\n      if (!ttl || !start) {\n        return Infinity\n      }\n      const age = (cachedNow || getNow()) - start\n      return ttl - age\n    }\n\n    this.#isStale = index => {\n      const s = starts[index]\n      const t = ttls[index]\n      return !!t && !!s && (cachedNow || getNow()) - s > t\n    }\n  }\n\n  // conditionally set private methods related to TTL\n  #updateItemAge: (index: Index) => void = () => {}\n  #statusTTL: (status: LRUCache.Status<V>, index: Index) => void = () => {}\n  #setItemTTL: (\n    index: Index,\n    ttl: LRUCache.Milliseconds,\n    start?: LRUCache.Milliseconds,\n    // ignore because we never call this if we're not already in TTL mode\n    /* c8 ignore start */\n  ) => void = () => {}\n  /* c8 ignore stop */\n\n  #isStale: (index: Index) => boolean = () => false\n\n  #initializeSizeTracking() {\n    const sizes = new ZeroArray(this.#max)\n    this.#calculatedSize = 0\n    this.#sizes = sizes\n    this.#removeItemSize = index => {\n      this.#calculatedSize -= sizes[index] as number\n      sizes[index] = 0\n    }\n    this.#requireSize = (k, v, size, sizeCalculation) => {\n      // provisionally accept background fetches.\n      // actual value size will be checked when they return.\n      if (this.#isBackgroundFetch(v)) {\n        return 0\n      }\n      if (!isPosInt(size)) {\n        if (sizeCalculation) {\n          if (typeof sizeCalculation !== 'function') {\n            throw new TypeError('sizeCalculation must be a function')\n          }\n          size = sizeCalculation(v, k)\n          if (!isPosInt(size)) {\n            throw new TypeError(\n              'sizeCalculation return invalid (expect positive integer)',\n            )\n          }\n        } else {\n          throw new TypeError(\n            'invalid size value (must be positive integer). ' +\n              'When maxSize or maxEntrySize is used, sizeCalculation ' +\n              'or size must be set.',\n          )\n        }\n      }\n      return size\n    }\n    this.#addItemSize = (\n      index: Index,\n      size: LRUCache.Size,\n      status?: LRUCache.Status<V>,\n    ) => {\n      sizes[index] = size\n      if (this.#maxSize) {\n        const maxSize = this.#maxSize - (sizes[index] as number)\n        while (this.#calculatedSize > maxSize) {\n          this.#evict(true)\n        }\n      }\n      this.#calculatedSize += sizes[index] as number\n      if (status) {\n        status.entrySize = size\n        status.totalCalculatedSize = this.#calculatedSize\n      }\n    }\n  }\n\n  #removeItemSize: (index: Index) => void = _i => {}\n  #addItemSize: (\n    index: Index,\n    size: LRUCache.Size,\n    status?: LRUCache.Status<V>,\n  ) => void = (_i, _s, _st) => {}\n  #requireSize: (\n    k: K,\n    v: V | BackgroundFetch<V>,\n    size?: LRUCache.Size,\n    sizeCalculation?: LRUCache.SizeCalculator<K, V>,\n  ) => LRUCache.Size = (\n    _k: K,\n    _v: V | BackgroundFetch<V>,\n    size?: LRUCache.Size,\n    sizeCalculation?: LRUCache.SizeCalculator<K, V>,\n  ) => {\n    if (size || sizeCalculation) {\n      throw new TypeError(\n        'cannot set size without setting maxSize or maxEntrySize on cache',\n      )\n    }\n    return 0\n  };\n\n  *#indexes({ allowStale = this.allowStale } = {}) {\n    if (this.#size) {\n      for (let i = this.#tail; true; ) {\n        if (!this.#isValidIndex(i)) {\n          break\n        }\n        if (allowStale || !this.#isStale(i)) {\n          yield i\n        }\n        if (i === this.#head) {\n          break\n        } else {\n          i = this.#prev[i] as Index\n        }\n      }\n    }\n  }\n\n  *#rindexes({ allowStale = this.allowStale } = {}) {\n    if (this.#size) {\n      for (let i = this.#head; true; ) {\n        if (!this.#isValidIndex(i)) {\n          break\n        }\n        if (allowStale || !this.#isStale(i)) {\n          yield i\n        }\n        if (i === this.#tail) {\n          break\n        } else {\n          i = this.#next[i] as Index\n        }\n      }\n    }\n  }\n\n  #isValidIndex(index: Index) {\n    return (\n      index !== undefined &&\n      this.#keyMap.get(this.#keyList[index] as K) === index\n    )\n  }\n\n  /**\n   * Return a generator yielding `[key, value]` pairs,\n   * in order from most recently used to least recently used.\n   */\n  *entries() {\n    for (const i of this.#indexes()) {\n      if (\n        this.#valList[i] !== undefined &&\n        this.#keyList[i] !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield [this.#keyList[i], this.#valList[i]] as [K, V]\n      }\n    }\n  }\n\n  /**\n   * Inverse order version of {@link LRUCache.entries}\n   *\n   * Return a generator yielding `[key, value]` pairs,\n   * in order from least recently used to most recently used.\n   */\n  *rentries() {\n    for (const i of this.#rindexes()) {\n      if (\n        this.#valList[i] !== undefined &&\n        this.#keyList[i] !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield [this.#keyList[i], this.#valList[i]]\n      }\n    }\n  }\n\n  /**\n   * Return a generator yielding the keys in the cache,\n   * in order from most recently used to least recently used.\n   */\n  *keys() {\n    for (const i of this.#indexes()) {\n      const k = this.#keyList[i]\n      if (k !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {\n        yield k\n      }\n    }\n  }\n\n  /**\n   * Inverse order version of {@link LRUCache.keys}\n   *\n   * Return a generator yielding the keys in the cache,\n   * in order from least recently used to most recently used.\n   */\n  *rkeys() {\n    for (const i of this.#rindexes()) {\n      const k = this.#keyList[i]\n      if (k !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {\n        yield k\n      }\n    }\n  }\n\n  /**\n   * Return a generator yielding the values in the cache,\n   * in order from most recently used to least recently used.\n   */\n  *values() {\n    for (const i of this.#indexes()) {\n      const v = this.#valList[i]\n      if (v !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {\n        yield this.#valList[i] as V\n      }\n    }\n  }\n\n  /**\n   * Inverse order version of {@link LRUCache.values}\n   *\n   * Return a generator yielding the values in the cache,\n   * in order from least recently used to most recently used.\n   */\n  *rvalues() {\n    for (const i of this.#rindexes()) {\n      const v = this.#valList[i]\n      if (v !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {\n        yield this.#valList[i]\n      }\n    }\n  }\n\n  /**\n   * Iterating over the cache itself yields the same results as\n   * {@link LRUCache.entries}\n   */\n  [Symbol.iterator]() {\n    return this.entries()\n  }\n\n  /**\n   * A String value that is used in the creation of the default string\n   * description of an object. Called by the built-in method\n   * `Object.prototype.toString`.\n   */\n  [Symbol.toStringTag] = 'LRUCache'\n\n  /**\n   * Find a value for which the supplied fn method returns a truthy value,\n   * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.\n   */\n  find(\n    fn: (v: V, k: K, self: LRUCache<K, V, FC>) => boolean,\n    getOptions: LRUCache.GetOptions<K, V, FC> = {},\n  ) {\n    for (const i of this.#indexes()) {\n      const v = this.#valList[i]\n      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v\n      if (value === undefined) continue\n      if (fn(value, this.#keyList[i] as K, this)) {\n        return this.get(this.#keyList[i] as K, getOptions)\n      }\n    }\n  }\n\n  /**\n   * Call the supplied function on each item in the cache, in order from most\n   * recently used to least recently used.\n   *\n   * `fn` is called as `fn(value, key, cache)`.\n   *\n   * If `thisp` is provided, function will be called in the `this`-context of\n   * the provided object, or the cache if no `thisp` object is provided.\n   *\n   * Does not update age or recenty of use, or iterate over stale values.\n   */\n  forEach(\n    fn: (v: V, k: K, self: LRUCache<K, V, FC>) => any,\n    thisp: any = this,\n  ) {\n    for (const i of this.#indexes()) {\n      const v = this.#valList[i]\n      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v\n      if (value === undefined) continue\n      fn.call(thisp, value, this.#keyList[i] as K, this)\n    }\n  }\n\n  /**\n   * The same as {@link LRUCache.forEach} but items are iterated over in\n   * reverse order.  (ie, less recently used items are iterated over first.)\n   */\n  rforEach(\n    fn: (v: V, k: K, self: LRUCache<K, V, FC>) => any,\n    thisp: any = this,\n  ) {\n    for (const i of this.#rindexes()) {\n      const v = this.#valList[i]\n      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v\n      if (value === undefined) continue\n      fn.call(thisp, value, this.#keyList[i] as K, this)\n    }\n  }\n\n  /**\n   * Delete any stale entries. Returns true if anything was removed,\n   * false otherwise.\n   */\n  purgeStale() {\n    let deleted = false\n    for (const i of this.#rindexes({ allowStale: true })) {\n      if (this.#isStale(i)) {\n        this.#delete(this.#keyList[i] as K, 'expire')\n        deleted = true\n      }\n    }\n    return deleted\n  }\n\n  /**\n   * Get the extended info about a given entry, to get its value, size, and\n   * TTL info simultaneously. Returns `undefined` if the key is not present.\n   *\n   * Unlike {@link LRUCache#dump}, which is designed to be portable and survive\n   * serialization, the `start` value is always the current timestamp, and the\n   * `ttl` is a calculated remaining time to live (negative if expired).\n   *\n   * Always returns stale values, if their info is found in the cache, so be\n   * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})\n   * if relevant.\n   */\n  info(key: K): LRUCache.Entry<V> | undefined {\n    const i = this.#keyMap.get(key)\n    if (i === undefined) return undefined\n    const v = this.#valList[i]\n    /* c8 ignore start - this isn't tested for the info function,\n     * but it's the same logic as found in other places. */\n    const value: V | undefined =\n      this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v\n    if (value === undefined) return undefined\n    /* c8 ignore end */\n    const entry: LRUCache.Entry<V> = { value }\n    if (this.#ttls && this.#starts) {\n      const ttl = this.#ttls[i]\n      const start = this.#starts[i]\n      if (ttl && start) {\n        const remain = ttl - (this.#perf.now() - start)\n        entry.ttl = remain\n        entry.start = Date.now()\n      }\n    }\n    if (this.#sizes) {\n      entry.size = this.#sizes[i]\n    }\n    return entry\n  }\n\n  /**\n   * Return an array of [key, {@link LRUCache.Entry}] tuples which can be\n   * passed to {@link LRUCache#load}.\n   *\n   * The `start` fields are calculated relative to a portable `Date.now()`\n   * timestamp, even if `performance.now()` is available.\n   *\n   * Stale entries are always included in the `dump`, even if\n   * {@link LRUCache.OptionsBase.allowStale} is false.\n   *\n   * Note: this returns an actual array, not a generator, so it can be more\n   * easily passed around.\n   */\n  dump() {\n    const arr: [K, LRUCache.Entry<V>][] = []\n    for (const i of this.#indexes({ allowStale: true })) {\n      const key = this.#keyList[i]\n      const v = this.#valList[i]\n      const value: V | undefined =\n        this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v\n      if (value === undefined || key === undefined) continue\n      const entry: LRUCache.Entry<V> = { value }\n      if (this.#ttls && this.#starts) {\n        entry.ttl = this.#ttls[i]\n        // always dump the start relative to a portable timestamp\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = this.#perf.now() - (this.#starts[i] as number)\n        entry.start = Math.floor(Date.now() - age)\n      }\n      if (this.#sizes) {\n        entry.size = this.#sizes[i]\n      }\n      arr.unshift([key, entry])\n    }\n    return arr\n  }\n\n  /**\n   * Reset the cache and load in the items in entries in the order listed.\n   *\n   * The shape of the resulting cache may be different if the same options are\n   * not used in both caches.\n   *\n   * The `start` fields are assumed to be calculated relative to a portable\n   * `Date.now()` timestamp, even if `performance.now()` is available.\n   */\n  load(arr: [K, LRUCache.Entry<V>][]) {\n    this.clear()\n    for (const [key, entry] of arr) {\n      if (entry.start) {\n        // entry.start is a portable timestamp, but we may be using\n        // node's performance.now(), so calculate the offset, so that\n        // we get the intended remaining TTL, no matter how long it's\n        // been on ice.\n        //\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = Date.now() - entry.start\n        entry.start = this.#perf.now() - age\n      }\n      this.set(key, entry.value, entry)\n    }\n  }\n\n  /**\n   * Add a value to the cache.\n   *\n   * Note: if `undefined` is specified as a value, this is an alias for\n   * {@link LRUCache#delete}\n   *\n   * Fields on the {@link LRUCache.SetOptions} options param will override\n   * their corresponding values in the constructor options for the scope\n   * of this single `set()` operation.\n   *\n   * If `start` is provided, then that will set the effective start\n   * time for the TTL calculation. Note that this must be a previous\n   * value of `performance.now()` if supported, or a previous value of\n   * `Date.now()` if not.\n   *\n   * Options object may also include `size`, which will prevent\n   * calling the `sizeCalculation` function and just use the specified\n   * number if it is a positive integer, and `noDisposeOnSet` which\n   * will prevent calling a `dispose` function in the case of\n   * overwrites.\n   *\n   * If the `size` (or return value of `sizeCalculation`) for a given\n   * entry is greater than `maxEntrySize`, then the item will not be\n   * added to the cache.\n   *\n   * Will update the recency of the entry.\n   *\n   * If the value is `undefined`, then this is an alias for\n   * `cache.delete(key)`. `undefined` is never stored in the cache.\n   */\n  set(\n    k: K,\n    v: V | BackgroundFetch<V> | undefined,\n    setOptions: LRUCache.SetOptions<K, V, FC> = {},\n  ) {\n    if (v === undefined) {\n      this.delete(k)\n      return this\n    }\n    const {\n      ttl = this.ttl,\n      start,\n      noDisposeOnSet = this.noDisposeOnSet,\n      sizeCalculation = this.sizeCalculation,\n      status,\n    } = setOptions\n    let { noUpdateTTL = this.noUpdateTTL } = setOptions\n\n    const size = this.#requireSize(\n      k,\n      v,\n      setOptions.size || 0,\n      sizeCalculation,\n    )\n    // if the item doesn't fit, don't do anything\n    // NB: maxEntrySize set to maxSize by default\n    if (this.maxEntrySize && size > this.maxEntrySize) {\n      if (status) {\n        status.set = 'miss'\n        status.maxEntrySizeExceeded = true\n      }\n      // have to delete, in case something is there already.\n      this.#delete(k, 'set')\n      return this\n    }\n    let index = this.#size === 0 ? undefined : this.#keyMap.get(k)\n    if (index === undefined) {\n      // addition\n      index = (\n        this.#size === 0 ? this.#tail\n        : this.#free.length !== 0 ? this.#free.pop()\n        : this.#size === this.#max ? this.#evict(false)\n        : this.#size) as Index\n      this.#keyList[index] = k\n      this.#valList[index] = v\n      this.#keyMap.set(k, index)\n      this.#next[this.#tail] = index\n      this.#prev[index] = this.#tail\n      this.#tail = index\n      this.#size++\n      this.#addItemSize(index, size, status)\n      if (status) status.set = 'add'\n      noUpdateTTL = false\n      if (this.#hasOnInsert) {\n        this.#onInsert?.(v as V, k, 'add')\n      }\n    } else {\n      // update\n      this.#moveToTail(index)\n      const oldVal = this.#valList[index] as V | BackgroundFetch<V>\n      if (v !== oldVal) {\n        if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {\n          oldVal.__abortController.abort(new Error('replaced'))\n          const { __staleWhileFetching: s } = oldVal\n          if (s !== undefined && !noDisposeOnSet) {\n            if (this.#hasDispose) {\n              this.#dispose?.(s as V, k, 'set')\n            }\n            if (this.#hasDisposeAfter) {\n              this.#disposed?.push([s as V, k, 'set'])\n            }\n          }\n        } else if (!noDisposeOnSet) {\n          if (this.#hasDispose) {\n            this.#dispose?.(oldVal as V, k, 'set')\n          }\n          if (this.#hasDisposeAfter) {\n            this.#disposed?.push([oldVal as V, k, 'set'])\n          }\n        }\n        this.#removeItemSize(index)\n        this.#addItemSize(index, size, status)\n        this.#valList[index] = v\n        if (status) {\n          status.set = 'replace'\n          const oldValue =\n            oldVal && this.#isBackgroundFetch(oldVal) ?\n              oldVal.__staleWhileFetching\n            : oldVal\n          if (oldValue !== undefined) status.oldValue = oldValue\n        }\n      } else if (status) {\n        status.set = 'update'\n      }\n\n      if (this.#hasOnInsert) {\n        this.onInsert?.(v as V, k, v === oldVal ? 'update' : 'replace')\n      }\n    }\n    if (ttl !== 0 && !this.#ttls) {\n      this.#initializeTTLTracking()\n    }\n    if (this.#ttls) {\n      if (!noUpdateTTL) {\n        this.#setItemTTL(index, ttl, start)\n      }\n      if (status) this.#statusTTL(status, index)\n    }\n    if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {\n      const dt = this.#disposed\n      let task: DisposeTask<K, V> | undefined\n      while ((task = dt?.shift())) {\n        this.#disposeAfter?.(...task)\n      }\n    }\n    return this\n  }\n\n  /**\n   * Evict the least recently used item, returning its value or\n   * `undefined` if cache is empty.\n   */\n  pop(): V | undefined {\n    try {\n      while (this.#size) {\n        const val = this.#valList[this.#head]\n        this.#evict(true)\n        if (this.#isBackgroundFetch(val)) {\n          if (val.__staleWhileFetching) {\n            return val.__staleWhileFetching\n          }\n        } else if (val !== undefined) {\n          return val\n        }\n      }\n    } finally {\n      if (this.#hasDisposeAfter && this.#disposed) {\n        const dt = this.#disposed\n        let task: DisposeTask<K, V> | undefined\n        while ((task = dt?.shift())) {\n          this.#disposeAfter?.(...task)\n        }\n      }\n    }\n  }\n\n  #evict(free: boolean) {\n    const head = this.#head\n    const k = this.#keyList[head] as K\n    const v = this.#valList[head] as V\n    if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {\n      v.__abortController.abort(new Error('evicted'))\n    } else if (this.#hasDispose || this.#hasDisposeAfter) {\n      if (this.#hasDispose) {\n        this.#dispose?.(v, k, 'evict')\n      }\n      if (this.#hasDisposeAfter) {\n        this.#disposed?.push([v, k, 'evict'])\n      }\n    }\n    this.#removeItemSize(head)\n    if (this.#autopurgeTimers?.[head]) {\n      clearTimeout(this.#autopurgeTimers[head])\n      this.#autopurgeTimers[head] = undefined\n    }\n    // if we aren't about to use the index, then null these out\n    if (free) {\n      this.#keyList[head] = undefined\n      this.#valList[head] = undefined\n      this.#free.push(head)\n    }\n    if (this.#size === 1) {\n      this.#head = this.#tail = 0 as Index\n      this.#free.length = 0\n    } else {\n      this.#head = this.#next[head] as Index\n    }\n    this.#keyMap.delete(k)\n    this.#size--\n    return head\n  }\n\n  /**\n   * Check if a key is in the cache, without updating the recency of use.\n   * Will return false if the item is stale, even though it is technically\n   * in the cache.\n   *\n   * Check if a key is in the cache, without updating the recency of\n   * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set\n   * to `true` in either the options or the constructor.\n   *\n   * Will return `false` if the item is stale, even though it is technically in\n   * the cache. The difference can be determined (if it matters) by using a\n   * `status` argument, and inspecting the `has` field.\n   *\n   * Will not update item age unless\n   * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.\n   */\n  has(k: K, hasOptions: LRUCache.HasOptions<K, V, FC> = {}) {\n    const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions\n    const index = this.#keyMap.get(k)\n    if (index !== undefined) {\n      const v = this.#valList[index]\n      if (\n        this.#isBackgroundFetch(v) &&\n        v.__staleWhileFetching === undefined\n      ) {\n        return false\n      }\n      if (!this.#isStale(index)) {\n        if (updateAgeOnHas) {\n          this.#updateItemAge(index)\n        }\n        if (status) {\n          status.has = 'hit'\n          this.#statusTTL(status, index)\n        }\n        return true\n      } else if (status) {\n        status.has = 'stale'\n        this.#statusTTL(status, index)\n      }\n    } else if (status) {\n      status.has = 'miss'\n    }\n    return false\n  }\n\n  /**\n   * Like {@link LRUCache#get} but doesn't update recency or delete stale\n   * items.\n   *\n   * Returns `undefined` if the item is stale, unless\n   * {@link LRUCache.OptionsBase.allowStale} is set.\n   */\n  peek(k: K, peekOptions: LRUCache.PeekOptions<K, V, FC> = {}) {\n    const { allowStale = this.allowStale } = peekOptions\n    const index = this.#keyMap.get(k)\n    if (index === undefined || (!allowStale && this.#isStale(index))) {\n      return\n    }\n    const v = this.#valList[index]\n    // either stale and allowed, or forcing a refresh of non-stale value\n    return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v\n  }\n\n  #backgroundFetch(\n    k: K,\n    index: Index | undefined,\n    options: LRUCache.FetchOptions<K, V, FC>,\n    context: any,\n  ): BackgroundFetch<V> {\n    const v = index === undefined ? undefined : this.#valList[index]\n    if (this.#isBackgroundFetch(v)) {\n      return v\n    }\n\n    const ac = new AC()\n    const { signal } = options\n    // when/if our AC signals, then stop listening to theirs.\n    signal?.addEventListener('abort', () => ac.abort(signal.reason), {\n      signal: ac.signal,\n    })\n\n    const fetchOpts = {\n      signal: ac.signal,\n      options,\n      context,\n    }\n\n    const cb = (v: V | undefined, updateCache = false): V | undefined => {\n      const { aborted } = ac.signal\n      const ignoreAbort = options.ignoreFetchAbort && v !== undefined\n      if (options.status) {\n        if (aborted && !updateCache) {\n          options.status.fetchAborted = true\n          options.status.fetchError = ac.signal.reason\n          if (ignoreAbort) options.status.fetchAbortIgnored = true\n        } else {\n          options.status.fetchResolved = true\n        }\n      }\n      if (aborted && !ignoreAbort && !updateCache) {\n        return fetchFail(ac.signal.reason)\n      }\n      // either we didn't abort, and are still here, or we did, and ignored\n      const bf = p as BackgroundFetch<V>\n      // if nothing else has been written there but we're set to update the\n      // cache and ignore the abort, or if it's still pending on this specific\n      // background request, then write it to the cache.\n      const vl = this.#valList[index as Index]\n      if (vl === p || (ignoreAbort && updateCache && vl === undefined)) {\n        if (v === undefined) {\n          if (bf.__staleWhileFetching !== undefined) {\n            this.#valList[index as Index] = bf.__staleWhileFetching\n          } else {\n            this.#delete(k, 'fetch')\n          }\n        } else {\n          if (options.status) options.status.fetchUpdated = true\n          this.set(k, v, fetchOpts.options)\n        }\n      }\n      return v\n    }\n\n    const eb = (er: any) => {\n      if (options.status) {\n        options.status.fetchRejected = true\n        options.status.fetchError = er\n      }\n      return fetchFail(er)\n    }\n\n    const fetchFail = (er: any): V | undefined => {\n      const { aborted } = ac.signal\n      const allowStaleAborted = aborted && options.allowStaleOnFetchAbort\n      const allowStale =\n        allowStaleAborted || options.allowStaleOnFetchRejection\n      const noDelete = allowStale || options.noDeleteOnFetchRejection\n      const bf = p as BackgroundFetch<V>\n      if (this.#valList[index as Index] === p) {\n        // if we allow stale on fetch rejections, then we need to ensure that\n        // the stale value is not removed from the cache when the fetch fails.\n        const del = !noDelete || bf.__staleWhileFetching === undefined\n        if (del) {\n          this.#delete(k, 'fetch')\n        } else if (!allowStaleAborted) {\n          // still replace the *promise* with the stale value,\n          // since we are done with the promise at this point.\n          // leave it untouched if we're still waiting for an\n          // aborted background fetch that hasn't yet returned.\n          this.#valList[index as Index] = bf.__staleWhileFetching\n        }\n      }\n      if (allowStale) {\n        if (options.status && bf.__staleWhileFetching !== undefined) {\n          options.status.returnedStale = true\n        }\n        return bf.__staleWhileFetching\n      } else if (bf.__returned === bf) {\n        throw er\n      }\n    }\n\n    const pcall = (\n      res: (v: V | undefined) => void,\n      rej: (e: any) => void,\n    ) => {\n      const fmp = this.#fetchMethod?.(k, v, fetchOpts)\n      if (fmp && fmp instanceof Promise) {\n        fmp.then(v => res(v === undefined ? undefined : v), rej)\n      }\n      // ignored, we go until we finish, regardless.\n      // defer check until we are actually aborting,\n      // so fetchMethod can override.\n      ac.signal.addEventListener('abort', () => {\n        if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {\n          res(undefined)\n          // when it eventually resolves, update the cache.\n          if (options.allowStaleOnFetchAbort) {\n            res = v => cb(v, true)\n          }\n        }\n      })\n    }\n\n    if (options.status) options.status.fetchDispatched = true\n    const p = new Promise(pcall).then(cb, eb)\n    const bf: BackgroundFetch<V> = Object.assign(p, {\n      __abortController: ac,\n      __staleWhileFetching: v,\n      __returned: undefined,\n    })\n\n    if (index === undefined) {\n      // internal, don't expose status.\n      this.set(k, bf, { ...fetchOpts.options, status: undefined })\n      index = this.#keyMap.get(k)\n    } else {\n      this.#valList[index] = bf\n    }\n    return bf\n  }\n\n  #isBackgroundFetch(p: any): p is BackgroundFetch<V> {\n    if (!this.#hasFetchMethod) return false\n    const b = p as BackgroundFetch<V>\n    return (\n      !!b &&\n      b instanceof Promise &&\n      b.hasOwnProperty('__staleWhileFetching') &&\n      b.__abortController instanceof AC\n    )\n  }\n\n  /**\n   * Make an asynchronous cached fetch using the\n   * {@link LRUCache.OptionsBase.fetchMethod} function.\n   *\n   * If the value is in the cache and not stale, then the returned\n   * Promise resolves to the value.\n   *\n   * If not in the cache, or beyond its TTL staleness, then\n   * `fetchMethod(key, staleValue, { options, signal, context })` is\n   * called, and the value returned will be added to the cache once\n   * resolved.\n   *\n   * If called with `allowStale`, and an asynchronous fetch is\n   * currently in progress to reload a stale value, then the former\n   * stale value will be returned.\n   *\n   * If called with `forceRefresh`, then the cached item will be\n   * re-fetched, even if it is not stale. However, if `allowStale` is also\n   * set, then the old value will still be returned. This is useful\n   * in cases where you want to force a reload of a cached value. If\n   * a background fetch is already in progress, then `forceRefresh`\n   * has no effect.\n   *\n   * If multiple fetches for the same key are issued, then they will all be\n   * coalesced into a single call to fetchMethod.\n   *\n   * Note that this means that handling options such as\n   * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort},\n   * {@link LRUCache.FetchOptions.signal},\n   * and {@link LRUCache.OptionsBase.allowStaleOnFetchRejection} will be\n   * determined by the FIRST fetch() call for a given key.\n   *\n   * This is a known (fixable) shortcoming which will be addresed on when\n   * someone complains about it, as the fix would involve added complexity and\n   * may not be worth the costs for this edge case.\n   *\n   * If {@link LRUCache.OptionsBase.fetchMethod} is not specified, then this is\n   * effectively an alias for `Promise.resolve(cache.get(key))`.\n   *\n   * When the fetch method resolves to a value, if the fetch has not\n   * been aborted due to deletion, eviction, or being overwritten,\n   * then it is added to the cache using the options provided.\n   *\n   * If the key is evicted or deleted before the `fetchMethod`\n   * resolves, then the AbortSignal passed to the `fetchMethod` will\n   * receive an `abort` event, and the promise returned by `fetch()`\n   * will reject with the reason for the abort.\n   *\n   * If a `signal` is passed to the `fetch()` call, then aborting the\n   * signal will abort the fetch and cause the `fetch()` promise to\n   * reject with the reason provided.\n   *\n   * **Setting `context`**\n   *\n   * If an `FC` type is set to a type other than `unknown`, `void`, or\n   * `undefined` in the {@link LRUCache} constructor, then all\n   * calls to `cache.fetch()` _must_ provide a `context` option. If\n   * set to `undefined` or `void`, then calls to fetch _must not_\n   * provide a `context` option.\n   *\n   * The `context` param allows you to provide arbitrary data that\n   * might be relevant in the course of fetching the data. It is only\n   * relevant for the course of a single `fetch()` operation, and\n   * discarded afterwards.\n   *\n   * **Note: `fetch()` calls are inflight-unique**\n   *\n   * If you call `fetch()` multiple times with the same key value,\n   * then every call after the first will resolve on the same\n   * promise<sup>1</sup>,\n   * _even if they have different settings that would otherwise change\n   * the behavior of the fetch_, such as `noDeleteOnFetchRejection`\n   * or `ignoreFetchAbort`.\n   *\n   * In most cases, this is not a problem (in fact, only fetching\n   * something once is what you probably want, if you're caching in\n   * the first place). If you are changing the fetch() options\n   * dramatically between runs, there's a good chance that you might\n   * be trying to fit divergent semantics into a single object, and\n   * would be better off with multiple cache instances.\n   *\n   * **1**: Ie, they're not the \"same Promise\", but they resolve at\n   * the same time, because they're both waiting on the same\n   * underlying fetchMethod response.\n   */\n\n  fetch(\n    k: K,\n    fetchOptions: unknown extends FC ? LRUCache.FetchOptions<K, V, FC>\n    : FC extends undefined | void ? LRUCache.FetchOptionsNoContext<K, V>\n    : LRUCache.FetchOptionsWithContext<K, V, FC>,\n  ): Promise<undefined | V>\n\n  // this overload not allowed if context is required\n  fetch(\n    k: unknown extends FC ? K\n    : FC extends undefined | void ? K\n    : never,\n    fetchOptions?: unknown extends FC ? LRUCache.FetchOptions<K, V, FC>\n    : FC extends undefined | void ? LRUCache.FetchOptionsNoContext<K, V>\n    : never,\n  ): Promise<undefined | V>\n\n  async fetch(\n    k: K,\n    fetchOptions: LRUCache.FetchOptions<K, V, FC> = {},\n  ): Promise<undefined | V> {\n    const {\n      // get options\n      allowStale = this.allowStale,\n      updateAgeOnGet = this.updateAgeOnGet,\n      noDeleteOnStaleGet = this.noDeleteOnStaleGet,\n      // set options\n      ttl = this.ttl,\n      noDisposeOnSet = this.noDisposeOnSet,\n      size = 0,\n      sizeCalculation = this.sizeCalculation,\n      noUpdateTTL = this.noUpdateTTL,\n      // fetch exclusive options\n      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,\n      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,\n      ignoreFetchAbort = this.ignoreFetchAbort,\n      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,\n      context,\n      forceRefresh = false,\n      status,\n      signal,\n    } = fetchOptions\n\n    if (!this.#hasFetchMethod) {\n      if (status) status.fetch = 'get'\n      return this.get(k, {\n        allowStale,\n        updateAgeOnGet,\n        noDeleteOnStaleGet,\n        status,\n      })\n    }\n\n    const options = {\n      allowStale,\n      updateAgeOnGet,\n      noDeleteOnStaleGet,\n      ttl,\n      noDisposeOnSet,\n      size,\n      sizeCalculation,\n      noUpdateTTL,\n      noDeleteOnFetchRejection,\n      allowStaleOnFetchRejection,\n      allowStaleOnFetchAbort,\n      ignoreFetchAbort,\n      status,\n      signal,\n    }\n\n    let index = this.#keyMap.get(k)\n    if (index === undefined) {\n      if (status) status.fetch = 'miss'\n      const p = this.#backgroundFetch(k, index, options, context)\n      return (p.__returned = p)\n    } else {\n      // in cache, maybe already fetching\n      const v = this.#valList[index]\n      if (this.#isBackgroundFetch(v)) {\n        const stale = allowStale && v.__staleWhileFetching !== undefined\n        if (status) {\n          status.fetch = 'inflight'\n          if (stale) status.returnedStale = true\n        }\n        return stale ? v.__staleWhileFetching : (v.__returned = v)\n      }\n\n      // if we force a refresh, that means do NOT serve the cached value,\n      // unless we are already in the process of refreshing the cache.\n      const isStale = this.#isStale(index)\n      if (!forceRefresh && !isStale) {\n        if (status) status.fetch = 'hit'\n        this.#moveToTail(index)\n        if (updateAgeOnGet) {\n          this.#updateItemAge(index)\n        }\n        if (status) this.#statusTTL(status, index)\n        return v\n      }\n\n      // ok, it is stale or a forced refresh, and not already fetching.\n      // refresh the cache.\n      const p = this.#backgroundFetch(k, index, options, context)\n      const hasStale = p.__staleWhileFetching !== undefined\n      const staleVal = hasStale && allowStale\n      if (status) {\n        status.fetch = isStale ? 'stale' : 'refresh'\n        if (staleVal && isStale) status.returnedStale = true\n      }\n      return staleVal ? p.__staleWhileFetching : (p.__returned = p)\n    }\n  }\n\n  /**\n   * In some cases, `cache.fetch()` may resolve to `undefined`, either because\n   * a {@link LRUCache.OptionsBase#fetchMethod} was not provided (turning\n   * `cache.fetch(k)` into just an async wrapper around `cache.get(k)`) or\n   * because `ignoreFetchAbort` was specified (either to the constructor or\n   * in the {@link LRUCache.FetchOptions}). Also, the\n   * {@link LRUCache.OptionsBase.fetchMethod} may return `undefined` or `void`, making\n   * the test even more complicated.\n   *\n   * Because inferring the cases where `undefined` might be returned are so\n   * cumbersome, but testing for `undefined` can also be annoying, this method\n   * can be used, which will reject if `this.fetch()` resolves to undefined.\n   */\n  forceFetch(\n    k: K,\n    fetchOptions: unknown extends FC ? LRUCache.FetchOptions<K, V, FC>\n    : FC extends undefined | void ? LRUCache.FetchOptionsNoContext<K, V>\n    : LRUCache.FetchOptionsWithContext<K, V, FC>,\n  ): Promise<V>\n  // this overload not allowed if context is required\n  forceFetch(\n    k: unknown extends FC ? K\n    : FC extends undefined | void ? K\n    : never,\n    fetchOptions?: unknown extends FC ? LRUCache.FetchOptions<K, V, FC>\n    : FC extends undefined | void ? LRUCache.FetchOptionsNoContext<K, V>\n    : never,\n  ): Promise<V>\n  async forceFetch(\n    k: K,\n    fetchOptions: LRUCache.FetchOptions<K, V, FC> = {},\n  ): Promise<V> {\n    const v = await this.fetch(\n      k,\n      fetchOptions as unknown extends FC ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void ? LRUCache.FetchOptionsNoContext<K, V>\n      : LRUCache.FetchOptionsWithContext<K, V, FC>,\n    )\n    if (v === undefined) throw new Error('fetch() returned undefined')\n    return v\n  }\n\n  /**\n   * If the key is found in the cache, then this is equivalent to\n   * {@link LRUCache#get}. If not, in the cache, then calculate the value using\n   * the {@link LRUCache.OptionsBase.memoMethod}, and add it to the cache.\n   *\n   * If an `FC` type is set to a type other than `unknown`, `void`, or\n   * `undefined` in the LRUCache constructor, then all calls to `cache.memo()`\n   * _must_ provide a `context` option. If set to `undefined` or `void`, then\n   * calls to memo _must not_ provide a `context` option.\n   *\n   * The `context` param allows you to provide arbitrary data that might be\n   * relevant in the course of fetching the data. It is only relevant for the\n   * course of a single `memo()` operation, and discarded afterwards.\n   */\n  memo(\n    k: K,\n    memoOptions: unknown extends FC ? LRUCache.MemoOptions<K, V, FC>\n    : FC extends undefined | void ? LRUCache.MemoOptionsNoContext<K, V>\n    : LRUCache.MemoOptionsWithContext<K, V, FC>,\n  ): V\n  // this overload not allowed if context is required\n  memo(\n    k: unknown extends FC ? K\n    : FC extends undefined | void ? K\n    : never,\n    memoOptions?: unknown extends FC ? LRUCache.MemoOptions<K, V, FC>\n    : FC extends undefined | void ? LRUCache.MemoOptionsNoContext<K, V>\n    : never,\n  ): V\n  memo(k: K, memoOptions: LRUCache.MemoOptions<K, V, FC> = {}) {\n    const memoMethod = this.#memoMethod\n    if (!memoMethod) {\n      throw new Error('no memoMethod provided to constructor')\n    }\n    const { context, forceRefresh, ...options } = memoOptions\n    const v = this.get(k, options)\n    if (!forceRefresh && v !== undefined) return v\n    const vv = memoMethod(k, v, {\n      options,\n      context,\n    } as LRUCache.MemoizerOptions<K, V, FC>)\n    this.set(k, vv, options)\n    return vv\n  }\n\n  /**\n   * Return a value from the cache. Will update the recency of the cache\n   * entry found.\n   *\n   * If the key is not found, get() will return `undefined`.\n   */\n  get(k: K, getOptions: LRUCache.GetOptions<K, V, FC> = {}) {\n    const {\n      allowStale = this.allowStale,\n      updateAgeOnGet = this.updateAgeOnGet,\n      noDeleteOnStaleGet = this.noDeleteOnStaleGet,\n      status,\n    } = getOptions\n    const index = this.#keyMap.get(k)\n    if (index !== undefined) {\n      const value = this.#valList[index]\n      const fetching = this.#isBackgroundFetch(value)\n      if (status) this.#statusTTL(status, index)\n      if (this.#isStale(index)) {\n        if (status) status.get = 'stale'\n        // delete only if not an in-flight background fetch\n        if (!fetching) {\n          if (!noDeleteOnStaleGet) {\n            this.#delete(k, 'expire')\n          }\n          if (status && allowStale) status.returnedStale = true\n          return allowStale ? value : undefined\n        } else {\n          if (\n            status &&\n            allowStale &&\n            value.__staleWhileFetching !== undefined\n          ) {\n            status.returnedStale = true\n          }\n          return allowStale ? value.__staleWhileFetching : undefined\n        }\n      } else {\n        if (status) status.get = 'hit'\n        // if we're currently fetching it, we don't actually have it yet\n        // it's not stale, which means this isn't a staleWhileRefetching.\n        // If it's not stale, and fetching, AND has a __staleWhileFetching\n        // value, then that means the user fetched with {forceRefresh:true},\n        // so it's safe to return that value.\n        if (fetching) {\n          return value.__staleWhileFetching\n        }\n        this.#moveToTail(index)\n        if (updateAgeOnGet) {\n          this.#updateItemAge(index)\n        }\n        return value\n      }\n    } else if (status) {\n      status.get = 'miss'\n    }\n  }\n\n  #connect(p: Index, n: Index) {\n    this.#prev[n] = p\n    this.#next[p] = n\n  }\n\n  #moveToTail(index: Index): void {\n    // if tail already, nothing to do\n    // if head, move head to next[index]\n    // else\n    //   move next[prev[index]] to next[index] (head has no prev)\n    //   move prev[next[index]] to prev[index]\n    // prev[index] = tail\n    // next[tail] = index\n    // tail = index\n    if (index !== this.#tail) {\n      if (index === this.#head) {\n        this.#head = this.#next[index] as Index\n      } else {\n        this.#connect(\n          this.#prev[index] as Index,\n          this.#next[index] as Index,\n        )\n      }\n      this.#connect(this.#tail, index)\n      this.#tail = index\n    }\n  }\n\n  /**\n   * Deletes a key out of the cache.\n   *\n   * Returns true if the key was deleted, false otherwise.\n   */\n  delete(k: K) {\n    return this.#delete(k, 'delete')\n  }\n\n  #delete(k: K, reason: LRUCache.DisposeReason) {\n    let deleted = false\n    if (this.#size !== 0) {\n      const index = this.#keyMap.get(k)\n      if (index !== undefined) {\n        if (this.#autopurgeTimers?.[index]) {\n          clearTimeout(this.#autopurgeTimers?.[index])\n          this.#autopurgeTimers[index] = undefined\n        }\n        deleted = true\n        if (this.#size === 1) {\n          this.#clear(reason)\n        } else {\n          this.#removeItemSize(index)\n          const v = this.#valList[index]\n          if (this.#isBackgroundFetch(v)) {\n            v.__abortController.abort(new Error('deleted'))\n          } else if (this.#hasDispose || this.#hasDisposeAfter) {\n            if (this.#hasDispose) {\n              this.#dispose?.(v as V, k, reason)\n            }\n            if (this.#hasDisposeAfter) {\n              this.#disposed?.push([v as V, k, reason])\n            }\n          }\n          this.#keyMap.delete(k)\n          this.#keyList[index] = undefined\n          this.#valList[index] = undefined\n          if (index === this.#tail) {\n            this.#tail = this.#prev[index] as Index\n          } else if (index === this.#head) {\n            this.#head = this.#next[index] as Index\n          } else {\n            const pi = this.#prev[index] as number\n            this.#next[pi] = this.#next[index] as number\n            const ni = this.#next[index] as number\n            this.#prev[ni] = this.#prev[index] as number\n          }\n          this.#size--\n          this.#free.push(index)\n        }\n      }\n    }\n    if (this.#hasDisposeAfter && this.#disposed?.length) {\n      const dt = this.#disposed\n      let task: DisposeTask<K, V> | undefined\n      while ((task = dt?.shift())) {\n        this.#disposeAfter?.(...task)\n      }\n    }\n    return deleted\n  }\n\n  /**\n   * Clear the cache entirely, throwing away all values.\n   */\n  clear() {\n    return this.#clear('delete')\n  }\n  #clear(reason: LRUCache.DisposeReason) {\n    for (const index of this.#rindexes({ allowStale: true })) {\n      const v = this.#valList[index]\n      if (this.#isBackgroundFetch(v)) {\n        v.__abortController.abort(new Error('deleted'))\n      } else {\n        const k = this.#keyList[index]\n        if (this.#hasDispose) {\n          this.#dispose?.(v as V, k as K, reason)\n        }\n        if (this.#hasDisposeAfter) {\n          this.#disposed?.push([v as V, k as K, reason])\n        }\n      }\n    }\n\n    this.#keyMap.clear()\n    this.#valList.fill(undefined)\n    this.#keyList.fill(undefined)\n    if (this.#ttls && this.#starts) {\n      this.#ttls.fill(0)\n      this.#starts.fill(0)\n      for (const t of this.#autopurgeTimers ?? []) {\n        if (t !== undefined) clearTimeout(t)\n      }\n      this.#autopurgeTimers?.fill(undefined)\n    }\n    if (this.#sizes) {\n      this.#sizes.fill(0)\n    }\n    this.#head = 0 as Index\n    this.#tail = 0 as Index\n    this.#free.length = 0\n    this.#calculatedSize = 0\n    this.#size = 0\n    if (this.#hasDisposeAfter && this.#disposed) {\n      const dt = this.#disposed\n      let task: DisposeTask<K, V> | undefined\n      while ((task = dt?.shift())) {\n        this.#disposeAfter?.(...task)\n      }\n    }\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 8261, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@apollo/server/dist/esm/plugin/usageReporting/iterateOverTrace.js","sources":["file:///E:/wark/Next.graphQL/nextTyar/node_modules/%40apollo/server/src/plugin/usageReporting/iterateOverTrace.ts"],"sourcesContent":["import type { Trace } from '@apollo/usage-reporting-protobuf';\n\n/**\n * Iterates over the entire trace, calling `f` on each Trace.Node found. It\n * looks under the \"root\" node as well as any inside the query plan. If any `f`\n * returns true, it stops walking the tree.\n *\n * Each call to `f` will receive an object that implements ResponseNamePath. If\n * `includePath` is true, `f` can call `toArray()` on it to convert the\n * linked-list representation to an array of the response name (field name)\n * nodes that you navigate to get to the node (including a \"service:subgraph\"\n * top-level node if this is a federated trace). Note that we don't add anything\n * to the path for index (list element) nodes. This is because the only use case\n * we have (error path statistics) does not care about list indexes (it's not\n * that interesting to know that sometimes an error was at foo.3.bar and\n * sometimes foo.5.bar, vs just generally foo.bar).\n *\n * If `includePath` is false, we don't bother to build up the linked lists, and\n * calling `toArray()` will throw.\n */\nexport function iterateOverTrace(\n  trace: Trace,\n  f: (node: Trace.INode, path: ResponseNamePath) => boolean,\n  includePath: boolean,\n) {\n  const rootPath = includePath\n    ? new RootCollectingPathsResponseNamePath()\n    : notCollectingPathsResponseNamePath;\n  if (trace.root) {\n    if (iterateOverTraceNode(trace.root, rootPath, f)) return;\n  }\n\n  if (trace.queryPlan) {\n    if (iterateOverQueryPlan(trace.queryPlan, rootPath, f)) return;\n  }\n}\n\n// Helper for iterateOverTrace; returns true to stop the overall walk.\nfunction iterateOverQueryPlan(\n  node: Trace.IQueryPlanNode,\n  rootPath: ResponseNamePath,\n  f: (node: Trace.INode, path: ResponseNamePath) => boolean,\n): boolean {\n  if (!node) return false;\n\n  if (node.fetch?.trace?.root && node.fetch.serviceName) {\n    return iterateOverTraceNode(\n      node.fetch.trace.root,\n      rootPath.child(`service:${node.fetch.serviceName}`),\n      f,\n    );\n  }\n  if (node.flatten?.node) {\n    return iterateOverQueryPlan(node.flatten.node, rootPath, f);\n  }\n  if (node.parallel?.nodes) {\n    // We want to stop as soon as some call returns true, which happens to be\n    // exactly what 'some' does.\n    return node.parallel.nodes.some((node) =>\n      iterateOverQueryPlan(node, rootPath, f),\n    );\n  }\n  if (node.sequence?.nodes) {\n    // We want to stop as soon as some call returns true, which happens to be\n    // exactly what 'some' does.\n    return node.sequence.nodes.some((node) =>\n      iterateOverQueryPlan(node, rootPath, f),\n    );\n  }\n\n  return false;\n}\n\n// Helper for iterateOverTrace; returns true to stop the overall walk.\nfunction iterateOverTraceNode(\n  node: Trace.INode,\n  path: ResponseNamePath,\n  f: (node: Trace.INode, path: ResponseNamePath) => boolean,\n): boolean {\n  // Invoke the function; if it returns true, don't descend and tell callers to\n  // stop walking.\n  if (f(node, path)) {\n    return true;\n  }\n\n  return (\n    // We want to stop as soon as some call returns true, which happens to be\n    // exactly what 'some' does.\n    node.child?.some((child) => {\n      const childPath = child.responseName\n        ? path.child(child.responseName)\n        : path;\n      return iterateOverTraceNode(child, childPath, f);\n    }) ?? false\n  );\n}\n\nexport interface ResponseNamePath {\n  toArray(): string[];\n  child(responseName: string): ResponseNamePath;\n}\n\nconst notCollectingPathsResponseNamePath: ResponseNamePath = {\n  toArray() {\n    throw Error('not collecting paths!');\n  },\n  child() {\n    return this;\n  },\n};\n\ntype CollectingPathsResponseNamePath =\n  | RootCollectingPathsResponseNamePath\n  | ChildCollectingPathsResponseNamePath;\nclass RootCollectingPathsResponseNamePath implements ResponseNamePath {\n  toArray() {\n    return [];\n  }\n  child(responseName: string) {\n    return new ChildCollectingPathsResponseNamePath(responseName, this);\n  }\n}\nclass ChildCollectingPathsResponseNamePath implements ResponseNamePath {\n  constructor(\n    readonly responseName: string,\n    readonly prev: CollectingPathsResponseNamePath,\n  ) {}\n  toArray() {\n    const out = [];\n    let curr: CollectingPathsResponseNamePath = this;\n    while (curr instanceof ChildCollectingPathsResponseNamePath) {\n      out.push(curr.responseName);\n      curr = curr.prev;\n    }\n    return out.reverse();\n  }\n  child(responseName: string) {\n    return new ChildCollectingPathsResponseNamePath(responseName, this);\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 8339, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@apollo/server/dist/esm/plugin/usageReporting/durationHistogram.js","sources":["file:///E:/wark/Next.graphQL/nextTyar/node_modules/%40apollo/server/src/plugin/usageReporting/durationHistogram.ts"],"sourcesContent":["export interface DurationHistogramOptions {\n  initSize?: number;\n  buckets?: number[];\n}\nexport class DurationHistogram {\n  // Note that it's legal for the values in \"buckets\" to be non-integers; they\n  // will be floored by toArray (which is called by the protobuf encoder).\n  // (We take advantage of this for field latencies specifically, because\n  // the ability to return a non-1 weight from fieldLevelInstrumentation\n  // means we want to build up our histograms as floating-point rather than\n  // rounding after every operation.)\n  private readonly buckets: number[];\n  static readonly BUCKET_COUNT = 384;\n  static readonly EXPONENT_LOG = Math.log(1.1);\n\n  toArray(): number[] {\n    let bufferedZeroes = 0;\n    const outputArray: number[] = [];\n\n    for (const value of this.buckets) {\n      if (value === 0) {\n        bufferedZeroes++;\n      } else {\n        if (bufferedZeroes === 1) {\n          outputArray.push(0);\n        } else if (bufferedZeroes !== 0) {\n          outputArray.push(-bufferedZeroes);\n        }\n        outputArray.push(Math.floor(value));\n        bufferedZeroes = 0;\n      }\n    }\n    return outputArray;\n  }\n\n  static durationToBucket(durationNs: number): number {\n    const log = Math.log(durationNs / 1000.0);\n    const unboundedBucket = Math.ceil(log / DurationHistogram.EXPONENT_LOG);\n\n    // Compare <= 0 to catch -0 and -infinity\n    return unboundedBucket <= 0 || Number.isNaN(unboundedBucket)\n      ? 0\n      : unboundedBucket >= DurationHistogram.BUCKET_COUNT\n        ? DurationHistogram.BUCKET_COUNT - 1\n        : unboundedBucket;\n  }\n\n  incrementDuration(durationNs: number, value = 1): DurationHistogram {\n    this.incrementBucket(DurationHistogram.durationToBucket(durationNs), value);\n    return this;\n  }\n\n  incrementBucket(bucket: number, value = 1) {\n    if (bucket >= DurationHistogram.BUCKET_COUNT) {\n      // Since we don't have fixed size arrays I'd rather throw the error manually\n      throw Error('Bucket is out of bounds of the buckets array');\n    }\n\n    // Extend the array if we haven't gotten it long enough to handle the new bucket\n    if (bucket >= this.buckets.length) {\n      const oldLength = this.buckets.length;\n      this.buckets.length = bucket + 1;\n      this.buckets.fill(0, oldLength);\n    }\n\n    this.buckets[bucket] += value;\n  }\n\n  combine(otherHistogram: DurationHistogram) {\n    for (let i = 0; i < otherHistogram.buckets.length; i++) {\n      this.incrementBucket(i, otherHistogram.buckets[i]);\n    }\n  }\n\n  constructor(options?: DurationHistogramOptions) {\n    const initSize = options?.initSize || 74;\n    const buckets = options?.buckets;\n\n    const arrayInitSize = Math.max(buckets?.length || 0, initSize);\n\n    this.buckets = Array<number>(arrayInitSize).fill(0);\n\n    if (buckets) {\n      buckets.forEach((val, index) => (this.buckets[index] = val));\n    }\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 8404, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@apollo/server/dist/esm/plugin/usageReporting/defaultSendOperationsAsTrace.js","sources":["file:///E:/wark/Next.graphQL/nextTyar/node_modules/%40apollo/server/src/plugin/usageReporting/defaultSendOperationsAsTrace.ts"],"sourcesContent":["import { LRUCache } from 'lru-cache';\nimport type { Trace } from '@apollo/usage-reporting-protobuf';\nimport { iterateOverTrace } from './iterateOverTrace.js';\nimport { DurationHistogram } from './durationHistogram.js';\n\nexport function defaultSendOperationsAsTrace() {\n  // We keep an LRU cache mapping from a trace key (which consists of the\n  // operation as defined by statsReportKey, the rough duration of the\n  // operation, what minute the operation ended at, etc) to `true` if we've seen\n  // it recently. We actually split this into one cache per minute so we can\n  // throw away a full minute's worth of cache at once; we keep only the last\n  // three minutes.\n  // Note that if a trace is over a certain size, we will always send it as\n  // stats. We check this within the addTrace function of the OurReport class so\n  // that we don't have to encode these large traces twice.\n  const cache = new LRUCache<string, true>({\n    // 3MiB limit, very much approximately since we can't be sure how V8 might\n    // be storing these strings internally. Though this should be enough to\n    // store a fair amount of trace keys.\n\n    // A future version of this might expose some\n    // configuration option to grow the cache, but ideally, we could do that\n    // dynamically based on the resources available to the server, and not add\n    // more configuration surface area. Hopefully the warning message will allow\n    // us to evaluate the need with more validated input from those that receive\n    // it.\n    maxSize: Math.pow(2, 20),\n    sizeCalculation: (_val, key) => {\n      return (key && Buffer.byteLength(key)) || 0;\n    },\n  });\n\n  return (trace: Trace, statsReportKey: string): boolean => {\n    const endTimeSeconds = trace.endTime?.seconds;\n    if (endTimeSeconds == null) {\n      throw Error('programming error: endTime not set on trace');\n    }\n\n    const hasErrors = traceHasErrors(trace);\n    const cacheKey = JSON.stringify([\n      statsReportKey,\n      DurationHistogram.durationToBucket(trace.durationNs),\n      // What minute it started at\n      Math.floor(endTimeSeconds / 60),\n      // If the trace has an error, send one errored trace per 5 second interval\n      // instead of the normal minutely bucket a non-errored trace takes.\n      hasErrors ? Math.floor(endTimeSeconds / 5) : '',\n    ]);\n\n    // If we've already seen something roughly like this, don't send as a trace.\n    if (cache.get(cacheKey)) {\n      return false;\n    }\n\n    cache.set(cacheKey, true);\n    return true;\n  };\n}\n\n// Returns true if any node on the trace has errors. (If this ends up being a\n// hot spot, we can precalculate it in TraceTreeBuilder.)\nfunction traceHasErrors(trace: Trace): boolean {\n  let hasErrors = false;\n\n  function traceNodeStats(node: Trace.INode): boolean {\n    if ((node.error?.length ?? 0) > 0) {\n      hasErrors = true;\n    }\n    return hasErrors;\n  }\n\n  iterateOverTrace(trace, traceNodeStats, false);\n  return hasErrors;\n}\n"],"names":[],"mappings":";;;;AAAA,OAAO,EAAE,QAAQ,EAAE,MAAM,WAAW,CAAC;AAErC,OAAO,EAAE,gBAAgB,EAAE,MAAM,uBAAuB,CAAC;AACzD,OAAO,EAAE,iBAAiB,EAAE,MAAM,wBAAwB,CAAC;;;;AAErD,SAAU,4BAA4B;IAU1C,MAAM,KAAK,GAAG,IAAI,wMAAQ,CAAe;QAWvC,OAAO,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC;QACxB,eAAe,EAAE,CAAC,IAAI,EAAE,GAAG,EAAE,EAAE;YAC7B,OAAO,AAAC,GAAG,IAAI,MAAM,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,GAAI,CAAC,CAAC;QAC9C,CAAC;KACF,CAAC,CAAC;IAEH,OAAO,CAAC,KAAY,EAAE,cAAsB,EAAW,EAAE;QACvD,MAAM,cAAc,GAAG,KAAK,CAAC,OAAO,EAAE,OAAO,CAAC;QAC9C,IAAI,cAAc,IAAI,IAAI,EAAE,CAAC;YAC3B,MAAM,KAAK,CAAC,6CAA6C,CAAC,CAAC;QAC7D,CAAC;QAED,MAAM,SAAS,GAAG,cAAc,CAAC,KAAK,CAAC,CAAC;QACxC,MAAM,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC;YAC9B,cAAc;YACd,yNAAiB,CAAC,gBAAgB,CAAC,KAAK,CAAC,UAAU,CAAC;YAEpD,IAAI,CAAC,KAAK,CAAC,cAAc,GAAG,EAAE,CAAC;YAG/B,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,cAAc,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE;SAChD,CAAC,CAAC;QAGH,IAAI,KAAK,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE,CAAC;YACxB,OAAO,KAAK,CAAC;QACf,CAAC;QAED,KAAK,CAAC,GAAG,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;QAC1B,OAAO,IAAI,CAAC;IACd,CAAC,CAAC;AACJ,CAAC;AAID,SAAS,cAAc,CAAC,KAAY;IAClC,IAAI,SAAS,GAAG,KAAK,CAAC;IAEtB,SAAS,cAAc,CAAC,IAAiB;QACvC,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,MAAM,IAAI,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC;YAClC,SAAS,GAAG,IAAI,CAAC;QACnB,CAAC;QACD,OAAO,SAAS,CAAC;IACnB,CAAC;QAED,uNAAgB,EAAC,KAAK,EAAE,cAAc,EAAE,KAAK,CAAC,CAAC;IAC/C,OAAO,SAAS,CAAC;AACnB,CAAC"}},
    {"offset": {"line": 8455, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@apollo/server/dist/esm/plugin/usageReporting/operationDerivedDataCache.js","sources":["file:///E:/wark/Next.graphQL/nextTyar/node_modules/%40apollo/server/src/plugin/usageReporting/operationDerivedDataCache.ts"],"sourcesContent":["import type { Logger } from '@apollo/utils.logger';\nimport type { ReferencedFieldsByType } from '@apollo/utils.usagereporting';\nimport { LRUCache } from 'lru-cache';\n\nexport interface OperationDerivedData {\n  signature: string;\n  referencedFieldsByType: ReferencedFieldsByType;\n}\n\nexport function createOperationDerivedDataCache({\n  logger,\n}: {\n  logger: Logger;\n}): LRUCache<string, OperationDerivedData> {\n  let lastWarn: Date;\n  let lastDisposals = 0;\n  return new LRUCache<string, OperationDerivedData>({\n    // Calculate the length of cache objects by the JSON.stringify byteLength.\n    sizeCalculation(obj) {\n      return Buffer.byteLength(JSON.stringify(obj), 'utf8');\n    },\n    // 10MiB limit, very much approximately since we can't be sure how V8 might\n    // be storing this data internally. Though this should be enough to store a\n    // fair amount of operation data, depending on their overall complexity. A\n    // future version of this might expose some configuration option to grow the\n    // cache, but ideally, we could do that dynamically based on the resources\n    // available to the server, and not add more configuration surface area.\n    // Hopefully the warning message will allow us to evaluate the need with\n    // more validated input from those that receive it.\n    maxSize: Math.pow(2, 20) * 10,\n    dispose() {\n      // Count the number of disposals between warning messages.\n      lastDisposals++;\n\n      // Only show a message warning about the high turnover every 60 seconds.\n      if (!lastWarn || new Date().getTime() - lastWarn.getTime() > 60000) {\n        // Log the time that we last displayed the message.\n        lastWarn = new Date();\n        logger.warn(\n          [\n            'This server is processing a high number of unique operations.  ',\n            `A total of ${lastDisposals} records have been `,\n            'ejected from the ApolloServerPluginUsageReporting signature cache in the past ',\n            'interval.  If you see this warning frequently, please open an ',\n            'issue on the Apollo Server repository.',\n          ].join(''),\n        );\n\n        // Reset the disposal counter for the next message interval.\n        lastDisposals = 0;\n      }\n    },\n  });\n}\n\nexport function operationDerivedDataCacheKey(\n  queryHash: string,\n  operationName: string,\n) {\n  return `${queryHash}${operationName && ':' + operationName}`;\n}\n"],"names":[],"mappings":";;;;;;AAEA,OAAO,EAAE,QAAQ,EAAE,MAAM,WAAW,CAAC;;AAO/B,SAAU,+BAA+B,CAAC,EAC9C,MAAM,EAGP;IACC,IAAI,QAAc,CAAC;IACnB,IAAI,aAAa,GAAG,CAAC,CAAC;IACtB,OAAO,IAAI,wMAAQ,CAA+B;QAEhD,eAAe,EAAC,GAAG;YACjB,OAAO,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,EAAE,MAAM,CAAC,CAAC;QACxD,CAAC;QASD,OAAO,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,EAAE;QAC7B,OAAO;YAEL,aAAa,EAAE,CAAC;YAGhB,IAAI,CAAC,QAAQ,IAAI,IAAI,IAAI,EAAE,CAAC,OAAO,EAAE,GAAG,QAAQ,CAAC,OAAO,EAAE,GAAG,KAAK,EAAE,CAAC;gBAEnE,QAAQ,GAAG,IAAI,IAAI,EAAE,CAAC;gBACtB,MAAM,CAAC,IAAI,CACT;oBACE,iEAAiE;oBACjE,CAAA,WAAA,EAAc,aAAa,CAAA,mBAAA,CAAqB;oBAChD,gFAAgF;oBAChF,gEAAgE;oBAChE,wCAAwC;iBACzC,CAAC,IAAI,CAAC,EAAE,CAAC,CACX,CAAC;gBAGF,aAAa,GAAG,CAAC,CAAC;YACpB,CAAC;QACH,CAAC;KACF,CAAC,CAAC;AACL,CAAC;AAEK,SAAU,4BAA4B,CAC1C,SAAiB,EACjB,aAAqB;IAErB,OAAO,GAAG,SAAS,GAAG,aAAa,IAAI,GAAG,GAAG,aAAa,EAAE,CAAC;AAC/D,CAAC"}},
    {"offset": {"line": 8494, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@apollo/server/dist/esm/plugin/usageReporting/stats.js","sources":["file:///E:/wark/Next.graphQL/nextTyar/node_modules/%40apollo/server/src/plugin/usageReporting/stats.ts"],"sourcesContent":["import type { NonFtv1ErrorPath } from '@apollo/server-gateway-interface';\nimport {\n  type google,\n  type IContextualizedStats,\n  type IFieldStat,\n  type IPathErrorStats,\n  type IQueryLatencyStats,\n  type IReport,\n  type IStatsContext,\n  type ITracesAndStats,\n  type ITypeStat,\n  type ReportHeader,\n  Trace,\n} from '@apollo/usage-reporting-protobuf';\nimport type { ReferencedFieldsByType } from '@apollo/utils.usagereporting';\nimport { DurationHistogram } from './durationHistogram.js';\nimport { iterateOverTrace, type ResponseNamePath } from './iterateOverTrace.js';\n\n// protobuf.js exports both a class and an interface (starting with I) for each\n// message type. The class is what it produces when it decodes the message; the\n// interface is what is accepted as input. We build up our messages using custom\n// types implementing the interfaces, so that we can take advantage of the\n// js_use_toArray option we added to our protobuf.js fork which allows us to use\n// classes like DurationHistogram to generate repeated fields. We end up\n// re-creating most of the report structure as custom classes (starting with\n// \"Our\"). TypeScript validates that we've properly listed all of the message\n// fields with the appropriate types (we use `Required` to ensure we implement\n// all message fields). Using our own classes has other advantages, like being\n// able to specify that nested messages are instances of the same class rather\n// than the interface type and thus that they have non-null fields (because the\n// interface type allows all fields to be optional, even though the protobuf\n// format doesn't differentiate between missing and falsey).\n\nexport class SizeEstimator {\n  bytes = 0;\n}\nexport class OurReport implements Required<IReport> {\n  // Apollo Server includes each operation either as aggregated stats or as a\n  // trace, but not both. Other reporting agents such as Apollo Router include\n  // all operations in stats (even those that are sent as traces), and they set\n  // this flag to true.\n  tracesPreAggregated = false;\n\n  constructor(readonly header: ReportHeader) {}\n  readonly tracesPerQuery: Record<string, OurTracesAndStats> =\n    Object.create(null);\n  endTime: google.protobuf.ITimestamp | null = null;\n  operationCount = 0;\n  // A rough estimate of the number of bytes currently in the report. We start\n  // at zero and don't count `header` and `endTime`, which have the same size\n  // for every report. This really is a rough estimate, so we don't stress too\n  // much about counting bytes for the tags and string/message lengths, etc:\n  // we mostly just count the lengths of strings plus some estimates for the\n  // messages with a bunch of numbers in them.\n  //\n  // We store this in a class so we can pass it down as a reference to other\n  // methods which increment it.\n  readonly sizeEstimator = new SizeEstimator();\n\n  ensureCountsAreIntegers() {\n    for (const tracesAndStats of Object.values(this.tracesPerQuery)) {\n      tracesAndStats.ensureCountsAreIntegers();\n    }\n  }\n\n  addTrace({\n    statsReportKey,\n    trace,\n    asTrace,\n    referencedFieldsByType,\n    // The max size a trace can be before it is sent as stats. Note that the\n    // Apollo reporting ingress server will never store any traces over 10mb\n    // anyway. They will still be converted to stats as we would do here.\n    maxTraceBytes = 10 * 1024 * 1024,\n    nonFtv1ErrorPaths,\n  }: {\n    statsReportKey: string;\n    trace: Trace;\n    asTrace: boolean;\n    referencedFieldsByType: ReferencedFieldsByType;\n    maxTraceBytes?: number;\n    nonFtv1ErrorPaths: NonFtv1ErrorPath[];\n  }) {\n    const tracesAndStats = this.getTracesAndStats({\n      statsReportKey,\n      referencedFieldsByType,\n    });\n    if (asTrace) {\n      const encodedTrace = Trace.encode(trace).finish();\n\n      if (!isNaN(maxTraceBytes) && encodedTrace.length > maxTraceBytes) {\n        tracesAndStats.statsWithContext.addTrace(\n          trace,\n          this.sizeEstimator,\n          nonFtv1ErrorPaths,\n        );\n      } else {\n        tracesAndStats.trace.push(encodedTrace);\n        this.sizeEstimator.bytes += 2 + encodedTrace.length;\n      }\n    } else {\n      tracesAndStats.statsWithContext.addTrace(\n        trace,\n        this.sizeEstimator,\n        nonFtv1ErrorPaths,\n      );\n    }\n  }\n\n  private getTracesAndStats({\n    statsReportKey,\n    referencedFieldsByType,\n  }: {\n    statsReportKey: string;\n    referencedFieldsByType: ReferencedFieldsByType;\n  }) {\n    const existing = this.tracesPerQuery[statsReportKey];\n    if (existing) {\n      return existing;\n    }\n    this.sizeEstimator.bytes += estimatedBytesForString(statsReportKey);\n\n    // Update the size estimator for the referenced field structure.\n    for (const [typeName, referencedFieldsForType] of Object.entries(\n      referencedFieldsByType,\n    )) {\n      // Two bytes each for the map entry and for the ReferencedFieldsForType,\n      // and for the isInterface bool if it's set.\n      this.sizeEstimator.bytes += 2 + 2;\n      if (referencedFieldsForType.isInterface) {\n        this.sizeEstimator.bytes += 2;\n      }\n      this.sizeEstimator.bytes += estimatedBytesForString(typeName);\n      for (const fieldName of referencedFieldsForType.fieldNames) {\n        this.sizeEstimator.bytes += estimatedBytesForString(fieldName);\n      }\n    }\n\n    // Include the referenced fields map in the report. (In an ideal world we\n    // could have a slightly more sophisticated protocol and ingestion pipeline\n    // that allowed us to only have to send this data once for each\n    // schema/operation pair.)\n    return (this.tracesPerQuery[statsReportKey] = new OurTracesAndStats(\n      referencedFieldsByType,\n    ));\n  }\n}\n\nclass OurTracesAndStats implements Required<ITracesAndStats> {\n  constructor(readonly referencedFieldsByType: ReferencedFieldsByType) {}\n  readonly trace: Uint8Array[] = [];\n  readonly statsWithContext = new StatsByContext();\n  readonly internalTracesContributingToStats: Uint8Array[] = [];\n\n  ensureCountsAreIntegers() {\n    this.statsWithContext.ensureCountsAreIntegers();\n  }\n}\n\nclass StatsByContext {\n  readonly map: { [k: string]: OurContextualizedStats } = Object.create(null);\n\n  /**\n   * This function is used by the protobuf generator to convert this map into\n   * an array of contextualized stats to serialize\n   */\n  toArray(): IContextualizedStats[] {\n    return Object.values(this.map);\n  }\n\n  ensureCountsAreIntegers() {\n    for (const contextualizedStats of Object.values(this.map)) {\n      contextualizedStats.ensureCountsAreIntegers();\n    }\n  }\n\n  addTrace(\n    trace: Trace,\n    sizeEstimator: SizeEstimator,\n    nonFtv1ErrorPaths: NonFtv1ErrorPath[],\n  ) {\n    this.getContextualizedStats(trace, sizeEstimator).addTrace(\n      trace,\n      sizeEstimator,\n      nonFtv1ErrorPaths,\n    );\n  }\n\n  private getContextualizedStats(\n    trace: Trace,\n    sizeEstimator: SizeEstimator,\n  ): OurContextualizedStats {\n    const statsContext: IStatsContext = {\n      clientName: trace.clientName,\n      clientVersion: trace.clientVersion,\n    };\n    const statsContextKey = JSON.stringify(statsContext);\n\n    const existing = this.map[statsContextKey];\n    if (existing) {\n      return existing;\n    }\n    // Adding a ContextualizedStats means adding a StatsContext plus a\n    // QueryLatencyStats. Let's guess about 20 bytes for a QueryLatencyStats;\n    // it'll be more if more features are used (like cache, APQ, etc).\n    sizeEstimator.bytes +=\n      20 +\n      estimatedBytesForString(trace.clientName) +\n      estimatedBytesForString(trace.clientVersion);\n    const contextualizedStats = new OurContextualizedStats(statsContext);\n    this.map[statsContextKey] = contextualizedStats;\n    return contextualizedStats;\n  }\n}\n\nexport class OurContextualizedStats implements Required<IContextualizedStats> {\n  queryLatencyStats = new OurQueryLatencyStats();\n  perTypeStat: { [k: string]: OurTypeStat } = Object.create(null);\n\n  constructor(readonly context: IStatsContext) {}\n\n  ensureCountsAreIntegers() {\n    for (const typeStat of Object.values(this.perTypeStat)) {\n      typeStat.ensureCountsAreIntegers();\n    }\n  }\n\n  // Extract statistics from the trace, and increment the estimated report size.\n  // We only add to the estimate when adding whole sub-messages. If it really\n  // mattered, we could do a lot more careful things like incrementing it\n  // whenever a numeric field on queryLatencyStats gets incremented over 0.\n  addTrace(\n    trace: Trace,\n    sizeEstimator: SizeEstimator,\n    nonFtv1ErrorPaths: NonFtv1ErrorPath[] = [],\n  ) {\n    const { fieldExecutionWeight } = trace;\n    if (!fieldExecutionWeight) {\n      this.queryLatencyStats.requestsWithoutFieldInstrumentation++;\n    }\n\n    this.queryLatencyStats.requestCount++;\n    if (trace.fullQueryCacheHit) {\n      this.queryLatencyStats.cacheLatencyCount.incrementDuration(\n        trace.durationNs,\n      );\n      this.queryLatencyStats.cacheHits++;\n    } else {\n      this.queryLatencyStats.latencyCount.incrementDuration(trace.durationNs);\n    }\n\n    // We only provide stats about cache TTLs on cache misses (ie, TTLs directly\n    // calculated by the backend), not for cache hits. This matches the\n    // behavior we've had for a while when converting traces into statistics\n    // in Studio's servers.\n    if (!trace.fullQueryCacheHit && trace.cachePolicy?.maxAgeNs != null) {\n      switch (trace.cachePolicy.scope) {\n        case Trace.CachePolicy.Scope.PRIVATE:\n          this.queryLatencyStats.privateCacheTtlCount.incrementDuration(\n            trace.cachePolicy.maxAgeNs,\n          );\n          break;\n        case Trace.CachePolicy.Scope.PUBLIC:\n          this.queryLatencyStats.publicCacheTtlCount.incrementDuration(\n            trace.cachePolicy.maxAgeNs,\n          );\n          break;\n      }\n    }\n\n    if (trace.persistedQueryHit) {\n      this.queryLatencyStats.persistedQueryHits++;\n    }\n    if (trace.persistedQueryRegister) {\n      this.queryLatencyStats.persistedQueryMisses++;\n    }\n\n    if (trace.forbiddenOperation) {\n      this.queryLatencyStats.forbiddenOperationCount++;\n    }\n    if (trace.registeredOperation) {\n      this.queryLatencyStats.registeredOperationCount++;\n    }\n\n    let hasError = false;\n\n    const errorPathStats = new Set<OurPathErrorStats>();\n\n    const traceNodeStats = (node: Trace.INode, path: ResponseNamePath) => {\n      // Generate error stats and error path information\n      if (node.error?.length) {\n        hasError = true;\n\n        let currPathErrorStats = this.queryLatencyStats.rootErrorStats;\n        path.toArray().forEach((subPath) => {\n          currPathErrorStats = currPathErrorStats.getChild(\n            subPath,\n            sizeEstimator,\n          );\n        });\n\n        errorPathStats.add(currPathErrorStats);\n        currPathErrorStats.errorsCount += node.error.length;\n      }\n\n      if (fieldExecutionWeight) {\n        // The actual field name behind the node; originalFieldName is set\n        // if an alias was used, otherwise responseName. (This is falsey for\n        // nodes that are not fields (root, array index, etc).)\n        const fieldName = node.originalFieldName || node.responseName;\n\n        // Protobuf doesn't really differentiate between \"unset\" and \"falsey\" so\n        // we're mostly actually checking that these things are non-empty string /\n        // non-zero numbers. The time fields represent the number of nanoseconds\n        // since the beginning of the entire trace, so let's pretend for the\n        // moment that it's plausible for a node to start or even end exactly when\n        // the trace started (ie, for the time values to be 0). This is unlikely\n        // in practice (everything should take at least 1ns). In practice we only\n        // write `type` and `parentType` on a Node when we write `startTime`, so\n        // the main thing we're looking out for by checking the time values is\n        // whether we somehow failed to write `endTime` at the end of the field;\n        // in this case, the `endTime >= startTime` check won't match.\n        if (\n          node.parentType &&\n          fieldName &&\n          node.type &&\n          node.endTime != null &&\n          node.startTime != null &&\n          node.endTime >= node.startTime\n        ) {\n          const typeStat = this.getTypeStat(node.parentType, sizeEstimator);\n\n          const fieldStat = typeStat.getFieldStat(\n            fieldName,\n            node.type,\n            sizeEstimator,\n          );\n\n          fieldStat.errorsCount += node.error?.length ?? 0;\n          fieldStat.observedExecutionCount++;\n          fieldStat.estimatedExecutionCount += fieldExecutionWeight;\n          // Note: this is actually counting the number of resolver calls for this\n          // field that had at least one error, not the number of overall GraphQL\n          // queries that had at least one error for this field. That doesn't seem\n          // to match the name, but it does match the other implementations of this\n          // logic.\n          fieldStat.requestsWithErrorsCount +=\n            (node.error?.length ?? 0) > 0 ? 1 : 0;\n          fieldStat.latencyCount.incrementDuration(\n            node.endTime - node.startTime,\n            // The latency histogram is always \"estimated\"; we don't track\n            // \"observed\" and \"estimated\" separately.\n            fieldExecutionWeight,\n          );\n        }\n      }\n\n      return false;\n    };\n\n    iterateOverTrace(trace, traceNodeStats, true);\n\n    // iterate over nonFtv1ErrorPaths, using some bits from traceNodeStats function\n    for (const { subgraph, path } of nonFtv1ErrorPaths) {\n      hasError = true;\n      if (path) {\n        let currPathErrorStats = this.queryLatencyStats.rootErrorStats.getChild(\n          `service:${subgraph}`,\n          sizeEstimator,\n        );\n        path.forEach((subPath) => {\n          if (typeof subPath === 'string') {\n            currPathErrorStats = currPathErrorStats.getChild(\n              subPath,\n              sizeEstimator,\n            );\n          }\n        });\n\n        errorPathStats.add(currPathErrorStats);\n        currPathErrorStats.errorsCount += 1;\n      }\n    }\n\n    for (const errorPath of errorPathStats) {\n      errorPath.requestsWithErrorsCount += 1;\n    }\n\n    if (hasError) {\n      this.queryLatencyStats.requestsWithErrorsCount++;\n    }\n  }\n\n  getTypeStat(parentType: string, sizeEstimator: SizeEstimator): OurTypeStat {\n    const existing = this.perTypeStat[parentType];\n    if (existing) {\n      return existing;\n    }\n    sizeEstimator.bytes += estimatedBytesForString(parentType);\n    const typeStat = new OurTypeStat();\n    this.perTypeStat[parentType] = typeStat;\n    return typeStat;\n  }\n}\n\nclass OurQueryLatencyStats implements Required<IQueryLatencyStats> {\n  latencyCount: DurationHistogram = new DurationHistogram();\n  requestCount = 0;\n  requestsWithoutFieldInstrumentation = 0;\n  cacheHits = 0;\n  persistedQueryHits = 0;\n  persistedQueryMisses = 0;\n  cacheLatencyCount: DurationHistogram = new DurationHistogram();\n  rootErrorStats: OurPathErrorStats = new OurPathErrorStats();\n  requestsWithErrorsCount = 0;\n  publicCacheTtlCount: DurationHistogram = new DurationHistogram();\n  privateCacheTtlCount: DurationHistogram = new DurationHistogram();\n  registeredOperationCount = 0;\n  forbiddenOperationCount = 0;\n}\n\nclass OurPathErrorStats implements Required<IPathErrorStats> {\n  children: { [k: string]: OurPathErrorStats } = Object.create(null);\n  errorsCount = 0;\n  requestsWithErrorsCount = 0;\n\n  getChild(subPath: string, sizeEstimator: SizeEstimator): OurPathErrorStats {\n    const existing = this.children[subPath];\n    if (existing) {\n      return existing;\n    }\n    const child = new OurPathErrorStats();\n    this.children[subPath] = child;\n    // Include a few bytes in the estimate for the numbers etc.\n    sizeEstimator.bytes += estimatedBytesForString(subPath) + 4;\n    return child;\n  }\n}\n\nclass OurTypeStat implements Required<ITypeStat> {\n  perFieldStat: { [k: string]: OurFieldStat } = Object.create(null);\n\n  getFieldStat(\n    fieldName: string,\n    returnType: string,\n    sizeEstimator: SizeEstimator,\n  ): OurFieldStat {\n    const existing = this.perFieldStat[fieldName];\n    if (existing) {\n      return existing;\n    }\n    // Rough estimate of 10 bytes for the numbers in the FieldStat.\n    sizeEstimator.bytes +=\n      estimatedBytesForString(fieldName) +\n      estimatedBytesForString(returnType) +\n      10;\n    const fieldStat = new OurFieldStat(returnType);\n    this.perFieldStat[fieldName] = fieldStat;\n    return fieldStat;\n  }\n\n  ensureCountsAreIntegers() {\n    for (const fieldStat of Object.values(this.perFieldStat)) {\n      fieldStat.ensureCountsAreIntegers();\n    }\n  }\n}\n\nclass OurFieldStat implements Required<IFieldStat> {\n  errorsCount = 0;\n  observedExecutionCount = 0;\n  // Note that this number isn't necessarily an integer while it is being\n  // aggregated. Before encoding as a protobuf we call ensureCountsAreIntegers\n  // which floors it.\n  estimatedExecutionCount = 0;\n  requestsWithErrorsCount = 0;\n  latencyCount: DurationHistogram = new DurationHistogram();\n\n  constructor(readonly returnType: string) {}\n\n  ensureCountsAreIntegers() {\n    // This is the only one that ever can receive non-integers.\n    this.estimatedExecutionCount = Math.floor(this.estimatedExecutionCount);\n  }\n}\n\nfunction estimatedBytesForString(s: string) {\n  // 2 is for the tag (field ID + wire type) plus the encoded length. (The\n  // encoded length takes up more than 1 byte for strings that are longer than\n  // 127 bytes, but this is an estimate.)\n  return 2 + Buffer.byteLength(s);\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 8776, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@apollo/server/dist/esm/plugin/usageReporting/traceDetails.js","sources":["file:///E:/wark/Next.graphQL/nextTyar/node_modules/%40apollo/server/src/plugin/usageReporting/traceDetails.ts"],"sourcesContent":["import { Trace } from '@apollo/usage-reporting-protobuf';\nimport type { VariableValueOptions } from './options.js';\n\n// Creates trace details from request variables, given a specification for modifying\n// values of private or sensitive variables.\n// The details will include all variable names and their (possibly hidden or modified) values.\n// If sendVariableValues is {all: bool}, {none: bool} or {exceptNames: Array}, the option will act similarly to\n// to the to-be-deprecated options.privateVariables, except that the redacted variable\n// names will still be visible in the UI even if the values are hidden.\n// If sendVariableValues is null or undefined, we default to the {none: true} case.\nexport function makeTraceDetails(\n  variables: Record<string, any>,\n  sendVariableValues?: VariableValueOptions,\n  operationString?: string,\n): Trace.Details {\n  const details = new Trace.Details();\n  const variablesToRecord = (() => {\n    if (sendVariableValues && 'transform' in sendVariableValues) {\n      const originalKeys = Object.keys(variables);\n      try {\n        // Custom function to allow user to specify what variablesJson will look like\n        const modifiedVariables = sendVariableValues.transform({\n          variables: variables,\n          operationString: operationString,\n        });\n        return cleanModifiedVariables(originalKeys, modifiedVariables);\n      } catch (e) {\n        // If the custom function provided by the user throws an exception,\n        // change all the variable values to an appropriate error message.\n        return handleVariableValueTransformError(originalKeys);\n      }\n    } else {\n      return variables;\n    }\n  })();\n\n  // Note: we explicitly do *not* include the details.rawQuery field. The\n  // Studio web app currently does nothing with this other than store it in\n  // the database and offer it up via its GraphQL API, and sending it means\n  // that using calculateSignature to hide sensitive data in the query\n  // string is ineffective.\n  Object.keys(variablesToRecord).forEach((name) => {\n    if (\n      !sendVariableValues ||\n      ('none' in sendVariableValues && sendVariableValues.none) ||\n      ('all' in sendVariableValues && !sendVariableValues.all) ||\n      ('exceptNames' in sendVariableValues &&\n        // We assume that most users will have only a few variables values to hide,\n        // or will just set {none: true}; we can change this\n        // linear-time operation if it causes real performance issues.\n        sendVariableValues.exceptNames.includes(name)) ||\n      ('onlyNames' in sendVariableValues &&\n        !sendVariableValues.onlyNames.includes(name))\n    ) {\n      // Special case for private variables. Note that this is a different\n      // representation from a variable containing the empty string, as that\n      // will be sent as '\"\"'.\n      details.variablesJson![name] = '';\n    } else {\n      try {\n        details.variablesJson![name] =\n          typeof variablesToRecord[name] === 'undefined'\n            ? ''\n            : JSON.stringify(variablesToRecord[name]);\n      } catch (e) {\n        details.variablesJson![name] = JSON.stringify(\n          '[Unable to convert value to JSON]',\n        );\n      }\n    }\n  });\n  return details;\n}\n\nfunction handleVariableValueTransformError(\n  variableNames: string[],\n): Record<string, any> {\n  const modifiedVariables = Object.create(null);\n  variableNames.forEach((name) => {\n    modifiedVariables[name] = '[PREDICATE_FUNCTION_ERROR]';\n  });\n  return modifiedVariables;\n}\n\n// Helper for makeTraceDetails() to enforce that the keys of a modified 'variables'\n// matches that of the original 'variables'\nfunction cleanModifiedVariables(\n  originalKeys: Array<string>,\n  modifiedVariables: Record<string, any>,\n): Record<string, any> {\n  const cleanedVariables: Record<string, any> = Object.create(null);\n  originalKeys.forEach((name) => {\n    cleanedVariables[name] = modifiedVariables[name];\n  });\n  return cleanedVariables;\n}\n"],"names":[],"mappings":";;;;AAAA,OAAO,EAAE,KAAK,EAAE,MAAM,kCAAkC,CAAC;;AAUnD,SAAU,gBAAgB,CAC9B,SAA8B,EAC9B,kBAAyC,EACzC,eAAwB;IAExB,MAAM,OAAO,GAAG,IAAI,qMAAK,CAAC,OAAO,EAAE,CAAC;IACpC,MAAM,iBAAiB,GAAG,CAAC,GAAG,EAAE;QAC9B,IAAI,kBAAkB,IAAI,WAAW,IAAI,kBAAkB,EAAE,CAAC;YAC5D,MAAM,YAAY,GAAG,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;YAC5C,IAAI,CAAC;gBAEH,MAAM,iBAAiB,GAAG,kBAAkB,CAAC,SAAS,CAAC;oBACrD,SAAS,EAAE,SAAS;oBACpB,eAAe,EAAE,eAAe;iBACjC,CAAC,CAAC;gBACH,OAAO,sBAAsB,CAAC,YAAY,EAAE,iBAAiB,CAAC,CAAC;YACjE,CAAC,CAAC,OAAO,CAAC,EAAE,CAAC;gBAGX,OAAO,iCAAiC,CAAC,YAAY,CAAC,CAAC;YACzD,CAAC;QACH,CAAC,MAAM,CAAC;YACN,OAAO,SAAS,CAAC;QACnB,CAAC;IACH,CAAC,CAAC,EAAE,CAAC;IAOL,MAAM,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE;QAC9C,IACE,CAAC,kBAAkB,IAClB,MAAM,IAAI,kBAAkB,IAAI,kBAAkB,CAAC,IAAI,CAAC,GACxD,KAAK,IAAI,kBAAkB,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,GACvD,aAAa,IAAI,kBAAkB,IAIlC,kBAAkB,CAAC,WAAW,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,GAC/C,WAAW,IAAI,kBAAkB,IAChC,CAAC,kBAAkB,CAAC,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAC/C,CAAC;YAID,OAAO,CAAC,aAAc,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC;QACpC,CAAC,MAAM,CAAC;YACN,IAAI,CAAC;gBACH,OAAO,CAAC,aAAc,CAAC,IAAI,CAAC,GAC1B,OAAO,iBAAiB,CAAC,IAAI,CAAC,KAAK,WAAW,GAC1C,EAAE,GACF,IAAI,CAAC,SAAS,CAAC,iBAAiB,CAAC,IAAI,CAAC,CAAC,CAAC;YAChD,CAAC,CAAC,OAAO,CAAC,EAAE,CAAC;gBACX,OAAO,CAAC,aAAc,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,SAAS,CAC3C,mCAAmC,CACpC,CAAC;YACJ,CAAC;QACH,CAAC;IACH,CAAC,CAAC,CAAC;IACH,OAAO,OAAO,CAAC;AACjB,CAAC;AAED,SAAS,iCAAiC,CACxC,aAAuB;IAEvB,MAAM,iBAAiB,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;IAC9C,aAAa,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE;QAC7B,iBAAiB,CAAC,IAAI,CAAC,GAAG,4BAA4B,CAAC;IACzD,CAAC,CAAC,CAAC;IACH,OAAO,iBAAiB,CAAC;AAC3B,CAAC;AAID,SAAS,sBAAsB,CAC7B,YAA2B,EAC3B,iBAAsC;IAEtC,MAAM,gBAAgB,GAAwB,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;IAClE,YAAY,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE;QAC5B,gBAAgB,CAAC,IAAI,CAAC,GAAG,iBAAiB,CAAC,IAAI,CAAC,CAAC;IACnD,CAAC,CAAC,CAAC;IACH,OAAO,gBAAgB,CAAC;AAC1B,CAAC"}},
    {"offset": {"line": 8831, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@apollo/server/dist/esm/generated/packageVersion.js","sources":["file:///E:/wark/Next.graphQL/nextTyar/node_modules/%40apollo/server/src/generated/packageVersion.ts"],"sourcesContent":["export const packageVersion = \"5.2.0\";\n"],"names":[],"mappings":";;;;AAAO,MAAM,cAAc,GAAG,OAAO,CAAC"}},
    {"offset": {"line": 8840, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@apollo/server/dist/esm/plugin/schemaIsSubgraph.js","sources":["file:///E:/wark/Next.graphQL/nextTyar/node_modules/%40apollo/server/src/plugin/schemaIsSubgraph.ts"],"sourcesContent":["import {\n  type GraphQLSchema,\n  isObjectType,\n  isScalarType,\n  isNonNullType,\n} from 'graphql';\n\n// Returns true if it appears that the schema was appears to be of a subgraph\n// (eg, returned from @apollo/subgraph's buildSubgraphSchema). This strategy\n// avoids depending explicitly on @apollo/subgraph or relying on something that\n// might not survive transformations like monkey-patching a boolean field onto\n// the schema.\n//\n// This is used for two things:\n// 1) Determining whether traces should be added to responses if requested with\n//    an HTTP header. If you want to include these traces even for non-subgraphs\n//    (when requested via header, eg for Apollo Explorer's trace view) you can\n//    use ApolloServerPluginInlineTrace explicitly; if you want to never include\n//    these traces even for subgraphs you can use\n//    ApolloServerPluginInlineTraceDisabled.\n// 2) Determining whether schema-reporting should be allowed; subgraphs cannot\n//    report schemas, and we accordingly throw if it's attempted.\nexport function schemaIsSubgraph(schema: GraphQLSchema): boolean {\n  const serviceType = schema.getType('_Service');\n  if (!isObjectType(serviceType)) {\n    return false;\n  }\n  const sdlField = serviceType.getFields().sdl;\n  if (!sdlField) {\n    return false;\n  }\n\n  let sdlFieldType = sdlField.type;\n  if (isNonNullType(sdlFieldType)) {\n    sdlFieldType = sdlFieldType.ofType;\n  }\n  if (!isScalarType(sdlFieldType)) {\n    return false;\n  }\n  return sdlFieldType.name == 'String';\n}\n"],"names":[],"mappings":";;;;AAAA,OAAO,EAEL,YAAY,EACZ,YAAY,EACZ,aAAa,GACd,MAAM,SAAS,CAAC;;AAiBX,SAAU,gBAAgB,CAAC,MAAqB;IACpD,MAAM,WAAW,GAAG,MAAM,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC;IAC/C,IAAI,KAAC,gKAAY,EAAC,WAAW,CAAC,EAAE,CAAC;QAC/B,OAAO,KAAK,CAAC;IACf,CAAC;IACD,MAAM,QAAQ,GAAG,WAAW,CAAC,SAAS,EAAE,CAAC,GAAG,CAAC;IAC7C,IAAI,CAAC,QAAQ,EAAE,CAAC;QACd,OAAO,KAAK,CAAC;IACf,CAAC;IAED,IAAI,YAAY,GAAG,QAAQ,CAAC,IAAI,CAAC;IACjC,QAAI,iKAAa,EAAC,YAAY,CAAC,EAAE,CAAC;QAChC,YAAY,GAAG,YAAY,CAAC,MAAM,CAAC;IACrC,CAAC;IACD,IAAI,KAAC,gKAAY,EAAC,YAAY,CAAC,EAAE,CAAC;QAChC,OAAO,KAAK,CAAC;IACf,CAAC;IACD,OAAO,YAAY,CAAC,IAAI,IAAI,QAAQ,CAAC;AACvC,CAAC"}},
    {"offset": {"line": 8868, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@apollo/server/dist/esm/plugin/usageReporting/plugin.js","sources":["file:///E:/wark/Next.graphQL/nextTyar/node_modules/%40apollo/server/src/plugin/usageReporting/plugin.ts"],"sourcesContent":["import { Report, ReportHeader, Trace } from '@apollo/usage-reporting-protobuf';\nimport type { Fetcher, FetcherResponse } from '@apollo/utils.fetcher';\nimport {\n  usageReportingSignature,\n  calculateReferencedFieldsByType,\n  type ReferencedFieldsByType,\n} from '@apollo/utils.usagereporting';\nimport retry from 'async-retry';\nimport { type GraphQLSchema, printSchema } from 'graphql';\nimport { type LRUCache } from 'lru-cache';\nimport os from 'os';\nimport { gzip } from 'zlib';\nimport type {\n  ApolloServerPlugin,\n  BaseContext,\n  GraphQLRequestContext,\n  GraphQLRequestContextDidResolveOperation,\n  GraphQLRequestContextWillSendResponse,\n  GraphQLRequestListener,\n  GraphQLServerListener,\n} from '../../externalTypes/index.js';\nimport { internalPlugin } from '../../internalPlugin.js';\nimport { dateToProtoTimestamp, TraceTreeBuilder } from '../traceTreeBuilder.js';\nimport { defaultSendOperationsAsTrace } from './defaultSendOperationsAsTrace.js';\nimport {\n  createOperationDerivedDataCache,\n  type OperationDerivedData,\n  operationDerivedDataCacheKey,\n} from './operationDerivedDataCache.js';\nimport type {\n  ApolloServerPluginUsageReportingOptions,\n  SendValuesBaseOptions,\n} from './options.js';\nimport { OurReport } from './stats.js';\nimport { makeTraceDetails } from './traceDetails.js';\nimport { packageVersion } from '../../generated/packageVersion.js';\nimport { computeCoreSchemaHash } from '../../utils/computeCoreSchemaHash.js';\nimport type { HeaderMap } from '../../utils/HeaderMap.js';\nimport { schemaIsSubgraph } from '../schemaIsSubgraph.js';\n\nconst reportHeaderDefaults = {\n  hostname: os.hostname(),\n  agentVersion: `@apollo/server@${packageVersion}`,\n  runtimeVersion: `node ${process.version}`,\n  // XXX not actually uname, but what node has easily.\n  uname: `${os.platform()}, ${os.type()}, ${os.release()}, ${os.arch()})`,\n};\n\nexport function ApolloServerPluginUsageReporting<TContext extends BaseContext>(\n  options: ApolloServerPluginUsageReportingOptions<TContext> = Object.create(\n    null,\n  ),\n): ApolloServerPlugin<TContext> {\n  const fieldLevelInstrumentationOption = options.fieldLevelInstrumentation;\n  const fieldLevelInstrumentation =\n    typeof fieldLevelInstrumentationOption === 'number'\n      ? async () =>\n          Math.random() < fieldLevelInstrumentationOption\n            ? 1 / fieldLevelInstrumentationOption\n            : 0\n      : fieldLevelInstrumentationOption\n        ? fieldLevelInstrumentationOption\n        : async () => true;\n\n  let requestDidStartHandler:\n    | ((\n        requestContext: GraphQLRequestContext<TContext>,\n      ) => GraphQLRequestListener<TContext>)\n    | null = null;\n  return internalPlugin({\n    __internal_plugin_id__: 'UsageReporting',\n    __is_disabled_plugin__: false,\n\n    // We want to be able to access locals from `serverWillStart` in our `requestDidStart`, thus\n    // this little hack. (Perhaps we should also allow GraphQLServerListener to contain\n    // a requestDidStart?)\n    async requestDidStart(requestContext: GraphQLRequestContext<TContext>) {\n      if (requestDidStartHandler) {\n        return requestDidStartHandler(requestContext);\n      }\n      // This happens if usage reporting is disabled (eg because this is a\n      // subgraph).\n      return {};\n    },\n\n    async serverWillStart({\n      logger: serverLogger,\n      apollo,\n      startedInBackground,\n      schema,\n    }): Promise<GraphQLServerListener> {\n      // Use the plugin-specific logger if one is provided; otherwise the general server one.\n      const logger = options.logger ?? serverLogger;\n      const { key, graphRef } = apollo;\n      if (!(key && graphRef)) {\n        throw new Error(\n          \"You've enabled usage reporting via ApolloServerPluginUsageReporting, \" +\n            'but you also need to provide your Apollo API key and graph ref, via ' +\n            'the APOLLO_KEY/APOLLO_GRAPH_REF environment ' +\n            'variables or via `new ApolloServer({apollo: {key, graphRef})`.',\n        );\n      }\n\n      if (schemaIsSubgraph(schema)) {\n        if (options.__onlyIfSchemaIsNotSubgraph) {\n          logger.warn(\n            'You have specified an Apollo API key and graph ref but this server appears ' +\n              'to be a subgraph. Typically usage reports are sent to Apollo by your Router ' +\n              'or Gateway, not directly from your subgraph; usage reporting is disabled. To ' +\n              'enable usage reporting anyway, explicitly install `ApolloServerPluginUsageReporting`. ' +\n              'To disable this warning, install `ApolloServerPluginUsageReportingDisabled`.',\n          );\n          // This early return means we don't start background timers, don't\n          // register serverDidStart, don't assign requestDidStartHandler, etc.\n          return {};\n        } else {\n          // This is just a warning; usage reporting is still enabled. If it\n          // turns out there are lots of people who really need to have this odd\n          // setup and they don't like the warning, we can provide a new option\n          // to disable the warning (or they can filter in their `logger`).\n          logger.warn(\n            'You have installed `ApolloServerPluginUsageReporting` but this server appears to ' +\n              'be a subgraph. Typically usage reports are sent to Apollo by your Router ' +\n              'or Gateway, not directly from your subgraph. If this was unintentional, remove ' +\n              \"`ApolloServerPluginUsageReporting` from your server's `plugins` array.\",\n          );\n        }\n      }\n\n      logger.info(\n        'Apollo usage reporting starting! See your graph at ' +\n          `https://studio.apollographql.com/graph/${encodeURI(graphRef)}/`,\n      );\n\n      // If sendReportsImmediately is not specified, we default to true if we're running\n      // with the ApolloServer designed for Lambda or similar. That's because these\n      // environments aren't designed around letting us run a background task to\n      // send reports later or hook into container destruction to flush buffered reports.\n      const sendReportsImmediately =\n        options.sendReportsImmediately ?? startedInBackground;\n\n      // Since calculating the signature and referenced fields for usage\n      // reporting is potentially an expensive operation, we'll cache the data\n      // we generate and re-use them for repeated operations for the same\n      // `queryHash`. However, because referenced fields depend on the current\n      // schema, we want to throw it out entirely any time the schema changes.\n      let operationDerivedDataCache: {\n        forSchema: GraphQLSchema;\n        cache: LRUCache<string, OperationDerivedData>;\n      } | null = null;\n\n      // This map maps from executable schema ID (schema hash, basically) to the\n      // report we'll send about it. That's because when we're using a gateway,\n      // the schema can change over time, but each report needs to be about a\n      // single schema. We avoid having this function be a memory leak by\n      // removing values from it when we're in the process of sending reports.\n      // That means we have to be very careful never to pull a Report out of it\n      // and hang on to it for a while before writing to it, because the report\n      // might have gotten sent and discarded in the meantime. So you should\n      // only access the values of this Map via\n      // getReportWhichMustBeUsedImmediately and getAndDeleteReport, and never\n      // hang on to the value returned by getReportWhichMustBeUsedImmediately.\n      const reportByExecutableSchemaId = new Map<string, OurReport>();\n      const getReportWhichMustBeUsedImmediately = (\n        executableSchemaId: string,\n      ): OurReport => {\n        const existing = reportByExecutableSchemaId.get(executableSchemaId);\n        if (existing) {\n          return existing;\n        }\n        const report = new OurReport(\n          new ReportHeader({\n            ...reportHeaderDefaults,\n            executableSchemaId,\n            graphRef,\n          }),\n        );\n        reportByExecutableSchemaId.set(executableSchemaId, report);\n        return report;\n      };\n      const getAndDeleteReport = (\n        executableSchemaId: string,\n      ): OurReport | null => {\n        const report = reportByExecutableSchemaId.get(executableSchemaId);\n        if (report) {\n          reportByExecutableSchemaId.delete(executableSchemaId);\n          return report;\n        }\n        return null;\n      };\n\n      const overriddenExecutableSchemaId = options.overrideReportedSchema\n        ? computeCoreSchemaHash(options.overrideReportedSchema)\n        : undefined;\n\n      let lastSeenExecutableSchemaToId:\n        | {\n            executableSchema: GraphQLSchema;\n            executableSchemaId: string;\n          }\n        | undefined;\n\n      let reportTimer: NodeJS.Timeout | undefined;\n      if (!sendReportsImmediately) {\n        reportTimer = setInterval(\n          () => sendAllReportsAndReportErrors(),\n          options.reportIntervalMs || 10 * 1000,\n        );\n      }\n\n      // We don't send traces if the user set `sendTraces: false`. We also may\n      // set this to false later if the usage-reporting ingress informs us that\n      // this graph does not support viewing traces.\n      let sendTraces = options.sendTraces ?? true;\n      const sendOperationAsTrace =\n        options.experimental_sendOperationAsTrace ??\n        defaultSendOperationsAsTrace();\n\n      let stopped = false;\n\n      function executableSchemaIdForSchema(schema: GraphQLSchema) {\n        if (lastSeenExecutableSchemaToId?.executableSchema === schema) {\n          return lastSeenExecutableSchemaToId.executableSchemaId;\n        }\n        const id = computeCoreSchemaHash(printSchema(schema));\n\n        // We override this variable every time we get a new schema so we cache\n        // the last seen value. It is a single-entry cache.\n        lastSeenExecutableSchemaToId = {\n          executableSchema: schema,\n          executableSchemaId: id,\n        };\n\n        return id;\n      }\n\n      async function sendAllReportsAndReportErrors(): Promise<void> {\n        await Promise.all(\n          [...reportByExecutableSchemaId.keys()].map((executableSchemaId) =>\n            sendReportAndReportErrors(executableSchemaId),\n          ),\n        );\n      }\n\n      async function sendReportAndReportErrors(\n        executableSchemaId: string,\n      ): Promise<void> {\n        return sendReport(executableSchemaId).catch((err) => {\n          // This catch block is primarily intended to catch network errors from\n          // the retried request itself, which include network errors and non-2xx\n          // HTTP errors.\n          if (options.reportErrorFunction) {\n            options.reportErrorFunction(err);\n          } else {\n            logger.error(err.message);\n          }\n        });\n      }\n\n      // Needs to be an arrow function to be confident that key is defined.\n      const sendReport = async (executableSchemaId: string): Promise<void> => {\n        let report = getAndDeleteReport(executableSchemaId);\n        if (\n          !report ||\n          (Object.keys(report.tracesPerQuery).length === 0 &&\n            report.operationCount === 0)\n        ) {\n          return;\n        }\n\n        // Set the report's overall end time. This is the timestamp that will be\n        // associated with the summarized statistics.\n        report.endTime = dateToProtoTimestamp(new Date());\n\n        report.ensureCountsAreIntegers();\n\n        const protobufError = Report.verify(report);\n        if (protobufError) {\n          throw new Error(`Error verifying report: ${protobufError}`);\n        }\n        let message: Uint8Array | null = Report.encode(report).finish();\n        // Let the original protobuf object be garbage collected (helpful if the\n        // HTTP request hangs).\n        report = null;\n\n        // Potential follow-up: we can compare message.length to\n        // report.sizeEstimator.bytes and use it to \"learn\" if our estimation is\n        // off and adjust it based on what we learn.\n\n        if (options.debugPrintReports) {\n          // We decode the report rather than printing the original `report`\n          // so that it includes all of the pre-encoded traces.\n          const decodedReport = Report.decode(message);\n          logger.info(\n            `Apollo usage report: ${JSON.stringify(decodedReport.toJSON())}`,\n          );\n        }\n\n        const compressed = await new Promise<Buffer>((resolve, reject) => {\n          gzip(message!, (error, result) => {\n            error ? reject(error) : resolve(result);\n          });\n        });\n        // Let the uncompressed message be garbage collected (helpful if the\n        // HTTP request is slow).\n        message = null;\n\n        // Wrap fetcher with async-retry for automatic retrying\n        const fetcher: Fetcher = options.fetcher ?? fetch;\n        const response: FetcherResponse = await retry(\n          // Retry on network errors and 5xx HTTP\n          // responses.\n          async () => {\n            const curResponse = await fetcher(\n              (options.endpointUrl ||\n                'https://usage-reporting.api.apollographql.com') +\n                '/api/ingress/traces',\n              {\n                method: 'POST',\n                headers: {\n                  'user-agent': 'ApolloServerPluginUsageReporting',\n                  'x-api-key': key,\n                  'content-encoding': 'gzip',\n                  accept: 'application/json',\n                },\n                body: compressed,\n                signal: AbortSignal.timeout(options.requestTimeoutMs ?? 30_000),\n              },\n            );\n\n            if (curResponse.status >= 500 && curResponse.status < 600) {\n              throw new Error(\n                `HTTP status ${curResponse.status}, ${\n                  (await curResponse.text()) || '(no body)'\n                }`,\n              );\n            } else {\n              return curResponse;\n            }\n          },\n          {\n            retries: (options.maxAttempts || 5) - 1,\n            minTimeout: options.minimumRetryDelayMs || 100,\n            factor: 2,\n          },\n        ).catch((err: Error) => {\n          throw new Error(\n            `Error sending report to Apollo servers: ${err.message}`,\n          );\n        });\n\n        if (response.status < 200 || response.status >= 300) {\n          // Note that we don't expect to see a 3xx here because request follows\n          // redirects.\n          throw new Error(\n            `Error sending report to Apollo servers: HTTP status ${\n              response.status\n            }, ${(await response.text()) || '(no body)'}`,\n          );\n        }\n\n        if (\n          sendTraces &&\n          response.status === 200 &&\n          response.headers\n            .get('content-type')\n            ?.match(/^\\s*application\\/json\\s*(?:;|$)/i)\n        ) {\n          const body = await response.text();\n          let parsedBody;\n          try {\n            parsedBody = JSON.parse(body);\n          } catch (e) {\n            throw new Error(`Error parsing response from Apollo servers: ${e}`);\n          }\n          if (parsedBody.tracesIgnored === true) {\n            logger.debug(\n              \"This graph's organization does not have access to traces; sending all \" +\n                'subsequent operations as stats.',\n            );\n            sendTraces = false;\n          }\n        }\n        if (options.debugPrintReports) {\n          logger.info(`Apollo usage report: status ${response.status}`);\n        }\n      };\n\n      requestDidStartHandler = ({\n        metrics,\n        schema,\n        request: { http, variables },\n      }): GraphQLRequestListener<TContext> => {\n        const treeBuilder: TraceTreeBuilder = new TraceTreeBuilder({\n          maskedBy: 'ApolloServerPluginUsageReporting',\n          sendErrors: options.sendErrors,\n        });\n        treeBuilder.startTiming();\n        metrics.startHrTime = treeBuilder.startHrTime;\n        let graphqlValidationFailure = false;\n        let graphqlUnknownOperationName = false;\n        let includeOperationInUsageReporting: boolean | null = null;\n\n        if (http) {\n          treeBuilder.trace.http = new Trace.HTTP({\n            method:\n              Trace.HTTP.Method[\n                http.method as keyof typeof Trace.HTTP.Method\n              ] || Trace.HTTP.Method.UNKNOWN,\n          });\n\n          if (options.sendHeaders) {\n            makeHTTPRequestHeaders(\n              treeBuilder.trace.http,\n              http.headers,\n              options.sendHeaders,\n            );\n          }\n        }\n\n        // After this function completes, includeOperationInUsageReporting is\n        // defined.\n        async function maybeCallIncludeRequestHook(\n          requestContext:\n            | GraphQLRequestContextDidResolveOperation<TContext>\n            | GraphQLRequestContextWillSendResponse<TContext>,\n        ): Promise<void> {\n          // If this is the second call in `willSendResponse` after\n          // `didResolveOperation`, we're done.\n          if (includeOperationInUsageReporting !== null) return;\n\n          if (typeof options.includeRequest !== 'function') {\n            // Default case we always report\n            includeOperationInUsageReporting = true;\n            return;\n          }\n          includeOperationInUsageReporting =\n            await options.includeRequest(requestContext);\n\n          // Help the user understand they've returned an unexpected value,\n          // which might be a subtle mistake.\n          if (typeof includeOperationInUsageReporting !== 'boolean') {\n            logger.warn(\n              \"The 'includeRequest' async predicate function must return a boolean value.\",\n            );\n            includeOperationInUsageReporting = true;\n          }\n        }\n\n        // Our usage reporting groups everything by operation, so we don't\n        // actually report about any issues that prevent us from getting an\n        // operation string (eg, a missing operation, or APQ problems).\n        // This is effectively bypassing the reporting of:\n        //   - PersistedQueryNotFoundError\n        //   - PersistedQueryNotSupportedError\n        //   - Missing `query` error\n        // We may want to report them some other way later!\n        let didResolveSource = false;\n\n        return {\n          async didResolveSource(requestContext) {\n            didResolveSource = true;\n\n            if (metrics.persistedQueryHit) {\n              treeBuilder.trace.persistedQueryHit = true;\n            }\n            if (metrics.persistedQueryRegister) {\n              treeBuilder.trace.persistedQueryRegister = true;\n            }\n\n            if (variables) {\n              treeBuilder.trace.details = makeTraceDetails(\n                variables,\n                options.sendVariableValues,\n                requestContext.source,\n              );\n            }\n\n            const clientInfo = (\n              options.generateClientInfo || defaultGenerateClientInfo\n            )(requestContext);\n            if (clientInfo) {\n              // While there is a clientAddress protobuf field, the backend\n              // doesn't pay attention to it yet, so we'll ignore it for now.\n              const { clientName, clientVersion } = clientInfo;\n              treeBuilder.trace.clientVersion = clientVersion || '';\n              treeBuilder.trace.clientName = clientName || '';\n            }\n          },\n          async validationDidStart() {\n            return async (validationErrors?: ReadonlyArray<Error>) => {\n              graphqlValidationFailure = validationErrors\n                ? validationErrors.length !== 0\n                : false;\n            };\n          },\n          async didResolveOperation(requestContext) {\n            // If operation is undefined then `getOperationAST` returned null\n            // and an unknown operation was specified.\n            graphqlUnknownOperationName =\n              requestContext.operation === undefined;\n            await maybeCallIncludeRequestHook(requestContext);\n\n            if (\n              includeOperationInUsageReporting &&\n              // No need to capture traces if the operation is going to\n              // immediately fail due to unknown operation name.\n              !graphqlUnknownOperationName\n            ) {\n              if (metrics.captureTraces === undefined) {\n                // We're not completely ignoring the operation. But should we\n                // calculate a detailed trace of every field while we do so (either\n                // directly in this plugin, or in a subgraph by sending the\n                // apollo-federation-include-trace header)? That will allow this\n                // operation to contribute to the \"field executions\" column in the\n                // Studio Fields page, to the timing hints in Explorer and\n                // vscode-graphql, and to the traces visible under Operations. (Note\n                // that `true` here does not imply that this operation will\n                // necessarily be *sent* to the usage-reporting endpoint in the form\n                // of a trace --- it still might be aggregated into stats first. But\n                // capturing a trace will mean we can understand exactly what fields\n                // were executed and what their performance was, at the tradeoff of\n                // some overhead for tracking the trace (and transmitting it between\n                // subgraph and gateway).\n                const rawWeight =\n                  await fieldLevelInstrumentation(requestContext);\n                treeBuilder.trace.fieldExecutionWeight =\n                  typeof rawWeight === 'number' ? rawWeight : rawWeight ? 1 : 0;\n\n                metrics.captureTraces =\n                  !!treeBuilder.trace.fieldExecutionWeight;\n              }\n            }\n          },\n          async executionDidStart() {\n            // If we're not capturing traces, don't return a willResolveField so\n            // that we don't build up a detailed trace inside treeBuilder. (We still\n            // will use treeBuilder as a convenient place to put top-level facts\n            // about the operation which can end up aggregated as stats, and we do\n            // eventually put *errors* onto the trace tree.)\n            if (!metrics.captureTraces) return;\n\n            return {\n              willResolveField({ info }) {\n                return treeBuilder.willResolveField(info);\n                // We could save the error into the trace during the end handler, but\n                // it won't have all the information that graphql-js adds to it later,\n                // like 'locations'.\n              },\n            };\n          },\n\n          async didEncounterSubsequentErrors(_requestContext, errors) {\n            treeBuilder.didEncounterErrors(errors);\n          },\n\n          async willSendSubsequentPayload(requestContext, payload) {\n            if (!payload.hasNext) {\n              await operationFinished(requestContext);\n            }\n          },\n\n          async willSendResponse(requestContext) {\n            // Search above for a comment about \"didResolveSource\" to see which\n            // of the pre-source-resolution errors we are intentionally avoiding.\n            if (!didResolveSource) return;\n            if (requestContext.errors) {\n              treeBuilder.didEncounterErrors(requestContext.errors);\n            }\n\n            // If there isn't any defer/stream coming later, we're done.\n            // Otherwise willSendSubsequentPayload will trigger\n            // operationFinished.\n            if (requestContext.response.body.kind === 'single') {\n              await operationFinished(requestContext);\n            }\n          },\n        };\n\n        async function operationFinished(\n          requestContext: GraphQLRequestContextWillSendResponse<TContext>,\n        ) {\n          const resolvedOperation = !!requestContext.operation;\n\n          // If we got an error before we called didResolveOperation (eg parse or\n          // validation error), check to see if we should include the request.\n          await maybeCallIncludeRequestHook(requestContext);\n\n          treeBuilder.stopTiming();\n          const executableSchemaId =\n            overriddenExecutableSchemaId ?? executableSchemaIdForSchema(schema);\n\n          if (includeOperationInUsageReporting === false) {\n            if (resolvedOperation) {\n              getReportWhichMustBeUsedImmediately(executableSchemaId)\n                .operationCount++;\n            }\n            return;\n          }\n\n          treeBuilder.trace.fullQueryCacheHit = !!metrics.responseCacheHit;\n          treeBuilder.trace.forbiddenOperation = !!metrics.forbiddenOperation;\n          treeBuilder.trace.registeredOperation = !!metrics.registeredOperation;\n\n          const policyIfCacheable =\n            requestContext.overallCachePolicy.policyIfCacheable();\n          if (policyIfCacheable) {\n            treeBuilder.trace.cachePolicy = new Trace.CachePolicy({\n              scope:\n                policyIfCacheable.scope === 'PRIVATE'\n                  ? Trace.CachePolicy.Scope.PRIVATE\n                  : policyIfCacheable.scope === 'PUBLIC'\n                    ? Trace.CachePolicy.Scope.PUBLIC\n                    : Trace.CachePolicy.Scope.UNKNOWN,\n              // Convert from seconds to ns.\n              maxAgeNs: policyIfCacheable.maxAge * 1e9,\n            });\n          }\n\n          // If this was a federated operation and we're the gateway, add the query plan\n          // to the trace.\n          if (metrics.queryPlanTrace) {\n            treeBuilder.trace.queryPlan = metrics.queryPlanTrace;\n          }\n\n          // Intentionally un-awaited so as not to block the response.  Any\n          // errors will be logged, but will not manifest a user-facing error.\n          // The logger in this case is a request specific logger OR the logger\n          // defined by the plugin if that's unavailable.  The request-specific\n          // logger is preferred since this is very much coupled directly to a\n          // client-triggered action which might be more granularly tagged by\n          // logging implementations.\n          addTrace().catch(logger.error.bind(logger));\n\n          async function addTrace(): Promise<void> {\n            // Ignore traces that come in after stop().\n            if (stopped) {\n              return;\n            }\n\n            // Ensure that the caller of addTrace (which does not await it) is\n            // not blocked. We use setImmediate rather than process.nextTick or\n            // just relying on the Promise microtask queue because setImmediate\n            // comes after IO, which is what we want.\n            await new Promise((res) => setImmediate(res));\n\n            const executableSchemaId =\n              overriddenExecutableSchemaId ??\n              executableSchemaIdForSchema(schema);\n\n            const { trace } = treeBuilder;\n\n            let statsReportKey: string | undefined = undefined;\n            let referencedFieldsByType: ReferencedFieldsByType;\n            if (!requestContext.document) {\n              statsReportKey = `## GraphQLParseFailure\\n`;\n            } else if (graphqlValidationFailure) {\n              statsReportKey = `## GraphQLValidationFailure\\n`;\n            } else if (graphqlUnknownOperationName) {\n              statsReportKey = `## GraphQLUnknownOperationName\\n`;\n            }\n\n            const isExecutable = statsReportKey === undefined;\n\n            if (statsReportKey) {\n              if (options.sendUnexecutableOperationDocuments) {\n                trace.unexecutedOperationBody = requestContext.source;\n                // Get the operation name from the request (which might not\n                // correspond to an actual operation).\n                trace.unexecutedOperationName =\n                  requestContext.request.operationName || '';\n              }\n              referencedFieldsByType = Object.create(null);\n            } else {\n              const operationDerivedData = getOperationDerivedData();\n              statsReportKey = `# ${requestContext.operationName || '-'}\\n${\n                operationDerivedData.signature\n              }`;\n              referencedFieldsByType =\n                operationDerivedData.referencedFieldsByType;\n            }\n\n            const protobufError = Trace.verify(trace);\n            if (protobufError) {\n              throw new Error(`Error encoding trace: ${protobufError}`);\n            }\n\n            if (resolvedOperation) {\n              getReportWhichMustBeUsedImmediately(executableSchemaId)\n                .operationCount++;\n            }\n\n            getReportWhichMustBeUsedImmediately(executableSchemaId).addTrace({\n              statsReportKey,\n              trace,\n              // We include the operation as a trace (rather than aggregated into stats) only if:\n              // * the user didn't set `sendTraces: false` AND\n              // * it's possible that the organization's plan allows for viewing traces AND\n              // * we captured this as a full trace AND\n              // * gateway reported no errors missing ftv1 data AND\n              // * sendOperationAsTrace says so\n              //\n              // (As an edge case, if the reason metrics.captureTraces is\n              // falsey is that this is an unexecutable operation and thus we\n              // never ran the code in didResolveOperation that sets\n              // metrics.captureTrace, we allow it to be sent as a trace. This\n              // means we'll still send some parse and validation failures as\n              // traces, for the sake of the Errors page.)\n              asTrace:\n                sendTraces &&\n                (!isExecutable || !!metrics.captureTraces) &&\n                !metrics.nonFtv1ErrorPaths?.length &&\n                sendOperationAsTrace(trace, statsReportKey),\n              referencedFieldsByType,\n              nonFtv1ErrorPaths: metrics.nonFtv1ErrorPaths ?? [],\n            });\n\n            // If the buffer gets big (according to our estimate), send.\n            if (\n              sendReportsImmediately ||\n              getReportWhichMustBeUsedImmediately(executableSchemaId)\n                .sizeEstimator.bytes >=\n                (options.maxUncompressedReportSize || 4 * 1024 * 1024)\n            ) {\n              await sendReportAndReportErrors(executableSchemaId);\n            }\n          }\n\n          // Calculates signature and referenced fields for the current document.\n          // Only call this when the document properly parses and validates and\n          // the given operation name (if any) is known!\n          function getOperationDerivedData(): OperationDerivedData {\n            if (!requestContext.document) {\n              // This shouldn't happen: no document means parse failure, which\n              // uses its own special statsReportKey.\n              throw new Error('No document?');\n            }\n\n            const cacheKey = operationDerivedDataCacheKey(\n              requestContext.queryHash,\n              requestContext.operationName || '',\n            );\n\n            // Ensure that the cache we have is for the right schema.\n            if (\n              !operationDerivedDataCache ||\n              operationDerivedDataCache.forSchema !== schema\n            ) {\n              operationDerivedDataCache = {\n                forSchema: schema,\n                cache: createOperationDerivedDataCache({ logger }),\n              };\n            }\n\n            // If we didn't have the signature in the cache, we'll resort to\n            // calculating it.\n            const cachedOperationDerivedData =\n              operationDerivedDataCache.cache.get(cacheKey);\n            if (cachedOperationDerivedData) {\n              return cachedOperationDerivedData;\n            }\n\n            const generatedSignature = (\n              options.calculateSignature || usageReportingSignature\n            )(requestContext.document, requestContext.operationName || '');\n\n            const generatedOperationDerivedData: OperationDerivedData = {\n              signature: generatedSignature,\n              referencedFieldsByType: calculateReferencedFieldsByType({\n                document: requestContext.document,\n                schema,\n                resolvedOperationName: requestContext.operationName ?? null,\n              }),\n            };\n\n            // Note that this cache is always an in-memory cache.\n            // If we replace it with a more generic async cache, we should\n            // not await the write operation.\n            operationDerivedDataCache.cache.set(\n              cacheKey,\n              generatedOperationDerivedData,\n            );\n            return generatedOperationDerivedData;\n          }\n        }\n      };\n\n      return {\n        async serverWillStop() {\n          if (reportTimer) {\n            clearInterval(reportTimer);\n            reportTimer = undefined;\n          }\n\n          stopped = true;\n          await sendAllReportsAndReportErrors();\n        },\n      };\n    },\n  });\n}\n\nexport function makeHTTPRequestHeaders(\n  http: Trace.IHTTP,\n  headers: HeaderMap,\n  sendHeaders?: SendValuesBaseOptions,\n): void {\n  if (\n    !sendHeaders ||\n    ('none' in sendHeaders && sendHeaders.none) ||\n    ('all' in sendHeaders && !sendHeaders.all)\n  ) {\n    return;\n  }\n  for (const [key, value] of headers) {\n    // Note that HeaderMap keys are already lower-case.\n    if (\n      ('exceptNames' in sendHeaders &&\n        // We assume that most users only have a few headers to hide, or will\n        // just set {none: true} ; we can change this linear-time\n        // operation if it causes real performance issues.\n        sendHeaders.exceptNames.some((exceptHeader) => {\n          // Headers are case-insensitive, and should be compared as such.\n          return exceptHeader.toLowerCase() === key;\n        })) ||\n      ('onlyNames' in sendHeaders &&\n        !sendHeaders.onlyNames.some((header) => {\n          return header.toLowerCase() === key;\n        }))\n    ) {\n      continue;\n    }\n\n    switch (key) {\n      case 'authorization':\n      case 'cookie':\n      case 'set-cookie':\n        break;\n      default:\n        http!.requestHeaders![key] = new Trace.HTTP.Values({\n          value: [value],\n        });\n    }\n  }\n}\n\nfunction defaultGenerateClientInfo<TContext extends BaseContext>({\n  request,\n}: GraphQLRequestContext<TContext>) {\n  const clientNameHeaderKey = 'apollographql-client-name';\n  const clientVersionHeaderKey = 'apollographql-client-version';\n\n  // Default to using the `apollo-client-x` header fields if present.\n  // If none are present, fallback on the `clientInfo` query extension\n  // for backwards compatibility.\n  // The default value if neither header values nor query extension is\n  // set is the empty String for all fields (as per protobuf defaults)\n  if (\n    request.http?.headers?.get(clientNameHeaderKey) ||\n    request.http?.headers?.get(clientVersionHeaderKey)\n  ) {\n    return {\n      clientName: request.http?.headers?.get(clientNameHeaderKey),\n      clientVersion: request.http?.headers?.get(clientVersionHeaderKey),\n    };\n  } else if (request.extensions?.clientInfo) {\n    return request.extensions.clientInfo;\n  } else {\n    return {};\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 9317, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@apollo/server/dist/esm/plugin/usageReporting/index.js","sources":["file:///E:/wark/Next.graphQL/nextTyar/node_modules/%40apollo/server/src/plugin/usageReporting/index.ts"],"sourcesContent":["export { ApolloServerPluginUsageReporting } from './plugin.js';\nexport type {\n  ApolloServerPluginUsageReportingOptions,\n  SendValuesBaseOptions,\n  VariableValueOptions,\n  SendErrorsOptions,\n  ClientInfo,\n  GenerateClientInfo,\n} from './options.js';\n"],"names":[],"mappings":";AAAA,OAAO,EAAE,gCAAgC,EAAE,MAAM,aAAa,CAAC"}}]
}